{"pages":[{"title":"About Me","text":"我就是我，不一样的烟火 教育经历 本科就读于兰州理工大学软件工程专业 专业兴趣技能 -Java -大数据 联系我 QQ: 582023774","link":"/about/index.html"},{"title":"归档","text":"","link":"/archives/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"IOC基本原理及相关实现","text":"一、IOC：Inversion of Control 控制反转.指的是 对象的创建权反转(交给)给 Spring. 作用是实现了程序的解耦合. 二、ioc(控制反转)底层原理1、传统方式开发，原始调用类中的方法对于如下类及其方法 123456public class ClassName{ //方法 public void methodName(){ //...... }} 若要调用方法methodName(),原始的做法都是先new一个对象，再用该对象调用类中的方法，即 12ClassName obj = new ClassName();obj.methodName(); 缺陷：耦合度太高 2、利用工厂模式解耦合 工厂模式 123public class Factory{ public static } 3、通过IOC把对象的创建交给spring进行管理第一步；创建xml文件第二部: 创建工厂类(使用dom4j解析配置文件 + 反射) 1234//使用dom4j解析配置文件//使用反射创建类对象class clazz = Class.forName() 三、Spring 中的工厂 通过工厂创建bean对象基本思路是：解析配置文件(配置文件中是类的唯一标识和全限定类名)，利用反射创建实例对象，然后将该标识和获得的对象分别作 key 和 value 封装到 Map 中。最后在静态方法中通过给定的唯一标识获取对应的 value 对象。 1234567891011121314151617181920212223242526272829303132333435363738394041public class BeanFactory { //定义一个Properties对象 private static Properties props; //定义一个Map,用于存放我们要创建的对象。我们把它称之为容器 private static Map&lt;String,Object&gt; beans; //使用静态代码块为Properties对象赋值 static { try { //实例化对象 props = new Properties(); //获取properties文件的流对象 InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;); props.load(in); //实例化容器 beans = new HashMap&lt;String,Object&gt;(); //取出配置文件中所有的Key Enumeration keys = props.keys(); //遍历枚举 while (keys.hasMoreElements()){ //取出每个Key String key = keys.nextElement().toString(); //根据key获取value String beanPath = props.getProperty(key); //反射创建对象 Object value = Class.forName(beanPath).newInstance(); //把key和value存入容器中 beans.put(key,value); } }catch(Exception e){ throw new ExceptionInInitializerError(&quot;初始化properties失败！&quot;); } } /** * 根据bean的名称获取对象 * @param beanName * @return */ public static Object getBean(String beanName){ return beans.get(beanName); } 四、DI :Dependency Injection 依赖注入.需要有 IOC 的环境,Spring 创建这个类的过程中,Spring 将类的依赖的属性设置进去。","link":"/2019/08/19/IOC基本原理及实现/"},{"title":"IO 常用API及基础总结","text":"File类#File 并不是指文件本身两个常量： 路径分隔符File.pathSeparator 名称分隔符File.separator //路径表示的几种形式 //1、windows下 String path = &quot;C:\\\\Users\\\\dell\\\\Desktop&quot;; //2、 path = &quot;C:&quot;+File.separator+&quot;Users&quot;+File.separator+&quot;dell&quot;+File.separator+&quot;Desktop&quot;; //3、推荐方式 path = &quot;C:/Users/dell/Desktop&quot;; IO流基础 一、概念流动、流向 以程序为中心二、IO流分类1、流向: 输入流与输出流 2、数据 字节流:二进制 可以一切文件 包括纯文本 、doc 、音频 、视频等等 字符流:文本文件 只能处理纯文本 3、功能 节点:包裹源头 处理:增强功能，提供性能(提高效率)三、字符流与字节流(重点)1、字节流 输入流:InputStream 输出流:OutputStream 2、字符流 (读入 写出) 输入流:Reader 输出流:Writer四、操作1、与文件建立联系 2、选择流 3、操作 4、释放资源 ###FileWriter写数据### 输出流写数据的步骤： A、创建输出流对象 B、调用输出流对象的写数据方法 并刷新缓冲区 (硬盘存储数据的基本单位是字节) C、释放资源 (close()方法先刷新 再通知系统释放资源) 换行:\\n \\r \\r\\n * windows识别的换行为 \\r\\n * Linux识别的换行为 \\n * mac识别的换行为 \\r ###FileReader读数据### 同 FileWriter写数据 代码实例: * int len; * char[] chs = new char[1024]; * while ((len=fr.read(chs))!=-1) { * System.out.print((new String(chs,0,len))); * } * fr.close(); *注意 char[] chs = new char[1024]; //写1024及其整数倍 *往控制台输出时，不要ln System.out.print(); ###文件复制### 数据源: 目的地: *判断读 //先读 然后写进去 //后写 ###字符缓冲流### (高效地读入和写出) BufferedWriter bf = new BufferedWriter(new FileWriter(&quot;bf.txt&quot;)); BufferedReader br = new BufferedReader(new FileReader(&quot;bf.txt&quot;)); //注意构造方法里面 System.out.print(new String(csh,0,len)); // 缓冲流的特殊功能: newLine() //写一个换行符 这个换行符由系统决定 readLine() //读一行 【不包括换行符】 五、IO 常用API 的测试文件操作File:文件和目录路径名的抽象表示形式，File类的实例是不可变的(即File可以创建实例) ##创建功能 createNewFile() mkdir() mkdirs() ##删除功能 ##判断功能字节流字节缓冲流对象流转换流 (OutputStreamWriter 、 InputStreamReader)可以指定字符集 *实例化转化流，必须先实例化一个字节流*测试转换流 1234567891011121314@Testpublic void testOut() throws IOException { OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;osw.txt&quot;), &quot;UTF-8&quot;); osw.write(&quot;测试写字符，指定字符集为UTF-8&quot;); osw.close();}@Testpublic void testIn() throws IOException { InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;osw.txt&quot;),&quot;UTF-8&quot;); char[] buf = new char[1024]; isr.read(buf); System.out.println(new String(buf)); isr.close();} 缓冲字符流BufferedWriterBufferedReader 1234567891011121314151617@Testpublic void testOut() throws IOException { BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;)); bw.write(&quot;测试字符缓冲流&quot;); bw.flush(); bw.close();}@Testpublic void testIn() throws IOException { BufferedReader br = new BufferedReader(new FileReader(&quot;bw.txt&quot;)); //br.readLine() 读一行，读到最后时返回null String line = &quot;&quot;; while ((line=br.readLine())!=null) { System.out.println(line); } br.close();} 打印流 PrintWriter字符打印流12345678910111213141516/** * 测试打印流 * @throws FileNotFoundException */@Testpublic void testPrint() throws FileNotFoundException { PrintWriter pw = new PrintWriter(&quot;pw.txt&quot;); pw.print(&quot;测试字符打印流&quot;); pw.close();}@Testpublic void testPrintStream() throws FileNotFoundException { PrintStream ps = new PrintStream(&quot;ps.txt&quot;); ps.print(&quot;测试字节打印流&quot;); ps.close();} 六、注意1、字符流的底层，依然是字节流2、File 类只是用来表示目录和文件的相关信息，不对文件内容进行访问 new File(“”); //仅仅是创建一个内存对象3、int read() ; 读取一个字节/(字符)内容，返回将该字节内容存到int类型的低8/(16)位4、操作文件即为节点流5、包装流","link":"/2019/07/15/API常用之-IO/"},{"title":"API常用之--String","text":"charAt 用于给出位置上的字符valueOf 用于将其他类型转换为字符串类型indexOf 用于实现检索substring 获取子串位置trim 去除字符串周围空白","link":"/2019/08/11/API常用之-String/"},{"title":"JSON简单应用","text":"","link":"/2019/08/13/JSON简单应用/"},{"title":"IntelliJ IDEA 常用笔记","text":"IDEA，全称 IntelliJ IDEA，是 Java 语言的集成开发环境，IDEA 在业界被公认为是最好的 java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS 整合、代码审查、创新的 GUI 设计等方面的功能可以说是超常的。 快捷输入psvmsout 类似的：soutp=System.out.println(“方法形参名 = “ + 形参名);soutv=System.out.println(“变量名 = “ + 变量);soutm=System.out.println(“当前类名.当前方法”);“abc”.sout =&gt; System.out.println(“abc”); 快捷键1、Alt+Enter快捷键是Idea中比较特殊的一个快捷键。 失效不起作用：第一步：进入Settings-&gt;Keymap-&gt;搜索：show Intention Actions这个快捷键。第二步：点击：Editor-&gt;intention-&gt;refactorings。将Introduce local variable这个选项勾选上。之后点击Apply，再点击Ok选项。之后就可以正常使用Alt+Enter快捷键了。 主题配置主题下载地址：http://www.easycolor.cc/intelliJidea/list.html 创建模块(Module)在 Eclipse 中我们有 Workspace（工作空间）和 Project（工程）的概念，在 IDEA中只有 Project（工程）和 Module（模块）的概念。这里的对应关系为： IDEA 官网说明：An Eclipse workspace is similar to a project in IntelliJ IDEAAn Eclipse project maps to a module in IntelliJ IDEA 翻译：Eclipse 中 workspace 相当于 IDEA 中的 ProjectEclipse 中 Project 相当于 IDEA 中的 Module 在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module。一个 Project可以有多个 Module。目前主流的大型项目都是分布式部署的，结构都是类似这种多 Module 结构。 模块的删除：先右键–&gt;选择Open Module Settings,点击 -，确认然后再右键删除 常用配置添加依赖 其他关闭打开 IDEA 时为上一次的project Settings –&gt; Appearance &amp; Behavior –&gt; System Settings, 取消 reopen last project on startup 前的勾选即可。","link":"/2019/07/28/IntelliJ-IDEA-常用笔记/"},{"title":"Java中的那些属性和方法","text":"java类的成员变量包括实例变量和类变量，成员方法包括实例方法和类方法。 成员变量实例变量，是新建了实例后才能用的变量 类变量，是不用新建实例，直接通过类来调用的变量。特点是用static修饰。所以它们还有个响当当的名字，叫静态变量。成员变量最大，包括实例变量和类变量，类变量=静态变量 成员方法实例方法类方法注意 在不是继承关系的情况下，每new 一次对象 就生成一个实例变量 总得来说，Java中的属性是绑定到类型上，方法是绑定到对象上","link":"/2019/08/11/Java中的那些属性和方法/"},{"title":"Java面试难点和易混淆点总结(一)","text":"","link":"/2019/07/27/Java面试难点和易混淆点总结-一/"},{"title":"Ajax的原理及实现","text":"一、什么是Ajax二、Ajax工作原理三、Ajax的实现","link":"/2019/07/24/ajax的原理及实现/"},{"title":"About Markdown","text":"一、MarkdownMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持 二、语法2.1 分割线分割线最常使用就是三个或以上*，还可以使用-和_。2.2字体后面俩字加黑 后面俩字斜体 2.3标题效果： 一级标题二级标题三级标题四级标题五级标题六级标题 2.4列表有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项 2 . 第二项 3 . 第三项 2.4.1列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第一个元素 2.5区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号 注意：只需在段落开头写一个 &gt; 即可，不必每行都带 &gt; ,一个区块的内容中间不能写空行。 2.6段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 2.7代码段1234567 for(int j=0;j&lt;=ny;++j) { if(i) DP[i][j]+=DP[i-1][j]; if(j) DP[i][j]+=DP[i][j-1]; DP[i][j]*=!mark[i][j];} 2.8表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 效果如下： 表头 表头 单元格 单元格 单元格 单元格 三、高级技巧3.1转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： 文本加粗** 正常显示星号 **","link":"/2019/07/03/about markdown/"},{"title":"Linux常用命令","text":"命令基本格式 一、常用基本命令1、 cpcp:copy 复制文件cp 源文件 目的地(目录)-p 保留文件原属性-r 复制目录 2、 | 管道output | input对某些命令执行的结果去作操作,会用到管道；用于命令与命令之间的连接，前一个命令的输出是后一个命令的输入 3、 rm rm [filename] remove 删除文件,对 root 用户有提示,普通用户没有提示 -f force 强制删除, root 无提示 -i 普通用户有提示的删除 -r 递归删除,慎重使用 -rf 4、文件的过滤 grep 123456789101112131415grep [OPTIONS] PATTERN [FILE...]过滤带有 [ 字符串 ] 的行grep [ 字符串 ] [ 文件 ] 过滤以 [ 字符串 ] 为开始的行grep [^ 字符串 ] [ 文件 ]过滤以 [ 字符串 ] 为结尾的行grep [ 字符串 $] [ 文件 ]过滤反选grep -v [ 字符串 ] [ 文件 ]eg.过滤以 root 为开始的行 grep ^root /etc/passwd过滤以 bash 为结尾的行grep bash$ /etc/passwd 二、文件操作三、查看日志四、查看进程和端口五、查看系统的状态TOP","link":"/2019/07/22/Linux常用命令/"},{"title":"博客记录","text":"博客搭建博客主题 填过的坑1、关于解决 npm 安装过慢的问题在cmd 命令行将默认源改为淘宝镜像源 2、 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/03/my blog/"},{"title":"mybatis配置中常见错误","text":"mybatis默认的包结构创建文件夹非常不方便，将其改为树形结构点击project右边的设置图标，将 Compact Middle Packages 的勾去掉即可。 环境搭建相关注意SqlMapConfig.xml头错误","link":"/2019/08/10/mybatis配置中常见错误/"},{"title":"sublime text 3 常用笔记","text":"如何运行程序Ctrl+B 运行程序后如何关闭下方方框1、 连按两次 Ctrl + ~ Ctrl + ~为打开Sublime Text 3控制台的快捷键2、 点击Esc键，立竿见影，最为便捷。","link":"/2019/07/27/sublime-text-3-常用笔记/"},{"title":"代理模式","text":"一、代理模式（Proxy Pattern） 代理模式也称为委托模式，是一种结构性设计模式。在代理模式中，一个类代表另一个类的功能。我们创建具有现有对象的对象，以便向外界提供功能接口。 优点可以隐藏委托类的实现;可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。 二、静态代理 静态代理设计模式 * 1、真实角色 * 2、代理角色： 要持有真实角色的引用 * 3、二者要实现相同的接口 12 三、动态代理","link":"/2019/08/23/代理模式/"},{"title":"单例模式","text":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 优点1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 实现方式一：懒汉式（线程不安全）懒汉式：就是用的时候再进行实例化对象。 1234567891011public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 这种实现方式不支持多线程，因为没有同步锁，多线程下不能正常工作。 实现方式二：懒汉式（线程安全）12345678910public class Singleton { private static Singleton instance; public static synchronized Singleton getInstance(){ if (instance == null){ instance = new Singleton(); } return instance; }} 可以在多线程环境下使用，但是效率太低。 优点：一个对象初始化一次，节省内存。缺点：必须用synchronized来维持单例，没效率。 实现方式三：饿汉式（线程安全）1234567public class Singleton { private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; }} 因为它作为静态资源，所以在类装载时就被实例化 优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。 实现方式四：双检锁/双重校验锁DCL（线程安全）1234567891011121314public class Singleton { private static Singleton instance; public static Singleton getInstance(){ if (instance == null){ synchronized (Singleton.class){ if (instance == null){ instance = new Singleton(); } } } return instance; }} 采用双锁机制，安全且在多线程情况下能保持高性能。详细了解请点击：Java并发编程 – 单例模式线程安全问题 实现方式五：登记式/静态内部类（线程安全）1234567891011public class Singleton { private static Singleton instance; private static class SingletonHandler{ private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance(){ return SingletonHandler.INSTANCE; }} 这种方式可以说是恶汉式的变通版，SingletonHandler没有被主动使用的情况下是不会实例化Singleton对象的，所以这样做，既能达到lazy式的加载，又能保证线程安全。 实现方式六：枚举类（线程安全）123456public enum Singleton { INSTANCE; public void myMethod() { System.out.println(&quot;enum instance test&quot;); }} 它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。 测试： 123456public class Main { public static void main(String[] args) { Singleton singleton = Singleton.INSTANCE; singleton.myMethod(); }} 1enum instance test 总结不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。","link":"/2019/07/20/单例模式/"},{"title":"这就是MyBatis","text":"本文将通过对 MyBatis 基础知识的总结，加深对 MyBatis 的理解与应用。 一、MyBatis 框架概述 mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 二、JDBC 的回顾与分析1// 三、MyBatis 框架快速入门四、MyBatis 中的设计模式五、MyBatis 底层原理及其自定义分析六、基于代理 DAO 实现 CRUD 操作七、MyBatis 的参数深入八、MyBatis 的输出结果封装九、SqlMapConfig.xml 配置文件十、MyBatis 连接池与事务深入十一、MyBatis 的动态 SQL 语句十二、MyBatis 多表查询之一对多十三、MyBatis 多表查询之多对多十四、MyBatis 延迟加载策略十五、MyBatis 缓存十六、MyBatis 注解开发","link":"/2019/08/22/这就是MyBatis/"},{"title":"实现状态管理的技术--Cookie和Session","text":"状态管理（数据管理）为什么需要状态管理什么是状态管理 状态指的是数据 管理指的是多次交互时对数据的修改 会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session 浏览器与服务器请求一次连接一次，每次连接服务器默认都不会保存任何数据通过技术手段，保存某次连接的数据，称为状态管理在多次请求中，使用某次请求的数据，必须使用状态管理技术实现状态管理的技术Cookie和Session 浏览器1（卡（华为手机，充电宝）—&gt; 服务器浏览器2（卡（华为手机，充电宝）—&gt;服务器浏览器3（卡（华为手机，充电宝）—&gt;服务器 浏览器1（id号）—&gt;服务器 （卡1（华为手机，充电宝，id号）浏览器2（id号）—&gt;服务器 （卡2（华为手机，充电宝，id号）浏览器3（id号）—&gt;服务器 （卡3（华为手机，充电宝，id号） CookieCookie:保存在浏览器端的文本文件，实现状态管理的方式之一 工作原理：当服务器创建cookie并发送到浏览器，浏览器再次访问服务器会自动将cookie发送到服务器 概念：客户端会话技术，将数据保存到客户端 快速入门： 使用步骤： 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理 基于响应头set-cookie和请求头cookie实现 cookie的细节 一次可不可以发送多个cookie? 可以 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁 持久化存储： setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值 零：删除cookie信息 cookie能不能存中文？ 在tomcat 8 之前 cookie中不能直接存储中文数据。 需要将中文数据转码—一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题？ 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 如果要共享，则可以将path设置为”/“ 2. 不同的tomcat服务器间cookie共享问题？ * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 案例：记住上一次访问时间 需求： 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 分析： 可以采用Cookie来完成 在服务器中的Servlet判断是否有一个名为lastTime的cookie 有：不是第一次访问 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20 写回Cookie：lastTime=2018年6月10日11:50:01 没有：是第一次访问 响应数据：您好，欢迎您首次访问 写回Cookie：lastTime=2018年6月10日11:50:01 cookie保存在浏览器端的文本文件 cookie存储数据大小有限制，不能超过4K cookie只能存储字符串,不能直接保存中文 cookie的数据不安全 cookie有路径的限制，只能读取同一个应用中的cookie同一个应用中，相同路径和子路径可以读取cookie发送cookie之前，都会cookie.serPath(“/“);为了方便读取 浏览器可以禁止cookieCookie的API： 创建cookieCookie c = new Cookie(“name”,”value”); 设置存活时间void setMaxAge(int seconds);-1:保存到浏览器的缓存中=0:cookie的失效，设置为0，被删除状态 0:保存到浏览器所在的磁盘中 设置路径void setPath(String path);cookie.setPat(“/“); 获取名字String getName(); 获取cookie的值String getValue(); 发送cookieresponse.addCookie(cookie); 获取cookieCookie[] cookies = request.getCookies(); 自动记忆账号和密码 代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@WebServlet(&quot;/cookieTest&quot;)public class CookieTest extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置响应的消息体的数据格式以及编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //1.获取所有Cookie Cookie[] cookies = request.getCookies(); boolean flag = false;//没有cookie为lastTime //2.遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0){ for (Cookie cookie : cookies) { //3.获取cookie的名称 String name = cookie.getName(); //4.判断名称是否是：lastTime if(&quot;lastTime&quot;.equals(name)){ //有该Cookie，不是第一次访问 flag = true;//有lastTime的cookie //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); cookie.setValue(str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); //响应数据 //获取Cookie的value，时间 String value = cookie.getValue(); System.out.println(&quot;解码前：&quot;+value); //URL解码： value = URLDecoder.decode(value,&quot;utf-8&quot;); System.out.println(&quot;解码后：&quot;+value); response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次访问时间为:&quot;+value+&quot;&lt;/h1&gt;&quot;); break; } } } if(cookies == null || cookies.length == 0 || flag == false){ //没有，第一次访问 //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); response.getWriter().write(&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); }} Session1、状态（数据）管理-session 会话管理 获取session对象 request.getSession();如果没有查找到session对象，会创建 request.getSession(true);如果没有查找到session对象，会创建 request.getSession(false);如果没有查找到session对象，返回null void setAttribute(String name,Object value);设置属性 Object getAttribute(String name);获取属性 2、基于session实现的功能 保存登录账号信息，所有包含登录功能的系统都必须实现 每个页面显示登录账号 使用session实现系统登录权限验证 3、session的销毁 超时时间 tomcat默认30分钟没有对session的访问 手动销毁 退出 void invalidate(); 4、Session的特点： Session是服务器维护的一个内存对象 Session可以保存任何数据类型 Session保存数据没有大小限制 Session没有路径的限制 Session数据没有安全隐患 默认，如果浏览器禁止cookie，Session也无法使用 5、URL重写 使用Session,防止浏览器禁止cookie 通过编码的方式，传递session的id response.encodeURL(“adminMain.jsp”); http://localhost:8080/day08_ums/adminMain.jsp;jsessionid=048F1A66235BD825944A8B804F131660","link":"/2019/07/24/Cookie和Session/"},{"title":"JDBC连接数据库基本操作","text":"什么是JDBCJAVA提供访问数据库的技术 JDBC如何实现可以操作所有数据库？JDBC提供了统一数据库的操作方式。JDBC是JAVA语言访问数据库的标准技术。提供了一组操作所有数据库的接口 接口 12345interface MyInterface{ public void save(); public void delete(); public void update();} 面向对象中多态MyInterface obj = new OracleClass();obj.save(); 驱动程序例如将数据添加到mysql数据库中,必须由mysql提供class MySqlClass implements MyInterface{ public void save(){ //将数据保存到mysql数据中 }}例如将数据添加到oracle数据库中，必须由oracle提供class OracleClass implements MyInterface{ public void save(){ //将数据保存到oracle数据中 }} * 1、JDBC的编码步骤 1、 加载驱动程序 2、 创建连接 3、 发送SQL INSERT UPDATE DELETE 4、 如果发送的是SELECT语句，处理结果集 5、 释放资源（关闭连接） 项目中业务功能SQL JDBC 技术标准 一组接口 数据库厂商提供驱动程序 JDBC工具类 CRUD 增删改查 模拟注册和登录，使用Statement,需要SQL与JAVA变量拼接，可能会出现SQL注入 Statement stmt = conn.createStatement(); 2、预处理语句对象 PreparedStatement,预处理语句对象，发送并执行SQL语句，是Statement子接口 优点： * 避免出现SQL注入现象 * 提升同一条SQL语句多次执行的效率 * 提升项目中SQL语句的可读性 用法： * SQL 使用?作为变量的占位符 String sql = “SELECT * FROM ajia_user WHERE username=’”+userName+”‘ AND password=’”+password+”‘“; String sql = “SELECT * FROM ajia_user WHERE username=? AND password=?”; String sql = “INSERT INTO ajia_user(id,username,password,email,phone,created,updated) “ + “VALUES(NULL,?,?,?,?,NOW(),NOW())”; String sql = “SELECT * FROM ajia_user WHERE id=?”; String sql = “SELECT * FROM ajia_user”; * 实例化： PreparedStatement pstmt = conn.prepareStatement(String sql); * 装载占位符(?)值 String userName = sc.nextLine(); String password = sc.nextLine(); String sql = &quot;SELECT * FROM ajia_user WHERE username=? AND password=?&quot;; pstmt.setString(1,userName); pstmt.setString(2,password); pstmt.setDouble(3,sal); pstmt.setTimeStamp(4,t); pstmt.setDate(5,d); pstmt.setObject(6,); * 执行SQL int executeUpdate();执行已经被装载值得SQL语句 ResultSet executeQuery();3、JDBC核心API DriverManager,驱动程序管理器Connection getConnection(String url,String user,String password);获取连接的方法url：jdbc:mysql://ip:3306/tedudbjdbc:mysql,主协议，指定调用哪个驱动程序//ip:3306/tedudb，自协议，指定数据库服务器的ip,数据库服务器软件的端口号，数据库名 Connection,连接对象Statement createStatement();PreparedStatement prepareStatement(String sql); Statement,语句对象int executeUpdate(String sql),执行insert,update,delete语句ResultSet executeQuery(String sql);执行select语句 PreparedStatement,语句处理语句对象void setXxx(int index,Xxx value);装载占位符值int executeUpdate(),执行insert,update,delete语句ResultSet executeQuery();执行select语句 关闭连接conn.close(); 4、JDBC事务处理事务：一组操作的逻辑单元 原子性，一致性，隔离性，持久性（ACID） 删除多条记录，修改多条记录，添加多条记录 Connection接口中： void setAutoCommit(boolean isAuto);设置自动提交方式，JDBC中默认自动提交 boolean getAutoCommit();获取JDBC自动提交方式 void commit();提交事务 void rollback();回滚事务 需求：使用JDBC事务，处理转账 t_account:id,username,balance create table t_account( id int(4) auto_increment primary key, username varchar(20), balance double(12,2) ); insert into t_account values(null,’1001’,100000); insert into t_account values(null,’1002’,100000); 5、批处理 create table t_log( id int(8) auto_increment primary key, title varchar(20), content varchar(50) ); 6、实体类 ajia_user 一组private属性 一组属性的setter和getter 重写父类equals(),hashCode(),toString()方法 一组构造器 实现SeriaLizable接口 7、DAO的设计 设计接口 实现类 接口的作用： * 解耦 多层体系结构应用中 视图层 控制层 业务层 持久层 * 扩展功能 1234567891011121314151617interface Hahaha{ public void f();} class Aaaaa implements Hahaha{ public void f(){ }//JDBC,MyBatis } class B{ public void f1(){ //..... Hahaha a = 反射获取Aaaaa对象; a.f(); } }JdbcUtil类： 123456789101112131415161718192021222324252627282930313233343536373839404142public class JdbcUtil { protected static Connection conn = null; private static String className=&quot;com.mysql.jdbc.Driver&quot;; private static String url=&quot;jdbc:mysql://localhost:3306/students_db?useUnicode=true&amp;characterEncoding=utf-8&quot;; private static String uname=&quot;root&quot;; private static String upasswd=&quot;root&quot;; /** * 获取数据库连接对象 * @return */ public static Connection getConn() { try { Class.forName(className); conn = DriverManager.getConnection(url, uname, upasswd); } catch (ClassNotFoundException e) { System.out.println(&quot;找不到驱动程序类 ，加载驱动失败！&quot;); e.printStackTrace() ; } catch (SQLException e) { System.out.println(&quot;数据库连接失败！&quot;); e.printStackTrace() ; } return conn; } /** * 关闭数据库连接 */ public static void closeConn(Connection conn) { try { if (conn!=null) conn.close(); conn = null; // 置null } catch (SQLException e) { System.out.println(&quot;连接关闭失败！&quot;); e.printStackTrace(); } } //测试// public static void main(String[] args) {// Connection conn = getConn();// System.out.println(conn);// }} 2、BaseDao设计 * 增删改方法的设计 * 查询方法的设计 ResultSet:基于连接的结果集 CacheRowSet:基于缓存的结果集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class BaseDao { Connection conn = null; /** 项目中增删改 * Object...param可变长参数 * 修改方法 */ public void update(String sql,Object...params) throws SQLException{ Connection conn = null; try { conn = JdbcUtil.getConn(); PreparedStatement pstmt = conn.prepareStatement(sql); if(params!=null){ for(int i=0;i&lt;params.length;i++ ){ pstmt.setObject(i+1, params[i]); } } pstmt.executeUpdate(); } finally{ JdbcUtil.closeConn(conn); } } /** * 查询方法 */ public ResultSet find(String sql,Object ...params)throws SQLException{ CachedRowSet crs = null; try { conn = JdbcUtil.getConn(); PreparedStatement pstmt = conn.prepareStatement(sql); if(params!=null){ for(int i=0;i&lt;params.length;i++ ){ pstmt.setObject(i+1, params[i]); } } ResultSet rs = pstmt.executeQuery(); //将基于连接的结果集转存到基于缓存的结果集 crs = new CachedRowSetImpl(); crs.populate(rs); } finally{ JdbcUtil.closeConn(conn); } return crs; } /** * 开启事务 */ public void beginTrans() { try { conn = JdbcUtil.getConn(); conn.setAutoCommit(false); // 关闭自动提交 } catch (SQLException e) { e.printStackTrace(); } } /** * 事务的提交 */ public void commit() { if (conn != null) { try { conn.commit(); } catch (SQLException e) { e.printStackTrace(); } } } /** * 事务的回滚 */ public void rollback() { if (conn != null) { try { conn.rollback(); } catch (SQLException e) { e.printStackTrace(); } } }}","link":"/2019/07/24/JDBC连接数据库基本操作/"},{"title":"Java基础面试总结(一)","text":"1. 简单说下什么是跨平台 术语：操作系统指令集、屏蔽系统之间的差异 由于各种操作系统所支持的指令集不是完全一致，所以在操作系统之上加个虚拟机可以来提供统一接口，屏蔽系统之间的差异。 2. Java有几种基本数据类型 有八种基本数据类型。 数据类型 字节 默认值 byte 1 0 short 2 0 int 4 0 long 8 0 float 4 0.0f double 8 0.0d char 2 ‘\\u0000’ boolean 4 false 各自占用几字节也记一下。 Java的默认数据类型1、 3. 面向对象特征面向对象的编程语言有封装、继承 、抽象、多态等4个主要的特征。 封装： 把描述一个对象的属性和行为的代码封装在一个模块中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。 抽象： 把现实生活中的对象抽象为类。分为过程抽象和数据抽象 数据抽象 –&gt;鸟有翅膀,羽毛等(类的属性) 过程抽象 –&gt;鸟会飞,会叫(类的方法) 继承：子类继承父类的特征和行为。子类可以有父类的方法，属性（非private）。子类也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高代码之间的耦合性。 多态： 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定(比如：向上转型，只有运行才能确定其对象属性)。方法覆盖和重载体现了多态性。 4. 为什么要有包装类型 术语：让基本类型也具有对象的特征 基本类型 包装器类型 boolean Boolean char Character int Integer byte Byte short Short long Long float Float double Double 为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型）因为容器都是装object的，这是就需要这些基本类型的包装器类了。 自动装箱：new Integer(6);，底层调用:Integer.valueOf(6) 自动拆箱: int i = new Integer(6);，底层调用i.intValue();方法实现。 123Integer i = 6;Integer j = 6;System.out.println(i==j); 答案在下面这段代码中找： 12345public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);} 二者的区别： 声明方式不同：基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间； 存储方式及位置不同：基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用； 初始值不同：基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null； 使用方式不同：基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。 5.==和equals区别 ==较的是两个引用在内存中指向的是不是同一对象（即同一内存空间），也就是说在内存空间中的存储位置是否一致。如果两个对象的引用相同时（指向同一对象时），“==”操作符返回true，否则返回flase。 equals用来比较某些特征是否一样。我们平时用的String类等的equals方法都是重写后的，实现比较两个对象的内容是否相等。 我们来看看String重写的equals方法： 它不止判断了内存地址，还增加了字符串是否相同的比较。 1234567891011121314151617181920212223242526public boolean equals(Object anObject) { //判断内存地址是否相同 if (this == anObject) { return true; } // 判断参数类型是否是String类型 if (anObject instanceof String) { // 强转 String anotherString = (String)anObject; int n = value.length; // 判断两个字符串长度是否相等 if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; // 一一比较 字符是否相同 while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false;} 6. String、StringBuffer和StringBuilder区别 java中String、StringBuffer、StringBuilder是编程中经常使用的字符串类，他们之间的区别也是经常在面试中会问到的问题。现在总结一下，看看他们的不同与相同。 1. 数据可变和不可变 String底层使用一个不可变的字符数组private final char value[];所以它内容不可变。 StringBuffer和StringBuilder都继承了AbstractStringBuilder底层使用的是可变字符数组：char[] value; 2. 线程安全 StringBuilder是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低。 通过他们的append()方法来看，StringBuffer是有同步锁，而StringBuilder没有： 123456@Overridepublic synchronized StringBuffer append(Object obj) { toStringCache = null; super.append(String.valueOf(obj)); return this;} 12345@Overridepublic StringBuilder append(String str) { super.append(str); return this;} 3. 相同点StringBuilder与StringBuffer有公共父类AbstractStringBuilder。 最后，操作可变字符串速度：StringBuilder &gt; StringBuffer &gt; String，这个答案就显得不足为奇了。 7. 讲一下Java中的集合 Collection下：List系(有序、元素允许重复)和Set系(无序、元素不重复) set根据equals和hashcode判断，一个对象要存储在Set中，必须重写equals和hashCode方法 Map下：HashMap线程不同步；ConcurrentMap线程同步 Collection系列和Map系列：Map是对Collection的补充，两个没什么关系 8. ArrayList和LinkedList区别？ 之前专门有写过ArrayList和LinkedList源码的文章。 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 9. ConcurrentModificationException异常出现的原因123456789101112public class Test { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer integer = iterator.next(); if(integer==2) list.remove(integer); } }} 执行上段代码是有问题的，会抛出ConcurrentModificationException异常。 原因：调用list.remove()方法导致modCount和expectedModCount的值不一致。 1234final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException();} 解决办法：在迭代器中如果要删除元素的话，需要调用Iterator类的remove方法。 123456789101112public class Test { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer integer = iterator.next(); if(integer==2) iterator.remove(); //注意这个地方 } }} 10. HashMap和HashTable、ConcurrentHashMap区别？相同点: HashMap和Hashtable都实现了Map接口 都可以存储key-value数据 不同点： HashMap可以把null作为key或value，HashTable不可以 HashMap线程不安全，效率高。HashTable线程安全，效率低。 HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。 什么是fail-fast?就是最快的时间能把错误抛出而不是让程序执行。 10.2 如何保证线程安全又效率高？Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 ConcurrentHashMap将整个Map分为N个segment(类似HashTable)，可以提供相同的线程安全，但是效率提升N倍，默认N为16。 10.3 我们能否让HashMap同步？HashMap可以通过下面的语句进行同步：Map m = Collections.synchronizeMap(hashMap); 11. 拷贝文件的工具类使用字节流还是字符流 答案：字节流 11.1 什么是字节流，什么是字符流？字节流：传递的是字节（二进制）， 字符流：传递的是字符 11.2 答案我们并不支持下载的文件有没有包含字节流(图片、影像、音源)，所以考虑到通用性，我们会用字节流。 12. 线程创建方式 这个之前自己做过总结，也算比较全面。 方法一：继承Thread类，作为线程对象存在（继承Thread对象）12345678910111213141516171819202122232425262728293031public class CreatThreadDemo1 extends Thread{ /** * 构造方法： 继承父类方法的Thread(String name)；方法 * @param name */ public CreatThreadDemo1(String name){ super(name); } @Override public void run() { while (!interrupted()){ System.out.println(getName()+&quot;线程执行了...&quot;); try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { CreatThreadDemo1 d1 = new CreatThreadDemo1(&quot;first&quot;); CreatThreadDemo1 d2 = new CreatThreadDemo1(&quot;second&quot;); d1.start(); d2.start(); d1.interrupt(); //中断第一个线程 }} 常规方法，不多做介绍了，interrupted方法，是来判断该线程是否被中断。（终止线程不允许用stop方法，该方法不会施放占用的资源。所以我们在设计程序的时候，要按照中断线程的思维去设计，就像上面的代码一样）。 让线程等待的方法 Thread.sleep(200); //线程休息2ms Object.wait()； //让线程进入等待，直到调用Object的notify或者notifyAll时，线程停止休眠 方法二：实现runnable接口，作为线程任务存在123456789101112131415public class CreatThreadDemo2 implements Runnable { @Override public void run() { while (true){ System.out.println(&quot;线程执行了...&quot;); } } public static void main(String[] args) { //将线程任务传给线程对象 Thread thread = new Thread(new CreatThreadDemo2()); //启动线程 thread.start(); }} Runnable 只是来修饰线程所执行的任务，它不是一个线程对象。想要启动Runnable对象，必须将它放到一个线程对象里。 方法三：匿名内部类创建线程对象12345678910111213141516171819202122232425262728293031public class CreatThreadDemo3 extends Thread{ public static void main(String[] args) { //创建无参线程对象 new Thread(){ @Override public void run() { System.out.println(&quot;线程执行了...&quot;); } }.start(); //创建带线程任务的线程对象 new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;线程执行了...&quot;); } }).start(); //创建带线程任务并且重写run方法的线程对象 new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;runnable run 线程执行了...&quot;); } }){ @Override public void run() { System.out.println(&quot;override run 线程执行了...&quot;); } }.start(); }} 创建带线程任务并且重写run方法的线程对象中，为什么只运行了Thread的run方法。我们看看Thread类的源码，，我们可以看到Thread实现了Runnable接口，而Runnable接口里有一个run方法。所以，我们最终调用的重写的方法应该是Thread类的run方法。而不是Runnable接口的run方法。 方法四：创建带返回值的线程12345678910111213141516171819202122232425public class CreatThreadDemo4 implements Callable { public static void main(String[] args) throws ExecutionException, InterruptedException { CreatThreadDemo4 demo4 = new CreatThreadDemo4(); FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(demo4); //FutureTask最终实现的是runnable接口 Thread thread = new Thread(task); thread.start(); System.out.println(&quot;我可以在这里做点别的业务逻辑...因为FutureTask是提前完成任务&quot;); //拿出线程执行的返回值 Integer result = task.get(); System.out.println(&quot;线程中运算的结果为:&quot;+result); } //重写Callable接口的call方法 @Override public Object call() throws Exception { int result = 1; System.out.println(&quot;业务逻辑计算中...&quot;); Thread.sleep(3000); return result; }} Callable接口介绍： 123456789public interface Callable&lt;V&gt; { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;} 返回指定泛型的call方法。然后调用FutureTask对象的get方法得道call方法的返回值。 方法五：定时器Timer1234567891011121314public class CreatThreadDemo5 { public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(&quot;定时器线程执行了...&quot;); } },0,1000); //延迟0，周期1s }} 方法六：线程池创建线程123456789101112131415161718192021public class CreatThreadDemo6 { public static void main(String[] args) { //创建一个具有10个线程的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); long threadpoolUseTime = System.currentTimeMillis(); for (int i = 0;i&lt;10;i++){ threadPool.execute(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName()+&quot;线程执行了...&quot;); } }); } long threadpoolUseTime1 = System.currentTimeMillis(); System.out.println(&quot;多线程用时&quot;+(threadpoolUseTime1-threadpoolUseTime)); //销毁线程池 threadPool.shutdown(); threadpoolUseTime = System.currentTimeMillis(); }} 方法七：利用java8新特性 stream 实现并发lambda表达式不懂的，可以看看我的java8新特性文章： java8-lambda：https://www.jianshu.com/p/3a08dc78a05f java8-stream：https://www.jianshu.com/p/ea16d6712a00 12345678910public class CreatThreadDemo7 { public static void main(String[] args) { List&lt;Integer&gt; values = Arrays.asList(10,20,30,40); //parallel 平行的，并行的 int result = values.parallelStream().mapToInt(p -&gt; p*2).sum(); System.out.println(result); //怎么证明它是并发处理呢 values.parallelStream().forEach(p-&gt; System.out.println(p)); }} 1234520040102030 怎么证明它是并发处理呢,他们并不是按照顺序输出的 。","link":"/2019/07/26/Java基础面试总结-一/"},{"title":"Java基础面试总结(三)","text":"1. 谈谈对象的访问定位对象创建起来之后，就会在虚拟机栈中维护一个本地变量表，用于存储基础类型和基础类型的值，引用类型与引用类型的值。其中引用类型的值就是堆中对象地址。如何引用堆中地址有两种方式： 句柄：在堆中维护一个句柄池，句柄中包含了对象地址，当对象改变的时候，只需改变句柄，不需要改变栈中本地变量表的引用 直接指针：对象的地址直接存储在栈中，这样做的好处就是访问速度变快（Hotspot采用该方式） 2. JVM将内存主要划分为哪五部分方法区、虚拟机栈、本地方法栈、堆、程序计数器。 3. String的intern()函数作用这个要分版本来回答： 如果是JDK6，如果字符串产量池先前已经创建该对象，则返回引用；否则将其添加到字符串常量池并返回引用。 如果是JDK6+，若字符串常量池有则返回引用，如果池中没有堆中有，则将堆中的引用添加到池中(注意是引用),然后返回引用；若池中也没有，则在池中创建并返回引用。 4. 本地方法栈和虚拟机栈区别本地方法栈与虚拟机栈所发挥的作用很相似，他们的区别在于虚拟机栈为执行Java代码方法服务，而本地方法栈是为Native方法服务。 5. 分配堆内存指令1-Xms -Xmx 前者是堆的初始值，后者是堆能达到的最大值。 6. 程序计数器作用记录当前线程锁执行的字节码的行号。 程序计数器是一块较小的内存空间。 处于线程独占区。 执行java方法时，它记录正在执行的虚拟机字节码指令地址。执行native方法，它的值为undefined 该区域是唯一一个没有规定任何OutOfMemoryError的区域 7. 如何将字符串反转？ 通过 charAt(int index)返回char值进行字符串拼接 调用StringBuffer中的reverse方法 8. Collection 和 Collections 有什么区别？ Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 9. 在 Queue 中 poll()和 remove()有什么区别？ queue的增加元素方法add和offer的区别在于，add方法在队列满的情况下将选择抛异常的方法来表示队列已经满了，而offer方法通过返回false表示队列已经满了；在有限队列的情况，使用offer方法优于add方法； remove方法和poll方法都是删除队列的头元素，remove方法在队列为空的情况下将抛异常，而poll方法将返回null； element和peek方法都是返回队列的头元素，但是不删除头元素，区别在与element方法在队列为空的情况下，将抛异常，而peek方法将返回null. 10. 什么是迭代器Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包括了可以返回迭代器实例的迭代方法。迭代器可以在迭代过程中删除底层集合的元素，但是不可以直接调用集合的remove(Object obj)删除，可以通过迭代器的remove()方法删除 11. 迭代器的优点如果用的是for循环，就用集合自带的remove(),而这样就改变了集合的Size（）循环的时候会出错。但如果把集合放入迭代器，既iterator迭代可以遍历并选择集合中的每个对象而不改变集合的结构，而把集合放入迭代器，用迭代器的remove（）就不会出现问题 12. Java集合类中的Iterator和ListIterator的区别对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面： iterator()方法在set和list接口中都有定义，但是ListIterator()仅存在于list接口中（或实现类中）； ListIterator有add()方法，可以向List中添加对象，而Iterator不能 ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。 ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。 13. 怎么确保一个集合不能被修改？ Java中提供final关键字，对基本类型进行修饰，当第一次初始化后，该变量就不可被修改 Collections工具类中的UnmodifiableList(不可修改的List、Map、Set等) 14. 并行和并发区别并发的关键是你有处理多个任务的能力，不一定要同时。 15. 说一下你对Daemon线程(守护线程)的理解？它有什么意义？一般应用于什么样的场景？所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因 此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。 守护线程和用户线程的没啥本质的区别：唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。 16. sleep() 和 wait() 有什么区别？ 对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。 而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。 17. notify 和 notifyAll 区别notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。换言之，如果只有一个线程在等待一个信号灯，notify和notifyAll都会通知到这个线程。但如果多个线程在等待这个信号灯，那么notify只会通知到其中一个，而其它线程并不会收到任何通知，而notifyAll会唤醒所有等待中的线程。 18. 线程中start()和run()的区别 每个线程都有要执行的任务。线程的任务处理逻辑可以在Tread类的run实例方法中直接实现或通过该方法进行调用，因此run()相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。 而start()的作用是启动相应的线程。启动一个线程实际是请求Java虚拟机运行相应的线程，而这个线程何时能够运行是由线程调度器决定的。start()调用结束并不表示相应线程已经开始运行，这个线程可能稍后运行，也可能永远也不会运行。 19. 线程池的五种状态线程池的5种状态：Running、ShutDown、Stop、Tidying、Terminated。 20. 线程池中 submit()和 execute()方法有什么区别？ execute(Runnable x) 没有返回值。可以执行任务，但无法判断任务是否成功完成。——实现Runnable接口 submit(Runnable x) 返回一个future。可以用这个future来判断任务是否成功完成。——实现Callable接口","link":"/2019/07/27/Java基础面试总结-三/"},{"title":"ArrayList源码分析","text":"简介 ArrayList是我们开发中非常常用的数据存储容器之一，其底层是数组实现的，我们可以在集合中存储任意类型的数据，ArrayList是线程不安全的，非常适合用于对元素进行查找，效率非常高。 线程安全性对ArrayList的操作一般分为两个步骤，改变位置(size)和操作元素(e)。所以这个过程在多线程的环境下是不能保证具有原子性的，因此ArrayList在多线程的环境下是线程不安全的。 源码分析1. 属性分析1234567891011121314151617181920212223242526272829303132/** * 默认初始化容量 */private static final int DEFAULT_CAPACITY = 10;/** * 如果自定义容量为0，则会默认用它来初始化ArrayList。或者用于空数组替换。 */private static final Object[] EMPTY_ELEMENTDATA = {};/** * 如果没有自定义容量，则会使用它来初始化ArrayList。或者用于空数组比对。 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};/** * 这就是ArrayList底层用到的数组 * 非私有，以简化嵌套类访问 * transient 在已经实现序列化的类中，不允许某变量序列化 */transient Object[] elementData;/** * 实际ArrayList集合大小 */private int size;/** * 可分配的最大容量 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 扩展：什么是序列化序列化是指：将对象转换成以字节序列的形式来表示，以便用于持久化和传输。 实现方法：实现Serializable接口。 然后用的时候拿出来进行反序列化即可又变成Java对象。 transient关键字解析 Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化。 有了transient关键字声明，则这个变量不会参与序列化操作，即使所在类实现了Serializable接口，反序列化后该变量为空值。 那么问题来了：ArrayList中数组声明：transient Object[] elementData;，事实上我们使用ArrayList在网络传输用的很正常，并没有出现空值。 原来：ArrayList在序列化的时候会调用writeObject()方法，将size和element写入ObjectOutputStream；反序列化时调用readObject()，从ObjectInputStream获取size和element，再恢复到elementData。 那为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？ 原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。 2. 构造方法分析根据initialCapacity 初始化一个空数组，如果值为0，则初始化一个空数组: 12345678910111213/** * 根据initialCapacity 初始化一个空数组 */public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); }} 不带参数初始化，默认容量为10: 123456/** * 不带参数初始化，默认容量为10 */public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;} 通过集合做参数的形式初始化：如果集合为空，则初始化为空数组： 1234567891011121314/** * 通过集合做参数的形式初始化 */public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; }} 3. 主干方法trimToSize()方法： 用来最小化实例存储，将容器大小调整为当前元素所占用的容量大小。 1234567891011/** * 这个方法用来最小化实例存储。 */public void trimToSize() { modCount++; if (size &lt; elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); }} clone()方法 用来克隆出一个新数组。 1234567891011public Object clone() { try { ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(e); }} 通过调用Object的clone()方法来得到一个新的ArrayList对象，然后将elementData复制给该对象并返回。 add(E e)方法 在数组末尾添加元素 12345678/** * 在数组末尾添加元素 */public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;} 看到它首先调用了ensureCapacityInternal()方法.注意参数是size+1,这是个面试考点。 123private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));} 这个方法里又嵌套调用了两个方法:计算容量+确保容量 计算容量：如果elementData是空，则返回默认容量10和size+1的最大值，否则返回size+1 123456private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity;} 计算完容量后，进行确保容量可用：(modCount不用理它，它用来计算修改次数) 如果size+1 &gt; elementData.length证明数组已经放满，则增加容量，调用grow()。 1234567private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);} 增加容量：默认1.5倍扩容。 获取当前数组长度=&gt;oldCapacity oldCapacity&gt;&gt;1 表示将oldCapacity右移一位(位运算)，相当于除2。再加上1，相当于新容量扩容1.5倍。 如果newCapacity&lt;minCapacity，则newCapacity = minCapacity。看例子更明白一点：假设size为1,则minCapacity=size+1=2,而elementData.length=1,newCapacity=1+1&gt;&gt;1=1,1&lt;2所以如果不处理该情况，扩容将不能正确完成。 如果新容量比最大值还要大，则将新容量赋值为VM要求最大值。 将elementData拷贝到一个新的容量中。 1234567891011private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);} size+1的问题 好了，那到这里可以说一下为什么要size+1。 size+1代表的含义是： 如果集合添加元素成功后，集合中的实际元素个数。 为了确保扩容不会出现错误。 假如不加一处理，如果默认size是0，则0+0&gt;&gt;1还是0。如果size是1，则1+1&gt;&gt;1还是1。有人问:不是默认容量大小是10吗?事实上，jdk1.8版本以后，ArrayList的扩容放在add()方法中。之前放在构造方法中。我用的是1.8版本，所以默认ArrayList arrayList = new ArrayList();后，size应该是0.所以,size+1对扩容来讲很必要. 123456public static void main(String[] args) { ArrayList arrayList = new ArrayList(); System.out.println(arrayList.size());}输出:0 事实上上面的代码是证明不了容量大小的，因为size只会在调用add()方法时才会自增。有办法的小伙伴可以在评论区大显神通。 add(int index, E element)方法123456789public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;} rangeCheckForAdd()是越界异常检测方法。ensureCapacityInternal()之前有讲，着重说一下System.arrayCopy方法： 1234567public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)代码解释: Object src : 原数组 int srcPos : 从元数据的起始位置开始 Object dest : 目标数组 int destPos : 目标数组的开始起始位置 int length : 要copy的数组的长度 示例：size为6，我们调用add(2,element)方法，则会从index=2+1=3的位置开始，将数组元素替换为从index起始位置为index=2，长度为6-2=4的数据。 异常处理： 1234private void rangeCheckForAdd(int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));} set(int index,E element)方法1234567891011public E set(int index, E element) { rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;}E elementData(int index) { return (E) elementData[index];} 逻辑很简单，覆盖旧值并返回。 indexOf(Object o)方法 根据Object对象获取数组中的索引值。 123456789101112public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1;} 如果o为空，则返回数组中第一个为空的索引；不为空也类似。 注意：通过源码可以看到，该方法是允许传空值进来的。 get(int index)方法 返回指定下标处的元素的值。 12345public E get(int index) { rangeCheck(index); return elementData(index);} rangeCheck(index)会检测index值是否合法，如果合法则返回索引对应的值。 remove(int index)方法 删除指定下标的元素。 12345678910111213141516public E remove(int index) { // 检测index是否合法 rangeCheck(index); // 数据结构修改次数 modCount++; E oldValue = elementData(index); // 记住这个算法 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;} 这里又碰到了System.arraycopy()方法，详情请查阅上文。 大概思路：将该元素后面的元素前移，最后一个元素置空。 ArrayList优缺点优点： 因为其底层是数组，所以修改和查询效率高。 可自动扩容(1.5倍)。 缺点： 插入和删除效率不高。 线程不安全。 那面试手写ArrayList应该就不是问题了。","link":"/2019/07/15/arrayList源码分析/"},{"title":"Java 多线程基础总结","text":"本文是Java多线程的基础入门篇 一、程序 进程 线程 程序：指令集，静态概念 进程：操作系统调度程序，动态概念 线程：在进程内多条执行路径 线程是进程中包含的一个或多个执行单元。线程只能归属一个进程。并且线程只能访问该进程所拥有的资源。当操作系统创建一个进程，该进程会自动申请一个主线程作为首要执行的任务。线程之间是独立的 一个进程内可以有多条并行的线程一个线程是进程的一个执行单元同类的多个线程共享一块内存空间和一组资源。线程本身是一个有可供程序执行的堆栈。线程的切换耗时小，把线程称为轻负荷进程。 进程和线程的关系： 1.一个进程至少要有一个线程。 2.线程的划分尺度一定是小于进程。 3.多个进程在执行过程中拥有独立的内存单元。 4.而多个线程共享内存。 5.线程在执行过程中与进程的区别在于每个独立的线程都有一个程序的执行入口，顺序执行，并有一个程序的执行出口。 6.从逻辑角度讲，多线程的意义在于一个应用程序中，有多个执行部分可以并发运行，但操作系统并没有将多个线程看作独立的应用来实现进程的调度和管理以及资源分配。 线程和进程的区别 根本区别：线程作为资源分配的单位 进程是调度和执行的单位 线程是进程的一部分 线程是不同的执行路径 并发：多个线程”同时”进行(),实际上多个线程是并发运行的。操作系统将运行时的多个线程以时间片段划分，在不同的时间片段中随机切换。Java支持多线，即在Java应用程序中，可以创建多个线程，多个线程可以并发运行。 二、线程创建之一 继承Thread +run(线程体) 启动：创建子类对象 +对象.start() 1234567891011121314151617181920/** * 继承Thread类，定义线程类 * @author gavino */public class MyThread extends Thread { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(i); } }}public class Test { public static void main(String[] args) { MyThread t1 = new MyThread();//创建线程对象 t1.start();//启动线程 MyThread t2 = new MyThread(); t2.start(); }}继承Thread类方式的缺点 三、静态代理模式* 1、真实角色* 2、代理角色： 要持有真实角色的引用* 3、二者要实现相同的接口 四、线程创建之二 类实现Runnable接口 +重写run(线程体)方法 –&gt;真实角色类 启动： 1、创建真实角色 2、创建代理角色(Thread类) +真实角色引用 3、代理对象.start() 123456789101112131415161718192021222324252627/** * 实现 Runnable 接口创建线程 描述的是线程任务，而不是线程 * 所以不能直接启动 * @author gavino */public class MyThread implements Runnable { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(i); } }}/** * Runnable 接口，是线程任务的规范接口，实现Runnable接口的类，描述的是线程任务 * 可以使用一个Thread对象封装一个实现Runnable接口对象，进而实现多线程。 * @author gavino */public class Test { public static void main(String[] args) { Runnable r1 = new MyThread();//创建一个任务对象 Thread t1 = new Thread(r1);//创建一个线程对象 t1.start(); Thread t2 = new Thread(r1);//创建第二个线程对象 t2.start(); }}匿名内部类创建并启动线程 12345678910public static void main(String[] args) { new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(&quot;匿名内部类多线程&quot;+i); } } }).start();} 两种线程的区别 继承类，不能实现多个线程共享同一个实例资源实现接口，任务模块化，多个线程可以共享同一个资源 继承类，就不能继承其它类，有单继承局限性实现接口，还可以继承其他的父类 推荐使用Runnable创建线程1）避免单继承的局限性2）便于共享资源 五、线程创建之三 类实现Callable接口 run方法的缺点：1、不能抛异常2、没有返回值 Callable创建线程：优点–可以获取返回值，缺点–比较繁琐 1）创建Callable实现类 +重写call()方法2）借助执行调度服务ExecutorService获取Future对象 ExecutorService ser = Executors.newFixedThreadPool(线程数量); Future result = ser.submit(实现类对象);3）获取值 result.get();4）停止服务 ser.shutdown(); 六、线程状态与停止线程、线程阻塞(一)线程状态 新建状态(new): 创建一个线程对象 就绪状态(Runnable): 线程对象创建以后，调用start()方法，就绪状态的线程只处于等待cpu的使用权。变为可运行。 运行状态(Running): 就绪状态的线程，获取到了cpu资源，执行程序代码。 阻塞状态(Blocked): 等待阻塞 调用wait()方法 没有占用cpu资源，也没有处于排队等待cpu状态 睡眠阻塞 调用sleep()方法 占用cpu资源，也没有处于排队等待cpu状态 IO阻塞 进入IO操作，线程即进入到IO阻塞状态，当IO操作结束，即结束IO阻塞状态 死亡状态(Dead): 线程任务执行结束 即run()结束，该线程对象就会垃圾回收 (二)停止线程 自然终止：线程体正常执行完毕。 外部干涉： 线程类中定义线程体使用的标识 线程体使用该标识 提供对外的方法改变该标识 外部根据条件调用该方法即可 (三)线程阻塞 join:合并线程(调用 join() 后，线程会等待 join() 所属线程运行结束后再继续运行。) yield：(屈服，让步)暂停自己的线程(从运行状态切换到就绪状态)就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行 注意是让自己或者其他线程运行，并不是单纯的让给其他线程。 sleep:休眠(暂停当前线程) 不释放锁 常用于两种形式 与时间相关的 如倒计时 模拟网络延时 七、线程基本信息-优先级 优先级不代表执行的先后顺序 代表概率 MAX_PRIORITY 10 NORM_PRIORITY 5(默认) MIN_PRIORITY 1 *setPriority() 设置优先级 123456789101112131415161718192021222324252627282930313233/** * 测试线程的优先级 * @author gavino */public class Test { public static void main(String[] args) { for (int i = 0; i &lt; 10; i++) { System.out.println(i+&quot; 线程：&quot;+Thread.currentThread().getName()+&quot; 优先级：&quot;+Thread.currentThread().getPriority()); } MyRun r1 = new MyRun(); MyRun r2 = new MyRun(); Thread t1 = new Thread(r1); t1.setName(&quot;t1&quot;); Thread t2 = new Thread(r2); t2.setName(&quot;t2&quot;); //获取线程的优先级// System.out.println(t1.getPriority());// System.out.println(t2.getPriority()); //设置线程优先级 t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(Thread.MIN_PRIORITY); t1.start(); t2.start(); }}class MyRun implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(i+&quot; 线程：&quot;+Thread.currentThread().getName()+&quot; 优先级：&quot;+Thread.currentThread().getPriority()); } }} 执行结果： 123456789101112130 线程：main 优先级：51 线程：main 优先级：52 线程：main 优先级：5...0 线程：t1 优先级：101 线程：t1 优先级：102 线程：t1 优先级：100 线程：t2 优先级：13 线程：t1 优先级：10...1 线程：t2 优先级：12 线程：t2 优先级：1... 线程类中常用的API currentThread()：当前线程 getName()：设置名称 setName(): 获取名称 isAlive()：判断状态 setDaemon(): 设置一个线程为守护(后台)线程 八、线程同步与锁定 可能出现线程安全问题的条件 多个线程访问统一资源 多行代码对同一个变量进行运算 同步：并发 多个线程访问同一份资源 确保资源安全 –&gt;线程安全（常说 Hashtable是线程安全的 HashMap是线程不安全的）synchronized–&gt;同步异步: synchronized可以修饰一段代码或方法(一)、同步块synchronized(引用类型|this|类.class) {}(二)、同步方法synchronized 修饰方法，将方法添加锁，JVM每次调用方法，都会处理锁(线程安全的方法效率低)public synchronized void method(){…}-——————————————————-* 实例方法，this为默认的锁对象* 类方法，当前类的字节码对象作为锁* 同步代码段锁，可以是任意对象锁 单例设计模式：确保一个类只有一个对象(该对象为内部自己创建，外部只能调用这一个对象) #【确保一个类只有一个对象】 懒汉式：(前面懒得创建对象，在使用的时候再创建对象) 1、构造器私有化 避免外部直接创建对象 2、声明一个私有的静态变量(属性) 3、创建一个对外的公共的静态方法 访问该变量，如果变量没有对象 创建该对象 饿汉式： 1、构造器私有化 避免外部直接创建对象 2、声明一个私有的静态变量(属性)，同时创建对象 3、创建一个对外的公共的静态方法 访问该变量 九、死锁 过多的同步容易造成死锁 123456789101112synchronized(o1){ ...... synchronized(02){ ...... }}synchronized(02){ ...... synchronized(01){ ..... }} 模拟线程死锁现象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @author gavino 模拟线程死锁现象 * 不同的线程分别占用对方需要的同步资源 * 都在等待对方放弃自己需要的同步资源 * * 出现死锁后，不会出现异常 */public class Demo { public static void main(String[] args) { MyLock myLock = new MyLock(); YouLock youLock = new YouLock(); StringBuilder sb = new StringBuilder(); Thread t1 = new Thread(new Runnable() { @Override public void run() { synchronized (myLock) { sb.append(&quot;my lock&quot;); sb.append(&quot;hehehe&quot;); System.out.println(sb); synchronized (youLock) { sb.append(&quot;your lock&quot;); sb.append(&quot;hahaha&quot;); System.out.println(sb); } } } }); Thread t2 = new Thread(new Runnable() { @Override public void run() { synchronized (youLock) { sb.append(&quot;your lock&quot;); sb.append(&quot;hahaha&quot;); System.out.println(sb); synchronized (myLock) { sb.append(&quot;my lock&quot;); sb.append(&quot;hehehe&quot;); System.out.println(sb); } } } }); t1.start(); t2.start(); }}class MyLock {}class YouLock {} 解决方法：生产者消费者模式（此处不指设计模式） 即：（过马路）信号灯法（标志位） 信号灯:flag 思路: flag–&gt;T 生产者生产 消费者等待 生产完成后通知消费 flag–&gt;F 消费者消费 生产者等待 消费完成后通知生产 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * 一个场景 共同的资源 */public class Product { //信号灯 private boolean flag = true; private String pro; //生产功能 public synchronized void produce(String pro) { if (!flag) { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //开始生产 try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;生产了&quot;+pro); //生产完毕 this.pro = pro ; //通知消费 this.notify(); //停止生产 this.flag = false; } //消费功能 public synchronized void consume() { if (flag) { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //开始消费 try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } //消费完毕 System.out.println(&quot;消费了&quot;+pro); //通知生产 this.notifyAll(); //停止消费 this.flag = true; }}定义生产者 12345678910111213141516171819/* * 生产者 */public class Producer implements Runnable { private Product p; Producer(Product p) { this.p = p; } @Override public void run() { for(int i=0;i&lt;20;i++) { if(0==i%2) { p.produce(&quot;产品A&quot;); }else { p.produce(&quot;产品B&quot;); } } }} 定义消费者 123456789101112131415/* * 消费者 */public class Consumer implements Runnable { private Product p; Consumer(Product p) { this.p = p; } @Override public void run() { for (int i = 0; i &lt; 20; i++) { p.consume(); } }} 应用 123456789public static void main(String[] args) { //公共资源 产品 Product product = new Product(); //多线程 不同的对象访问同一份资源 Producer p = new Producer(product); Consumer c = new Consumer(product); new Thread(p).start(); new Thread(c).start();} 注意wait():等待 释放锁sleep()不释放锁notify()/notifyAll():唤醒wait() notify()/notifyAll()和synchronized一同使用-—————————————————wait和notify是object的方法，也就是说所有对象都有这两个方法。这两个方法可以用来阻塞当前线程（同时放弃互斥锁）或者是唤醒其他调用wait方法陷入阻塞的线程（不能唤醒那些因为抢占锁而阻塞的队列）。能够执行wait和notify的前提是代码已经进入了synchronized包含的代码块中。 十、任务调度Timerschedule()quartz 框架 十一、总结 重点：* 创建线程* 终止线程* sleep* 同步(面试中) 拓展JUC: 在 Java 5.0 提供了 java.util.concurrent(简称JUC)包,在此包中增加了在并发编程中很常用的工具类,用于定义类似于线程的自定义子系统,包括线程池,异步 IO 和轻量级任务框架;还提供了设计用于多线程上下文中的 Collection 实现等。quartz 框架： Quartz是一个完全由java编写的开源作业调度框架。 高并发编程工具JUC","link":"/2019/08/06/java-多线程/"},{"title":"Mysql在项目中的基本操作","text":"Mysql数据库：关系型数据库 NOSQL数据库关系型数据库：Oracle Mysql(SUN Java) DB2(IBM) 表的管理 DML（INSERT UPDATE DELETE SELECT） MYSQL常用的数据类型 int(6) double(10,2) varchar:可变长字符类型 name varchar(10) Jack char:不可变长字符类型 idcode char(18) 210 date:日期类型 timestamp:时间戳类型 约束 主键约束：primary key,主键字段的值非空唯一 外键约束：foreign key references t1(id);外键字段值引用其他主键字段的值 创建数据库 1create database tedudb; 选择数据库 1use tedudb; 创建表 12345678910create table t_user( id int(6) auto_increment primary key, username varchar(20), password varchar(20), email varchar(50), phone varchar(20), type char(1), created timestamp, updated timestamp); 需求：根据如下需求创建表 创建部门表和员工表，员工表中有部门号字段为外键字段，引用部门表中部门号字段部门表字段：部门号，部门名，部门地址员工表字段：员工号，员工姓名，职位，薪水，入职日期，经理编号，部门号 部门表 12345create table dept1( deptno int(2) auto_increment primary key, dname varchar(30), loc varchar(50) ); 员工表1 1234567891011create table emp1( empno int(4) auto_increment primary key, ename varchar(20), job varchar(20), sal double(10,2), hiredate date, mgr int(4), deptno int(2), foreign key(mgr) references emp1(empno), foreign key(deptno) references dept1(deptno)); 查看数据库表：show tables; 查看表结构：desc t_user;12345create table dept2( deptno int(2) auto_increment primary key, dname varchar(30), loc varchar(50) ); 员工表2 123456789create table emp2( empno int(4) auto_increment primary key, ename varchar(20), job varchar(20), sal double(10,2), hiredate date, mgr int(4), deptno int(2)); 通过修改表的方式添加外键： 12alter table emp2 add foreign key(mgr) references emp2(empno); alter table emp2 add foreign key(deptno) references dept2(deptno); 创建表设置字符集 12345678910111213141516create table dept( deptno int(2) auto_increment primary key, dname varchar(30), loc varchar(50) ) default charset=utf8; create table emp( empno int(4) auto_increment primary key, ename varchar(20), job varchar(20), sal double(10,2), hiredate date, mgr int(4), deptno int(2))default charset=utf8; alter table emp add foreign key(mgr) references emp(empno); alter table emp add foreign key(deptno) references dept(deptno); DML： INSERT:添加数据 需求：创建管理员账号 insert into t_user values(NULL,’admin’,’admin’,‘admin@tedu.cn’,’15699782000’,’2’,now(),now()); 需求：创建普通用户账号 insert into t_user values(NULL,’user01’,’user01’,‘user01@tedu.cn’,’15699782111’,’1’,now(),now()); 需求： 1、创建4个部门分别为10,20,30,40,部门名为研发部，教学部，人事部，财务部 insert into dept values(10,’研发部’,’兰理工本部综合楼301’); insert into dept values(20,’教学部’,’兰理工本部综合楼302’); insert into dept values(30,’人事部’,’兰理工本部综合楼303’); insert into dept values(40,’财务部’,’兰理工本部综合楼304’); 2、向员工表中添加如下员工： * 一个总裁 insert into emp values(7000,’KING’,’总裁’,20000,’2010-1-1’,null,10); * 三个部门（研发部，教学部，人事部）经理 insert into emp values(7001,’汪梦婷’,’经理’,18000,’2013-2-12’,7000,10); insert into emp values(7002,’马良’,’经理’,22000,’2014-3-10’,7000,20); insert into emp values(7003,’周荣民’,’经理’,10000,’2012-5-29’,7000,30); * 每个部门中添加5个员工 研发部 insert into emp values(7004,’王云飞’,’CLERK’,15000,’2012-09-19’,7001,10); insert into emp values(7005,’张宇’,’CLERK’,12500,’2013-02-12’,7001,10); insert into emp values(7006,’白浩诛’,’CLERK’,11000,’2017-12-12’,7001,10); insert into emp values(7007,’王禹’,’CLERK’,9000,’2018-06-06’,7001,10); insert into emp values(7008,’曹倩’,’CLERK’,19000,’2010-05-12’,7001,10); 教学部 insert into emp values(7010,’楚玲玲’,’讲师’,22000,’2016-09-19’,7002,20); insert into emp values(7011,’腾萃萃’,’讲师’,18000,’2013-02-12’,7002,20); insert into emp values(7012,’朱海熊’,’讲师’,15000,’2017-02-12’,7002,20); insert into emp values(7013,’刘依琳’,’讲师’,21500,’2017-07-06’,7002,20); insert into emp values(7014,’薛媛’,’讲师’,28000,’2010-04-12’,7002,20); 人事部 insert into emp values(7015,’张泽亮’,’人事专员’,6000,’2017-09-19’,7003,30); insert into emp values(7016,’严志威’,’人事专员’,5500,’2016-08-12’,7003,30); insert into emp values(7017,’刘俊翔’,’人事专员’,7000,’2015-07-12’,7003,30); insert into emp values(7018,’张帅帅’,’人事专员’,9000,’2014-06-06’,7003,30); insert into emp values(7019,’王广志’,’人事专员’,6500,’2010-05-12’,7003,30); UPDATE 需求：将公司中30号部门员工涨薪1000 update emp set sal=sal+1000 where deptno=30; update emp set sal=sal+600,hiredate=’2016-05-12’ where empno=7019; DELETE insert into emp(empno,ename) values(8000,’aaaa’); delete from emp where empno=8000; SELECT: DML（INSERT,UPDATE,DELETE） DQL（SELECT） DML（INSERT,UPDATE,DELETE,SELECT 增删改查 CRUD） 作业：课上所有的需求 基本查询select 字段1,字段2… from 表名;需求：列出员工姓名，薪水，职位，入职日期select ename,sal,job,hiredate from emp;需求：列出员工表中所有数据select * from emp;开发中，尽可能不使用*select empno,ename,job,sal,hiredate,mgr,deptno from emp; 过滤查询 需求：列出10号部门员工的姓名，工资，入职日期select ename,sal,hiredate from emp where deptno=10;需求：列出薪水低于10000的员工姓名，薪水，职位，部门号select ename,sal,job,deptno from emp where sal&lt;10000;需求：列出10号部门16年之后入职的员工姓名，薪水，职位，入职日期select ename,sal,job,hiredate from emp where deptno=10 and hiredate&gt;’2016-1-1’;需求：列出10号部门或16年之后入职的员工姓名，薪水，职位，入职日期，部门号select ename,sal,job,hiredate,deptno from emp where deptno=10 or hiredate&gt;’2016-1-1’;需求：列出10，20号部门中的员工姓名，薪水，职位，部门号select ename,sal,job,deptno from emp where deptno in(10,20);需求：列出&apos;王&apos;姓的员工姓名，职位，入职日期 模糊查询：like % _select ename,job,hiredate from emp where ename like ‘王%’;需求：列出名字中第二个字是&apos;浩&apos;的员工姓名，薪水，职位，入职日期，部门号select ename,sal,job,hiredate,deptno from emp where ename like ‘_浩%’; 排序查询order by asc(升序) desc(降序)需求：列出员工的姓名，薪水，职位入职日期，根据薪水降序排序select ename,sal,hiredate from emp order by sal desc;需求：列出员工的姓名，薪水，职位,入职日期，根据薪水降序排序,入职日期升序排序select ename,sal,hiredate from emp order by sal desc,hiredate asc; 需求：列出10号部门员工的姓名，薪水，职位，入职日期，根据薪水降序排序 select ename,sal,job,hiredate from emp where deptno=10 order by sal desc; 分组查询group by 统计运算：max min sum avg count 需求：列出公司中每个部门员工薪水总和select deptno, sum(sal) from emp group by deptno;需求：列出公司中每个部门的最大工资，最小工资，平均工资，工资总和select deptno,max(sal),min(sal),avg(sal),sum(sal) from emp group by deptno;需求：列出公司中有多少个员工select ename,count(*) from emp;–语法错误 注意：分组查询，只能查询分组字段和分组之后的组函数运算结果 多表查询（联合查询，内连接，外连接查询）查询的数据分布在多张表里 需求：列出员工姓名，薪水，职位，入职日期，部门名，部门地址 等值查询（等价于内连接） select ename,sal,job,hiredate,dname,loc from emp e,dept dwhere e.deptno=d.deptno;内连接查询select ename,sal,job,hiredate,dname,loc from emp e inner join dept don e.deptno=d.deptno;等值查询或内连接查询，查询的结果都必须满足连接条件 注意：多表查询一定要指定连接条件，条件的数量n-1 否则会出现笛卡尔乘积现象 外连接查询 左外连接、右外连接、全外连接 左外连接 select ename,sal,job,hiredate,dname,loc from emp e left outer join dept don e.deptno=d.deptno;右外连接select ename,sal,job,hiredate,dname,loc from dept d right outer join emp eon e.deptno=d.deptno;右外连接select ename,sal,job,hiredate,dname,loc from emp e right outer join dept don e.deptno=d.deptno; 全外连接（oracle支持）select ename,sal,job,hiredate,dname,loc from emp e full outer join dept don e.deptno=d.deptno; mysql分页查询select * from emp limit 5,5;","link":"/2019/07/23/mysql在项目中的基本操作/"},{"title":"Java基础面试总结(二)","text":"1. 两个对象的hashCode相同，则equals也一定为true，对吗？不对，答案见下面的代码： 1234@Overridepublic int hashCode() { return 1;} 两个对象equals为true，则hashCode也一定相同，对吗？ 这块肯定是有争议的。面试的时候这样答：如果按照官方设计要求来打代码的话，hashcode一定相等。但是如果不按官方照设计要求、不重写hashcode方法，就会出现不相等的情况。 2. java线程池用过没有？ Executors提供了四种方法来创建线程池。 newFixedThreadPool() :创建固定大小的线程池。 newCachedThreadPool(): 创建无限大小的线程池，线程池中线程数量不固定，可根据需求自动更改。 newSingleThreadPool() : 创建单个线程池，线程池中只有一个线程。 newScheduledThreadPool() 创建固定大小的线程池，可以延迟或定时的执行任务。 手写一个： 12345678910public static void main(String[] args) { ExecutorService threadPool = Executors.newCachedThreadPool(); threadPool.execute(() -&gt; { for (int i = 0; i&lt; 20;i++) { System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); } }); threadPool.shutdown();} 线程池作用 限制线程个数，避免线程过多导致系统运行缓慢或崩溃。 不需要频繁的创建和销毁，节约资源、响应更快。 3. Math.round(-2.5)等于多少？ 不要认为它是四舍五入!不要认为它是四舍五入!不要认为它是四舍五入! 口诀：+0.5后向下取整。所以结果是-2。 留个题，Math.round(-2.6)结果和Math.round(2.6)结果 4. 面向对象六大原则 单一职责原则——SRP 让每个类只专心处理自己的方法。 开闭原则——OCP 软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。 里式替换原则——LSP 子类可以去扩展父类，但是不能改变父类原有的功能。 依赖倒置原则——DIP 应该通过调用接口或抽象类(比较高层)，而不是调用实现类(细节)。 接口隔离原则——ISP 把接口分成满足依赖关系的最小接口，实现类中不能有不需要的方法。 迪米特原则——LOD 高内聚,低耦合。 5. static和final区别 关键词 修饰物 影响 final 变量 分配到常量池中，程序不可改变其值 final 方法 子类中将不能被重写 final 类 不能被继承 static 变量 分配在内存堆上，引用都会指向这一个地址而不会重新分配内存 static 方法块 虚拟机优先加载 static 类 可以直接通过类来调用而不需要new 6. String s = “hello”和String s = new String(“hello”);区别String s = new String(&quot;hello&quot;);可能创建两个对象也可能创建一个对象。如果常量池中有hello字符串常量的话，则仅仅在堆中创建一个对象。如果常量池中没有hello对象，则堆上和常量池都需要创建。 String s = &quot;hello&quot;这样创建的对象，JVM会直接检查字符串常量池是否已有”hello”字符串对象，如没有，就分配一个内存存放”hello”，如有了，则直接将字符串常量池中的地址返回给栈。(没有new，没有堆的操作) 7. 引用类型是占用几个字节？hotspot在64位平台上，占8个字节，在32位平台上占4个字节。 8. (1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4和(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)区别12System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4);System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)); 控制台: 12a34a7 8.1 什么情况下,加号会变成字符串连接符依据上面的例子来思考。 9. java中的switch选择结构可以使用数据类型的数据(JDK1.8) char byte short int Character Byte Short Integer String enum 更好的记忆方法: 基本类型中，没有boolean和浮点类型+长类型long.相应的包装类型也没有。 外加String和enum。 10. 4&amp;5``4^5``4&amp;10&gt;&gt;1各等于多少1234567// 0100 &amp; 0101 = 0100 = 4System.out.println(4&amp;5);// 0100 ^ 0101 = 0001 = 1System.out.println(4^5);System.out.println(10&gt;&gt;1); // 有疑问参考下面的运算符优先级System.out.println(4&amp;10&gt;&gt;1); 12344154 4|5等于多少呢答案：5 运算符优先级 运算符 结合性 [ ] . ( ) (方法调用) 从左向右 ! ~ ++ -- +(一元运算) -(一元运算) 从右向左 * / % 从左向右 + - 从左向右 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 从左向右 &lt; &lt;= &gt; &gt;= instanceof 从左向右 == != 从左向右 &amp; 从左向右 ^ 从左向右 ` ` &amp;&amp; 从左向右 ` ?: 从右向左 = 从右向左 11. 某些java类为什么要实现Serializable接口为了网络进行传输或者持久化 什么是序列化将对象的状态信息转换为可以存储或传输的形式的过程 除了实现Serializable接口还有什么序列化方式 Json序列化 FastJson序列化 ProtoBuff序列化… 12. JVM垃圾处理方法标记-清除算法（老年代）该算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象(可达性分析), 在标记完成后统一清理掉所有被标记的对象. 该算法会有两个问题： 效率问题，标记和清除效率不高。 空间问题: 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集。 所以它一般用于”垃圾不太多的区域，比如老年代”。 复制算法（新生代）该算法的核心是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象（非垃圾）复制到另外一块上面, 然后把已使用过的内存空间一次清理掉. 优点：不用考虑碎片问题，方法简单高效。缺点：内存浪费严重。 现代商用VM的新生代均采用复制算法, 但由于新生代中的98%的对象都是生存周期极短的, 因此并不需完全按照1∶1的比例划分新生代空间, 而是将新生代划分为一块较大的Eden区和两块较小的Survivor区(HotSpot默认Eden和Survivor的大小比例为8∶1), 每次只用Eden和其中一块Survivor. 当发生MinorGC时, 将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor上, 最后清理掉Eden和刚才用过的Survivor的空间. 当Survivor空间不够用(不足以保存尚存活的对象)时, 需要依赖老年代进行空间分配担保机制, 这部分内存直接进入老年代。 复制算法的空间分配担保：在执行Minor GC前, VM会首先检查老年代是否有足够的空间存放新生代尚存活对象, 由于新生代使用复制收集算法, 为了提升内存利用率, 只使用了其中一个Survivor作为轮换备份, 因此当出现大量对象在Minor GC后仍然存活的情况时, 就需要老年代进行分配担保, 让Survivor无法容纳的对象直接进入老年代, 但前提是老年代需要有足够的空间容纳这些存活对象. 但存活对象的大小在实际完成GC前是无法明确知道的, 因此Minor GC前, VM会先首先检查老年代连续空间是否大于新生代对象总大小或历次晋升的平均大小, 如果条件成立, 则进行Minor GC, 否则进行Full GC(让老年代腾出更多空间).然而取历次晋升的对象的平均大小也是有一定风险的, 如果某次Minor GC存活后的对象突增,远远高于平均值的话,依然可能导致担保失败(Handle Promotion Failure, 老年代也无法存放这些对象了), 此时就只好在失败后重新发起一次Full GC(让老年代腾出更多空间). 标记-整理算法（老年代）标记清除算法会产生内存碎片问题, 而复制算法需要有额外的内存担保空间, 于是针对老年代的特点, 又有了标记整理算法. 标记整理算法的标记过程与标记清除算法相同, 但后续步骤不再对可回收对象直接清理, 而是让所有存活的对象都向一端移动,然后清理掉端边界以外的内存. 13. 新生代、老年代、持久代都存储哪些东西新生代： 方法中new一个对象，就会先进入新生代。 老年代： 新生代中经历了N次垃圾回收仍然存活的对象就会被放到老年代中。 大对象一般直接放入老年代。 当Survivor空间不足。需要老年代担保一些空间，也会将对象放入老年代。 永久代：指的就是方法区。 14. 可达性算法中，哪些对象可作为GC Roots对象。 虚拟机栈中引用的对象 方法区静态成员引用的对象 方法区常量引用对象 本地方法栈JNI引用的对象 15. 什么时候进行MinGC和FullGCMinGC: 当Eden区满时,触发Minor GC. FullGC: 调用System.gc时，系统建议执行Full GC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小大于老年代的剩余空间 堆中分配很大的对象，而老年代没有足够的空间 16. 如何判定对象为垃圾对象在堆里面存放着Java世界中几乎所有的对象实例, 垃圾收集器在对堆进行回收前, 第一件事就是判断哪些对象已死(可回收). 引用计数法在JDK1.2之前，使用的是引用计数器算法。在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就+1，当引用失效的时候，计数器的值就-1，当引用计数器被减为零的时候，标志着这个对象已经没有引用了，可以回收了！ 问题：如果在A类中调用B类的方法，B类中调用A类的方法，这样当其他所有的引用都消失了之后，A和B还有一个相互的引用，也就是说两个对象的引用计数器各为1，而实际上这两个对象都已经没有额外的引用，已经是垃圾了。但是该算法并不会计算出该类型的垃圾。 可达性分析法在主流商用语言(如Java、C#)的主流实现中, 都是通过可达性分析算法来判定对象是否存活的: 通过一系列的称为 GC Roots 的对象作为起点, 然后向下搜索; 搜索所走过的路径称为引用链/Reference Chain, 当一个对象到 GC Roots 没有任何引用链相连时, 即该对象不可达, 也就说明此对象是不可用的, 如下图:虽然E和F相互关联， 但它们到GC Roots是不可达的, 因此也会被判定为可回收的对象。 注: 即使在可达性分析算法中不可达的对象, VM也并不是马上对其回收, 因为要真正宣告一个对象死亡, 至少要经历两次标记过程: 第一次是在可达性分析后发现没有与GC Roots相连接的引用链, 第二次是GC对在F-Queue执行队列中的对象进行的小规模标记(对象需要覆盖finalize()方法且没被调用过). 17. 你能说出来几个垃圾收集器SerialSerial收集器是Hotspot运行在Client模式下的默认新生代收集器, 它在进行垃圾收集时，会暂停所有的工作进程，用一个线程去完成GC工作 特点：简单高效，适合jvm管理内存不大的情况（十兆到百兆）。 ParnewParNew收集器其实是Serial的多线程版本，回收策略完全一样，但是他们又有着不同。 我们说了Parnew是多线程gc收集，所以它配合多核心的cpu效果更好，如果是一个cpu，他俩效果就差不多。（可用-XX:ParallelGCThreads参数控制GC线程数） CmsCMS(Concurrent Mark Sweep)收集器是一款具有划时代意义的收集器, 一款真正意义上的并发收集器, 虽然现在已经有了理论意义上表现更好的G1收集器, 但现在主流互联网企业线上选用的仍是CMS(如Taobao),又称多并发低暂停的收集器。 由他的英文组成可以看出，它是基于标记-清除算法实现的。整个过程分4个步骤： 初始标记(CMS initial mark):仅只标记一下GC Roots能直接关联到的对象, 速度很快 并发标记(CMS concurrent mark: GC Roots Tracing过程) 重新标记(CMS remark):修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录 并发清除(CMS concurrent sweep: 已死对象将会就地释放) 可以看到，初始标记、重新标记需要STW(stop the world 即：挂起用户线程)操作。因为最耗时的操作是并发标记和并发清除。所以总体上我们认为CMS的GC与用户线程是并发运行的。 优点:并发收集、低停顿 缺点： CMS默认启动的回收线程数=(CPU数目+3)*4当CPU数&gt;4时, GC线程最多占用不超过25%的CPU资源, 但是当CPU数&lt;=4时, GC线程可能就会过多的占用用户CPU资源, 从而导致应用程序变慢, 总吞吐量降低. 无法清除浮动垃圾（GC运行到并发清除阶段时用户线程产生的垃圾），因为用户线程是需要内存的，如果浮动垃圾施放不及时，很可能就造成内存溢出，所以CMS不能像别的垃圾收集器那样等老年代几乎满了才触发，CMS提供了参数-XX:CMSInitiatingOccupancyFraction来设置GC触发百分比(1.6后默认92%),当然我们还得设置启用该策略-XX:+UseCMSInitiatingOccupancyOnly 因为CMS采用标记-清除算法，所以可能会带来很多的碎片，如果碎片太多没有清理，jvm会因为无法分配大对象内存而触发GC，因此CMS提供了-XX:+UseCMSCompactAtFullCollection参数，它会在GC执行完后接着进行碎片整理，但是又会有个问题，碎片整理不能并发，所以必须单线程去处理，所以如果每次GC完都整理用户线程stop的时间累积会很长，所以XX:CMSFullGCsBeforeCompaction参数设置隔几次GC进行一次碎片整理（默认为0）。 G1同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是引入分区的思路，弱化分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。 因为每个区都有E、S、O代，所以在G1中，不需要对整个Eden等代进行回收，而是寻找可回收对象比较多的区，然后进行回收（虽然也需要STW操作，但是花费的时间是很少的），保证高效率。 新生代收集G1的新生代收集跟ParNew类似，如果存活时间超过某个阈值，就会被转移到S/O区。 年轻代内存由一组不连续的heap区组成, 这种方法使得可以动态调整各代区域的大小 老年代收集分为以下几个阶段： 初始标记 (Initial Mark: Stop the World Event)在G1中, 该操作附着一次年轻代GC, 以标记Survivor中有可能引用到老年代对象的Regions. 扫描根区域 (Root Region Scanning: 与应用程序并发执行)扫描Survivor中能够引用到老年代的references. 但必须在Minor GC触发前执行完 并发标记 (Concurrent Marking : 与应用程序并发执行)在整个堆中查找存活对象, 但该阶段可能会被Minor GC中断 重新标记 (Remark : Stop the World Event)完成堆内存中存活对象的标记. 使用snapshot-at-the-beginning(SATB, 起始快照)算法, 比CMS所用算法要快得多(空Region直接被移除并回收, 并计算所有区域的活跃度). 清理 (Cleanup : Stop the World Event and Concurrent)在含有存活对象和完全空闲的区域上进行统计(STW)、擦除Remembered Sets(使用Remembered Set来避免扫描全堆，每个区都有对应一个Set用来记录引用信息、读写操作记录)(STW)、重置空regions并将他们返还给空闲列表(free list)(Concurrent) 详情请看参考文档 18. JVM中对象的创建过程1. 拿到内存创建指令当虚拟机遇到内存创建的指令的时候（new 类名），来到了方法区，找 根据new的参数在常量池中定位一个类的符号引用。 2. 检查符号引用检查该符号引用有没有被加载、解析和初始化过，如果没有则执行类加载过程，否则直接准备为新的对象分配内存 3. 分配内存虚拟机为对象分配内存（堆）分配内存分为指针碰撞和空闲列表两种方式；分配内存还要要保证并发安全，有两种方式。 3.1. 指针碰撞所有的存储空间分为两部分，一部分是空闲，一部分是占用，需要分配空间的时候，只需要计算指针移动的长度即可。 3.2. 空闲列表虚拟机维护了一个空闲列表，需要分配空间的时候去查该空闲列表进行分配并对空闲列表做更新。 可以看出，内存分配方式是由java堆是否规整决定的，java堆的规整是由垃圾回收机制来决定的 3.2.5 安全性问题的思考假如分配内存策略是指针碰撞，如果在高并发情况下，多个对象需要分配内存，如果不做处理，肯定会出现线程安全问题，导致一些对象分配不到空间等。 下面是解决方案： 3.3 线程同步策略也就是每个线程都进行同步，防止出现线程安全。 3.4. 本地线程分配缓冲也称TLAB（Thread Local Allocation Buffer），在堆中为每一个线程分配一小块独立的内存，这样以来就不存并发问题了，Java 层面与之对应的是 ThreadLocal 类的实现 4. 初始化 分配完内存后要对对象的头（Object Header）进行初始化，这新信息包括：该对象对应类的元数据、该对象的GC代、对象的哈希码。 抽象数据类型默认初始化为null，基本数据类型为0，布尔为false。。。5. 调用对象的初始化方法也就是执行构造方法。","link":"/2019/07/27/Java基础面试总结-二/"}],"tags":[{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"命令","slug":"命令","link":"/tags/命令/"},{"name":"Sublime","slug":"Sublime","link":"/tags/Sublime/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"框架","slug":"框架","link":"/tags/框架/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"Cookie","slug":"Cookie","link":"/tags/Cookie/"},{"name":"Session","slug":"Session","link":"/tags/Session/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"源码","slug":"源码","link":"/tags/源码/"}],"categories":[{"name":"SSM","slug":"SSM","link":"/categories/SSM/"},{"name":"Java 基础篇","slug":"Java-基础篇","link":"/categories/Java-基础篇/"},{"name":"常用工具","slug":"常用工具","link":"/categories/常用工具/"},{"name":"剑指offer","slug":"剑指offer","link":"/categories/剑指offer/"},{"name":"web 前端","slug":"web-前端","link":"/categories/web-前端/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"教程","slug":"教程","link":"/categories/教程/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"数据库","slug":"数据库","link":"/categories/数据库/"},{"name":"源码分析","slug":"源码分析","link":"/categories/源码分析/"}]}