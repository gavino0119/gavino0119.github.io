{"pages":[{"title":"归档","text":"","link":"/archives/index.html"},{"title":"About Me","text":"我就是我，不一样的烟火 教育经历 本科就读于兰州理工大学软件工程专业 专业兴趣技能 -Java -大数据 联系我 QQ: 582023774","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"实现状态管理的技术--Cookie和Session","text":"状态管理（数据管理）为什么需要状态管理什么是状态管理 状态指的是数据 管理指的是多次交互时对数据的修改 浏览器与服务器请求一次连接一次，每次连接服务器默认都不会保存任何数据通过技术手段，保存某次连接的数据，称为状态管理在多次请求中，使用某次请求的数据，必须使用状态管理技术实现状态管理的技术Cookie和Session 浏览器1（卡（华为手机，充电宝）—&gt; 服务器浏览器2（卡（华为手机，充电宝）—&gt;服务器浏览器3（卡（华为手机，充电宝）—&gt;服务器 浏览器1（id号）—&gt;服务器 （卡1（华为手机，充电宝，id号）浏览器2（id号）—&gt;服务器 （卡2（华为手机，充电宝，id号）浏览器3（id号）—&gt;服务器 （卡3（华为手机，充电宝，id号） CookieCookie:保存在浏览器端的文本文件，实现状态管理的方式之一工作原理：当服务器创建cookie并发送到浏览器，浏览器再次访问服务器会自动将cookie发送的服务器 Cookie的特点： cookie保存在浏览器端的文本文件 cookie存储数据大小有限制，不能超过4K cookie只能存储字符串,不能直接保存中文 cookie的数据不安全 cookie有路径的限制，只能读取同一个应用中的cookie 同一个应用中，相同路径和子路径可以读取cookie 发送cookie之前，都会cookie.serPath(“/“);为了方便读取 浏览器可以禁止cookieCookie的API： 创建cookieCookie c = new Cookie(“name”,”value”); 设置存活时间void setMaxAge(int seconds);-1:保存到浏览器的缓存中=0:cookie的失效，设置为0，被删除状态 0:保存到浏览器所在的磁盘中 设置路径void setPath(String path);cookie.setPat(“/“); 获取名字String getName(); 获取cookie的值String getValue(); 发送cookieresponse.addCookie(cookie); 获取cookieCookie[] cookies = request.getCookies(); 自动记忆账号和密码 Session1、状态（数据）管理-session 会话管理 获取session对象 request.getSession();如果没有查找到session对象，会创建 request.getSession(true);如果没有查找到session对象，会创建 request.getSession(false);如果没有查找到session对象，返回null void setAttribute(String name,Object value);设置属性 Object getAttribute(String name);获取属性 2、基于session实现的功能 保存登录账号信息，所有包含登录功能的系统都必须实现 每个页面显示登录账号 使用session实现系统登录权限验证 3、session的销毁 超时时间 tomcat默认30分钟没有对session的访问 手动销毁 退出 void invalidate(); 4、Session的特点： Session是服务器维护的一个内存对象 Session可以保存任何数据类型 Session保存数据没有大小限制 Session没有路径的限制 Session数据没有安全隐患 默认，如果浏览器禁止cookie，Session也无法使用 5、URL重写 使用Session,防止浏览器禁止cookie 通过编码的方式，传递session的id response.encodeURL(“adminMain.jsp”); http://localhost:8080/day08_ums/adminMain.jsp;jsessionid=048F1A66235BD825944A8B804F131660","link":"/2019/07/24/Cookie和Session/"},{"title":"Ajax的原理及实现","text":"一、什么是Ajax二、Ajax工作原理三、Ajax的实现","link":"/2019/07/24/ajax的原理及实现/"},{"title":"IO 基础总结","text":"File类#File 并不是指文件本身两个常量： 路径分隔符File.pathSeparator 名称分隔符File.separator //路径表示的几种形式 //1、windows下 String path = &quot;C:\\\\Users\\\\dell\\\\Desktop&quot;; //2、 path = &quot;C:&quot;+File.separator+&quot;Users&quot;+File.separator+&quot;dell&quot;+File.separator+&quot;Desktop&quot;; //3、推荐方式 path = &quot;C:/Users/dell/Desktop&quot;; IO流基础 一、概念流动、流向 以程序为中心二、IO流分类1、流向: 输入流与输出流 2、数据 字节流:二进制 可以一切文件 包括纯文本 、doc 、音频 、视频等等 字符流:文本文件 只能处理纯文本 3、功能 节点:包裹源头 处理:增强功能，提供性能(提高效率)三、字符流与字节流(重点)1、字节流 输入流:InputStream 输出流:OutputStream 2、字符流 (读入 写出) 输入流:Reader 输出流:Writer四、操作1、与文件建立联系 2、选择流 3、操作 4、释放资源 ###FileWriter写数据### 输出流写数据的步骤： A、创建输出流对象 B、调用输出流对象的写数据方法 并刷新缓冲区 (硬盘存储数据的基本单位是字节) C、释放资源 (close()方法先刷新 再通知系统释放资源) 换行:\\n \\r \\r\\n * windows识别的换行为 \\r\\n * Linux识别的换行为 \\n * mac识别的换行为 \\r ###FileReader读数据### 同 FileWriter写数据 代码实例: * int len; * char[] chs = new char[1024]; * while ((len=fr.read(chs))!=-1) { * System.out.print((new String(chs,0,len))); * } * fr.close(); *注意 char[] chs = new char[1024]; //写1024及其整数倍 *往控制台输出时，不要ln System.out.print(); ###文件复制### 数据源: 目的地: *判断读 //先读 然后写进去 //后写 ###字符缓冲流### (高效地读入和写出) BufferedWriter bf = new BufferedWriter(new FileWriter(&quot;bf.txt&quot;)); BufferedReader br = new BufferedReader(new FileReader(&quot;bf.txt&quot;)); //注意构造方法里面 System.out.print(new String(csh,0,len)); // 缓冲流的特殊功能: newLine() //写一个换行符 这个换行符由系统决定 readLine() //读一行 【不包括换行符】 IO流高级 File:文件和目录路径名的抽象表示形式，File类的实例是不可变的(即File可以创建实例) ##创建功能 createNewFile() mkdir() mkdirs() ##删除功能 ##判断功能","link":"/2019/07/15/IO-基础总结/"},{"title":"About Markdown","text":"一、MarkdownMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持 二、语法2.1 分割线分割线最常使用就是三个或以上*，还可以使用-和_。2.2字体后面俩字加黑 后面俩字斜体 2.3标题效果： 一级标题二级标题三级标题四级标题五级标题六级标题 2.4列表有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项 2 . 第二项 3 . 第三项 2.4.1列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第一个元素 2.5区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号 注意：只需在段落开头写一个 &gt; 即可，不必每行都带 &gt; ,一个区块的内容中间不能写空行。 2.6段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 2.7代码段1234567 for(int j=0;j&lt;=ny;++j) { if(i) DP[i][j]+=DP[i-1][j]; if(j) DP[i][j]+=DP[i][j-1]; DP[i][j]*=!mark[i][j];} 2.8表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 效果如下： 表头 表头 单元格 单元格 单元格 单元格 三、高级技巧3.1转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： 文本加粗** 正常显示星号 **","link":"/2019/07/03/about markdown/"},{"title":"Linux常用命令","text":"命令基本格式 一、常用基本命令1、 cpcp:copy 复制文件cp 源文件 目的地(目录)-p 保留文件原属性-r 复制目录 2、 | 管道output | input对某些命令执行的结果去作操作,会用到管道；用于命令与命令之间的连接，前一个命令的输出是后一个命令的输入 3、 rm rm [filename] remove 删除文件,对 root 用户有提示,普通用户没有提示 -f force 强制删除, root 无提示 -i 普通用户有提示的删除 -r 递归删除,慎重使用 -rf 4、文件的过滤 grep 123456789101112131415grep [OPTIONS] PATTERN [FILE...]过滤带有 [ 字符串 ] 的行grep [ 字符串 ] [ 文件 ] 过滤以 [ 字符串 ] 为开始的行grep [^ 字符串 ] [ 文件 ]过滤以 [ 字符串 ] 为结尾的行grep [ 字符串 $] [ 文件 ]过滤反选grep -v [ 字符串 ] [ 文件 ]eg.过滤以 root 为开始的行 grep ^root /etc/passwd过滤以 bash 为结尾的行grep bash$ /etc/passwd 二、文件操作三、查看日志四、查看进程和端口五、查看系统的状态TOP","link":"/2019/07/22/Linux常用命令/"},{"title":"博客记录","text":"博客搭建博客主题 填过的坑1、关于解决 npm 安装过慢的问题在cmd 命令行将默认源改为淘宝镜像源 2、 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/03/my blog/"},{"title":"单例模式","text":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 优点1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 实现方式一：懒汉式（线程不安全）懒汉式：就是用的时候再进行实例化对象。 1234567891011public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 这种实现方式不支持多线程，因为没有同步锁，多线程下不能正常工作。 实现方式二：懒汉式（线程安全）12345678910public class Singleton { private static Singleton instance; public static synchronized Singleton getInstance(){ if (instance == null){ instance = new Singleton(); } return instance; }} 可以在多线程环境下使用，但是效率太低。 优点：一个对象初始化一次，节省内存。缺点：必须用synchronized来维持单例，没效率。 实现方式三：饿汉式（线程安全）1234567public class Singleton { private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; }} 因为它作为静态资源，所以在类装载时就被实例化 优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。 实现方式四：双检锁/双重校验锁DCL（线程安全）1234567891011121314public class Singleton { private static Singleton instance; public static Singleton getInstance(){ if (instance == null){ synchronized (Singleton.class){ if (instance == null){ instance = new Singleton(); } } } return instance; }} 采用双锁机制，安全且在多线程情况下能保持高性能。详细了解请点击：Java并发编程 – 单例模式线程安全问题 实现方式五：登记式/静态内部类（线程安全）1234567891011public class Singleton { private static Singleton instance; private static class SingletonHandler{ private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance(){ return SingletonHandler.INSTANCE; }} 这种方式可以说是恶汉式的变通版，SingletonHandler没有被主动使用的情况下是不会实例化Singleton对象的，所以这样做，既能达到lazy式的加载，又能保证线程安全。 实现方式六：枚举类（线程安全）123456public enum Singleton { INSTANCE; public void myMethod() { System.out.println(&quot;enum instance test&quot;); }} 它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。 测试： 123456public class Main { public static void main(String[] args) { Singleton singleton = Singleton.INSTANCE; singleton.myMethod(); }} 1enum instance test 总结不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。","link":"/2019/07/20/单例模式/"},{"title":"JDBC连接数据库基本操作","text":"什么是JDBCJAVA提供访问数据库的技术 JDBC如何实现可以操作所有数据库？JDBC提供了统一数据库的操作方式。JDBC是JAVA语言访问数据库的标准技术。提供了一组操作所有数据库的接口 接口 12345interface MyInterface{ public void save(); public void delete(); public void update();} 面向对象中多态MyInterface obj = new OracleClass();obj.save(); 驱动程序例如将数据添加到mysql数据库中,必须由mysql提供class MySqlClass implements MyInterface{ public void save(){ //将数据保存到mysql数据中 }}例如将数据添加到oracle数据库中，必须由oracle提供class OracleClass implements MyInterface{ public void save(){ //将数据保存到oracle数据中 }} * 1、JDBC的编码步骤 1、 加载驱动程序 2、 创建连接 3、 发送SQL INSERT UPDATE DELETE 4、 如果发送的是SELECT语句，处理结果集 5、 释放资源（关闭连接） 项目中业务功能SQL JDBC 技术标准 一组接口 数据库厂商提供驱动程序 JDBC工具类 CRUD 增删改查 模拟注册和登录，使用Statement,需要SQL与JAVA变量拼接，可能会出现SQL注入 Statement stmt = conn.createStatement(); 2、预处理语句对象 PreparedStatement,预处理语句对象，发送并执行SQL语句，是Statement子接口 优点： * 避免出现SQL注入现象 * 提升同一条SQL语句多次执行的效率 * 提升项目中SQL语句的可读性 用法： * SQL 使用?作为变量的占位符 String sql = “SELECT * FROM ajia_user WHERE username=’”+userName+”‘ AND password=’”+password+”‘“; String sql = “SELECT * FROM ajia_user WHERE username=? AND password=?”; String sql = “INSERT INTO ajia_user(id,username,password,email,phone,created,updated) “ + “VALUES(NULL,?,?,?,?,NOW(),NOW())”; String sql = “SELECT * FROM ajia_user WHERE id=?”; String sql = “SELECT * FROM ajia_user”; * 实例化： PreparedStatement pstmt = conn.prepareStatement(String sql); * 装载占位符(?)值 String userName = sc.nextLine(); String password = sc.nextLine(); String sql = &quot;SELECT * FROM ajia_user WHERE username=? AND password=?&quot;; pstmt.setString(1,userName); pstmt.setString(2,password); pstmt.setDouble(3,sal); pstmt.setTimeStamp(4,t); pstmt.setDate(5,d); pstmt.setObject(6,); * 执行SQL int executeUpdate();执行已经被装载值得SQL语句 ResultSet executeQuery();3、JDBC核心API DriverManager,驱动程序管理器Connection getConnection(String url,String user,String password);获取连接的方法url：jdbc:mysql://ip:3306/tedudbjdbc:mysql,主协议，指定调用哪个驱动程序//ip:3306/tedudb，自协议，指定数据库服务器的ip,数据库服务器软件的端口号，数据库名 Connection,连接对象Statement createStatement();PreparedStatement prepareStatement(String sql); Statement,语句对象int executeUpdate(String sql),执行insert,update,delete语句ResultSet executeQuery(String sql);执行select语句 PreparedStatement,语句处理语句对象void setXxx(int index,Xxx value);装载占位符值int executeUpdate(),执行insert,update,delete语句ResultSet executeQuery();执行select语句 关闭连接conn.close(); 4、JDBC事务处理事务：一组操作的逻辑单元 原子性，一致性，隔离性，持久性（ACID） 删除多条记录，修改多条记录，添加多条记录 Connection接口中： void setAutoCommit(boolean isAuto);设置自动提交方式，JDBC中默认自动提交 boolean getAutoCommit();获取JDBC自动提交方式 void commit();提交事务 void rollback();回滚事务 需求：使用JDBC事务，处理转账 t_account:id,username,balance create table t_account( id int(4) auto_increment primary key, username varchar(20), balance double(12,2) ); insert into t_account values(null,’1001’,100000); insert into t_account values(null,’1002’,100000); 5、批处理 create table t_log( id int(8) auto_increment primary key, title varchar(20), content varchar(50) ); 6、实体类 ajia_user 一组private属性 一组属性的setter和getter 重写父类equals(),hashCode(),toString()方法 一组构造器 实现SeriaLizable接口 7、DAO的设计 设计接口 实现类 接口的作用： * 解耦 多层体系结构应用中 视图层 控制层 业务层 持久层 * 扩展功能 1234567891011121314151617interface Hahaha{ public void f();} class Aaaaa implements Hahaha{ public void f(){ }//JDBC,MyBatis } class B{ public void f1(){ //..... Hahaha a = 反射获取Aaaaa对象; a.f(); } }JdbcUtil类： 123456789101112131415161718192021222324252627282930313233343536373839404142public class JdbcUtil { protected static Connection conn = null; private static String className=&quot;com.mysql.jdbc.Driver&quot;; private static String url=&quot;jdbc:mysql://localhost:3306/students_db?useUnicode=true&amp;characterEncoding=utf-8&quot;; private static String uname=&quot;root&quot;; private static String upasswd=&quot;root&quot;; /** * 获取数据库连接对象 * @return */ public static Connection getConn() { try { Class.forName(className); conn = DriverManager.getConnection(url, uname, upasswd); } catch (ClassNotFoundException e) { System.out.println(&quot;找不到驱动程序类 ，加载驱动失败！&quot;); e.printStackTrace() ; } catch (SQLException e) { System.out.println(&quot;数据库连接失败！&quot;); e.printStackTrace() ; } return conn; } /** * 关闭数据库连接 */ public static void closeConn(Connection conn) { try { if (conn!=null) conn.close(); conn = null; // 置null } catch (SQLException e) { System.out.println(&quot;连接关闭失败！&quot;); e.printStackTrace(); } } //测试// public static void main(String[] args) {// Connection conn = getConn();// System.out.println(conn);// }} 2、BaseDao设计 * 增删改方法的设计 * 查询方法的设计 ResultSet:基于连接的结果集 CacheRowSet:基于缓存的结果集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class BaseDao { Connection conn = null; /** 项目中增删改 * Object...param可变长参数 * 修改方法 */ public void update(String sql,Object...params) throws SQLException{ Connection conn = null; try { conn = JdbcUtil.getConn(); PreparedStatement pstmt = conn.prepareStatement(sql); if(params!=null){ for(int i=0;i&lt;params.length;i++ ){ pstmt.setObject(i+1, params[i]); } } pstmt.executeUpdate(); } finally{ JdbcUtil.closeConn(conn); } } /** * 查询方法 */ public ResultSet find(String sql,Object ...params)throws SQLException{ CachedRowSet crs = null; try { conn = JdbcUtil.getConn(); PreparedStatement pstmt = conn.prepareStatement(sql); if(params!=null){ for(int i=0;i&lt;params.length;i++ ){ pstmt.setObject(i+1, params[i]); } } ResultSet rs = pstmt.executeQuery(); //将基于连接的结果集转存到基于缓存的结果集 crs = new CachedRowSetImpl(); crs.populate(rs); } finally{ JdbcUtil.closeConn(conn); } return crs; } /** * 开启事务 */ public void beginTrans() { try { conn = JdbcUtil.getConn(); conn.setAutoCommit(false); // 关闭自动提交 } catch (SQLException e) { e.printStackTrace(); } } /** * 事务的提交 */ public void commit() { if (conn != null) { try { conn.commit(); } catch (SQLException e) { e.printStackTrace(); } } } /** * 事务的回滚 */ public void rollback() { if (conn != null) { try { conn.rollback(); } catch (SQLException e) { e.printStackTrace(); } } }}","link":"/2019/07/24/JDBC连接数据库基本操作/"},{"title":"ArrayList源码分析","text":"简介 ArrayList是我们开发中非常常用的数据存储容器之一，其底层是数组实现的，我们可以在集合中存储任意类型的数据，ArrayList是线程不安全的，非常适合用于对元素进行查找，效率非常高。 线程安全性对ArrayList的操作一般分为两个步骤，改变位置(size)和操作元素(e)。所以这个过程在多线程的环境下是不能保证具有原子性的，因此ArrayList在多线程的环境下是线程不安全的。 源码分析1. 属性分析1234567891011121314151617181920212223242526272829303132/** * 默认初始化容量 */private static final int DEFAULT_CAPACITY = 10;/** * 如果自定义容量为0，则会默认用它来初始化ArrayList。或者用于空数组替换。 */private static final Object[] EMPTY_ELEMENTDATA = {};/** * 如果没有自定义容量，则会使用它来初始化ArrayList。或者用于空数组比对。 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};/** * 这就是ArrayList底层用到的数组 * 非私有，以简化嵌套类访问 * transient 在已经实现序列化的类中，不允许某变量序列化 */transient Object[] elementData;/** * 实际ArrayList集合大小 */private int size;/** * 可分配的最大容量 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 扩展：什么是序列化序列化是指：将对象转换成以字节序列的形式来表示，以便用于持久化和传输。 实现方法：实现Serializable接口。 然后用的时候拿出来进行反序列化即可又变成Java对象。 transient关键字解析 Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化。 有了transient关键字声明，则这个变量不会参与序列化操作，即使所在类实现了Serializable接口，反序列化后该变量为空值。 那么问题来了：ArrayList中数组声明：transient Object[] elementData;，事实上我们使用ArrayList在网络传输用的很正常，并没有出现空值。 原来：ArrayList在序列化的时候会调用writeObject()方法，将size和element写入ObjectOutputStream；反序列化时调用readObject()，从ObjectInputStream获取size和element，再恢复到elementData。 那为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？ 原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。 2. 构造方法分析根据initialCapacity 初始化一个空数组，如果值为0，则初始化一个空数组: 12345678910111213/** * 根据initialCapacity 初始化一个空数组 */public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); }} 不带参数初始化，默认容量为10: 123456/** * 不带参数初始化，默认容量为10 */public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;} 通过集合做参数的形式初始化：如果集合为空，则初始化为空数组： 1234567891011121314/** * 通过集合做参数的形式初始化 */public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; }} 3. 主干方法trimToSize()方法： 用来最小化实例存储，将容器大小调整为当前元素所占用的容量大小。 1234567891011/** * 这个方法用来最小化实例存储。 */public void trimToSize() { modCount++; if (size &lt; elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); }} clone()方法 用来克隆出一个新数组。 1234567891011public Object clone() { try { ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(e); }} 通过调用Object的clone()方法来得到一个新的ArrayList对象，然后将elementData复制给该对象并返回。 add(E e)方法 在数组末尾添加元素 12345678/** * 在数组末尾添加元素 */public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;} 看到它首先调用了ensureCapacityInternal()方法.注意参数是size+1,这是个面试考点。 123private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));} 这个方法里又嵌套调用了两个方法:计算容量+确保容量 计算容量：如果elementData是空，则返回默认容量10和size+1的最大值，否则返回size+1 123456private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity;} 计算完容量后，进行确保容量可用：(modCount不用理它，它用来计算修改次数) 如果size+1 &gt; elementData.length证明数组已经放满，则增加容量，调用grow()。 1234567private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);} 增加容量：默认1.5倍扩容。 获取当前数组长度=&gt;oldCapacity oldCapacity&gt;&gt;1 表示将oldCapacity右移一位(位运算)，相当于除2。再加上1，相当于新容量扩容1.5倍。 如果newCapacity&lt;minCapacity，则newCapacity = minCapacity。看例子更明白一点：假设size为1,则minCapacity=size+1=2,而elementData.length=1,newCapacity=1+1&gt;&gt;1=1,1&lt;2所以如果不处理该情况，扩容将不能正确完成。 如果新容量比最大值还要大，则将新容量赋值为VM要求最大值。 将elementData拷贝到一个新的容量中。 1234567891011private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);} size+1的问题 好了，那到这里可以说一下为什么要size+1。 size+1代表的含义是： 如果集合添加元素成功后，集合中的实际元素个数。 为了确保扩容不会出现错误。 假如不加一处理，如果默认size是0，则0+0&gt;&gt;1还是0。如果size是1，则1+1&gt;&gt;1还是1。有人问:不是默认容量大小是10吗?事实上，jdk1.8版本以后，ArrayList的扩容放在add()方法中。之前放在构造方法中。我用的是1.8版本，所以默认ArrayList arrayList = new ArrayList();后，size应该是0.所以,size+1对扩容来讲很必要. 123456public static void main(String[] args) { ArrayList arrayList = new ArrayList(); System.out.println(arrayList.size());}输出:0 事实上上面的代码是证明不了容量大小的，因为size只会在调用add()方法时才会自增。有办法的小伙伴可以在评论区大显神通。 add(int index, E element)方法123456789public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;} rangeCheckForAdd()是越界异常检测方法。ensureCapacityInternal()之前有讲，着重说一下System.arrayCopy方法： 1234567public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)代码解释: Object src : 原数组 int srcPos : 从元数据的起始位置开始 Object dest : 目标数组 int destPos : 目标数组的开始起始位置 int length : 要copy的数组的长度 示例：size为6，我们调用add(2,element)方法，则会从index=2+1=3的位置开始，将数组元素替换为从index起始位置为index=2，长度为6-2=4的数据。 异常处理： 1234private void rangeCheckForAdd(int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));} set(int index,E element)方法1234567891011public E set(int index, E element) { rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;}E elementData(int index) { return (E) elementData[index];} 逻辑很简单，覆盖旧值并返回。 indexOf(Object o)方法 根据Object对象获取数组中的索引值。 123456789101112public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1;} 如果o为空，则返回数组中第一个为空的索引；不为空也类似。 注意：通过源码可以看到，该方法是允许传空值进来的。 get(int index)方法 返回指定下标处的元素的值。 12345public E get(int index) { rangeCheck(index); return elementData(index);} rangeCheck(index)会检测index值是否合法，如果合法则返回索引对应的值。 remove(int index)方法 删除指定下标的元素。 12345678910111213141516public E remove(int index) { // 检测index是否合法 rangeCheck(index); // 数据结构修改次数 modCount++; E oldValue = elementData(index); // 记住这个算法 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;} 这里又碰到了System.arraycopy()方法，详情请查阅上文。 大概思路：将该元素后面的元素前移，最后一个元素置空。 ArrayList优缺点优点： 因为其底层是数组，所以修改和查询效率高。 可自动扩容(1.5倍)。 缺点： 插入和删除效率不高。 线程不安全。 那面试手写ArrayList应该就不是问题了。","link":"/2019/07/15/arrayList源码分析/"},{"title":"Mysql在项目中的基本操作","text":"Mysql数据库：关系型数据库 NOSQL数据库关系型数据库：Oracle Mysql(SUN Java) DB2(IBM) 表的管理 DML（INSERT UPDATE DELETE SELECT） MYSQL常用的数据类型 int(6) double(10,2) varchar:可变长字符类型 name varchar(10) Jack char:不可变长字符类型 idcode char(18) 210 date:日期类型 timestamp:时间戳类型 约束 主键约束：primary key,主键字段的值非空唯一 外键约束：foreign key references t1(id);外键字段值引用其他主键字段的值 创建数据库 1create database tedudb; 选择数据库 1use tedudb; 创建表 12345678910create table t_user( id int(6) auto_increment primary key, username varchar(20), password varchar(20), email varchar(50), phone varchar(20), type char(1), created timestamp, updated timestamp); 需求：根据如下需求创建表 创建部门表和员工表，员工表中有部门号字段为外键字段，引用部门表中部门号字段部门表字段：部门号，部门名，部门地址员工表字段：员工号，员工姓名，职位，薪水，入职日期，经理编号，部门号 部门表 12345create table dept1( deptno int(2) auto_increment primary key, dname varchar(30), loc varchar(50) ); 员工表1 1234567891011create table emp1( empno int(4) auto_increment primary key, ename varchar(20), job varchar(20), sal double(10,2), hiredate date, mgr int(4), deptno int(2), foreign key(mgr) references emp1(empno), foreign key(deptno) references dept1(deptno)); 查看数据库表：show tables; 查看表结构：desc t_user;12345create table dept2( deptno int(2) auto_increment primary key, dname varchar(30), loc varchar(50) ); 员工表2 123456789create table emp2( empno int(4) auto_increment primary key, ename varchar(20), job varchar(20), sal double(10,2), hiredate date, mgr int(4), deptno int(2)); 通过修改表的方式添加外键： 12alter table emp2 add foreign key(mgr) references emp2(empno); alter table emp2 add foreign key(deptno) references dept2(deptno); 创建表设置字符集 12345678910111213141516create table dept( deptno int(2) auto_increment primary key, dname varchar(30), loc varchar(50) ) default charset=utf8; create table emp( empno int(4) auto_increment primary key, ename varchar(20), job varchar(20), sal double(10,2), hiredate date, mgr int(4), deptno int(2))default charset=utf8; alter table emp add foreign key(mgr) references emp(empno); alter table emp add foreign key(deptno) references dept(deptno); DML： INSERT:添加数据 需求：创建管理员账号 insert into t_user values(NULL,’admin’,’admin’,‘admin@tedu.cn’,’15699782000’,’2’,now(),now()); 需求：创建普通用户账号 insert into t_user values(NULL,’user01’,’user01’,‘user01@tedu.cn’,’15699782111’,’1’,now(),now()); 需求： 1、创建4个部门分别为10,20,30,40,部门名为研发部，教学部，人事部，财务部 insert into dept values(10,’研发部’,’兰理工本部综合楼301’); insert into dept values(20,’教学部’,’兰理工本部综合楼302’); insert into dept values(30,’人事部’,’兰理工本部综合楼303’); insert into dept values(40,’财务部’,’兰理工本部综合楼304’); 2、向员工表中添加如下员工： * 一个总裁 insert into emp values(7000,’KING’,’总裁’,20000,’2010-1-1’,null,10); * 三个部门（研发部，教学部，人事部）经理 insert into emp values(7001,’汪梦婷’,’经理’,18000,’2013-2-12’,7000,10); insert into emp values(7002,’马良’,’经理’,22000,’2014-3-10’,7000,20); insert into emp values(7003,’周荣民’,’经理’,10000,’2012-5-29’,7000,30); * 每个部门中添加5个员工 研发部 insert into emp values(7004,’王云飞’,’CLERK’,15000,’2012-09-19’,7001,10); insert into emp values(7005,’张宇’,’CLERK’,12500,’2013-02-12’,7001,10); insert into emp values(7006,’白浩诛’,’CLERK’,11000,’2017-12-12’,7001,10); insert into emp values(7007,’王禹’,’CLERK’,9000,’2018-06-06’,7001,10); insert into emp values(7008,’曹倩’,’CLERK’,19000,’2010-05-12’,7001,10); 教学部 insert into emp values(7010,’楚玲玲’,’讲师’,22000,’2016-09-19’,7002,20); insert into emp values(7011,’腾萃萃’,’讲师’,18000,’2013-02-12’,7002,20); insert into emp values(7012,’朱海熊’,’讲师’,15000,’2017-02-12’,7002,20); insert into emp values(7013,’刘依琳’,’讲师’,21500,’2017-07-06’,7002,20); insert into emp values(7014,’薛媛’,’讲师’,28000,’2010-04-12’,7002,20); 人事部 insert into emp values(7015,’张泽亮’,’人事专员’,6000,’2017-09-19’,7003,30); insert into emp values(7016,’严志威’,’人事专员’,5500,’2016-08-12’,7003,30); insert into emp values(7017,’刘俊翔’,’人事专员’,7000,’2015-07-12’,7003,30); insert into emp values(7018,’张帅帅’,’人事专员’,9000,’2014-06-06’,7003,30); insert into emp values(7019,’王广志’,’人事专员’,6500,’2010-05-12’,7003,30); UPDATE 需求：将公司中30号部门员工涨薪1000 update emp set sal=sal+1000 where deptno=30; update emp set sal=sal+600,hiredate=’2016-05-12’ where empno=7019; DELETE insert into emp(empno,ename) values(8000,’aaaa’); delete from emp where empno=8000; SELECT: DML（INSERT,UPDATE,DELETE） DQL（SELECT） DML（INSERT,UPDATE,DELETE,SELECT 增删改查 CRUD） 作业：课上所有的需求 基本查询select 字段1,字段2… from 表名;需求：列出员工姓名，薪水，职位，入职日期select ename,sal,job,hiredate from emp;需求：列出员工表中所有数据select * from emp;开发中，尽可能不使用*select empno,ename,job,sal,hiredate,mgr,deptno from emp; 过滤查询 需求：列出10号部门员工的姓名，工资，入职日期select ename,sal,hiredate from emp where deptno=10;需求：列出薪水低于10000的员工姓名，薪水，职位，部门号select ename,sal,job,deptno from emp where sal&lt;10000;需求：列出10号部门16年之后入职的员工姓名，薪水，职位，入职日期select ename,sal,job,hiredate from emp where deptno=10 and hiredate&gt;’2016-1-1’;需求：列出10号部门或16年之后入职的员工姓名，薪水，职位，入职日期，部门号select ename,sal,job,hiredate,deptno from emp where deptno=10 or hiredate&gt;’2016-1-1’;需求：列出10，20号部门中的员工姓名，薪水，职位，部门号select ename,sal,job,deptno from emp where deptno in(10,20);需求：列出&apos;王&apos;姓的员工姓名，职位，入职日期 模糊查询：like % _select ename,job,hiredate from emp where ename like ‘王%’;需求：列出名字中第二个字是&apos;浩&apos;的员工姓名，薪水，职位，入职日期，部门号select ename,sal,job,hiredate,deptno from emp where ename like ‘_浩%’; 排序查询order by asc(升序) desc(降序)需求：列出员工的姓名，薪水，职位入职日期，根据薪水降序排序select ename,sal,hiredate from emp order by sal desc;需求：列出员工的姓名，薪水，职位,入职日期，根据薪水降序排序,入职日期升序排序select ename,sal,hiredate from emp order by sal desc,hiredate asc; 需求：列出10号部门员工的姓名，薪水，职位，入职日期，根据薪水降序排序 select ename,sal,job,hiredate from emp where deptno=10 order by sal desc; 分组查询group by 统计运算：max min sum avg count 需求：列出公司中每个部门员工薪水总和select deptno, sum(sal) from emp group by deptno;需求：列出公司中每个部门的最大工资，最小工资，平均工资，工资总和select deptno,max(sal),min(sal),avg(sal),sum(sal) from emp group by deptno;需求：列出公司中有多少个员工select ename,count(*) from emp;–语法错误 注意：分组查询，只能查询分组字段和分组之后的组函数运算结果 多表查询（联合查询，内连接，外连接查询）查询的数据分布在多张表里 需求：列出员工姓名，薪水，职位，入职日期，部门名，部门地址 等值查询（等价于内连接） select ename,sal,job,hiredate,dname,loc from emp e,dept dwhere e.deptno=d.deptno;内连接查询select ename,sal,job,hiredate,dname,loc from emp e inner join dept don e.deptno=d.deptno;等值查询或内连接查询，查询的结果都必须满足连接条件 注意：多表查询一定要指定连接条件，条件的数量n-1 否则会出现笛卡尔乘积现象 外连接查询 左外连接、右外连接、全外连接 左外连接 select ename,sal,job,hiredate,dname,loc from emp e left outer join dept don e.deptno=d.deptno;右外连接select ename,sal,job,hiredate,dname,loc from dept d right outer join emp eon e.deptno=d.deptno;右外连接select ename,sal,job,hiredate,dname,loc from emp e right outer join dept don e.deptno=d.deptno; 全外连接（oracle支持）select ename,sal,job,hiredate,dname,loc from emp e full outer join dept don e.deptno=d.deptno; mysql分页查询select * from emp limit 5,5;","link":"/2019/07/23/mysql在项目中的基本操作/"}],"tags":[{"name":"Cookie","slug":"Cookie","link":"/tags/Cookie/"},{"name":"Session","slug":"Session","link":"/tags/Session/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"命令","slug":"命令","link":"/tags/命令/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"源码","slug":"源码","link":"/tags/源码/"}],"categories":[{"name":"Java 基础篇","slug":"Java-基础篇","link":"/categories/Java-基础篇/"},{"name":"web 前端","slug":"web-前端","link":"/categories/web-前端/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"数据库","slug":"数据库","link":"/categories/数据库/"},{"name":"Java 源码分析","slug":"Java-源码分析","link":"/categories/Java-源码分析/"}]}