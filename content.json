{"pages":[{"title":"归档","text":"","link":"/archives/index.html"},{"title":"关于我 & 留言板","text":"关于我 &amp; 留言板","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/03/hello-world/"},{"title":"IO 基础总结","text":"File类#File 并不是指文件本身两个常量： 路径分隔符File.pathSeparator 名称分隔符File.separator //路径表示的几种形式 //1、windows下 String path = &quot;C:\\\\Users\\\\dell\\\\Desktop&quot;; //2、 path = &quot;C:&quot;+File.separator+&quot;Users&quot;+File.separator+&quot;dell&quot;+File.separator+&quot;Desktop&quot;; //3、推荐方式 path = &quot;C:/Users/dell/Desktop&quot;; IO流基础 一、概念流动、流向 以程序为中心二、IO流分类1、流向: 输入流与输出流 2、数据 字节流:二进制 可以一切文件 包括纯文本 、doc 、音频 、视频等等 字符流:文本文件 只能处理纯文本 3、功能 节点:包裹源头 处理:增强功能，提供性能(提高效率)三、字符流与字节流(重点)1、字节流 输入流:InputStream 输出流:OutputStream 2、字符流 (读入 写出) 输入流:Reader 输出流:Writer四、操作1、与文件建立联系 2、选择流 3、操作 4、释放资源 ###FileWriter写数据### 输出流写数据的步骤： A、创建输出流对象 B、调用输出流对象的写数据方法 并刷新缓冲区 (硬盘存储数据的基本单位是字节) C、释放资源 (close()方法先刷新 再通知系统释放资源) 换行:\\n \\r \\r\\n * windows识别的换行为 \\r\\n * Linux识别的换行为 \\n * mac识别的换行为 \\r ###FileReader读数据### 同 FileWriter写数据 代码实例: * int len; * char[] chs = new char[1024]; * while ((len=fr.read(chs))!=-1) { * System.out.print((new String(chs,0,len))); * } * fr.close(); *注意 char[] chs = new char[1024]; //写1024及其整数倍 *往控制台输出时，不要ln System.out.print(); ###文件复制### 数据源: 目的地: *判断读 //先读 然后写进去 //后写 ###字符缓冲流### (高效地读入和写出) BufferedWriter bf = new BufferedWriter(new FileWriter(&quot;bf.txt&quot;)); BufferedReader br = new BufferedReader(new FileReader(&quot;bf.txt&quot;)); //注意构造方法里面 System.out.print(new String(csh,0,len)); // 缓冲流的特殊功能: newLine() //写一个换行符 这个换行符由系统决定 readLine() //读一行 【不包括换行符】 IO流高级 File:文件和目录路径名的抽象表示形式，File类的实例是不可变的(即File可以创建实例) ##创建功能 createNewFile() mkdir() mkdirs() ##删除功能 ##判断功能","link":"/2019/07/15/IO-基础总结/"},{"title":"About Markdown","text":"一、MarkdownMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持 二、语法2.1 分割线分割线最常使用就是三个或以上*，还可以使用-和_。2.2标题效果： 一级标题二级标题三级标题四级标题五级标题六级标题 2.3列表有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项2 . 第二项3 . 第三项 效果： 第一项 第二项 第三项 后面俩字加黑 后面俩字斜体 2.4段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 2.5代码段1234567 for(int j=0;j&lt;=ny;++j) { if(i) DP[i][j]+=DP[i-1][j]; if(j) DP[i][j]+=DP[i][j-1]; DP[i][j]*=!mark[i][j];}","link":"/2019/07/03/my-first-article/"},{"title":"单例模式","text":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 优点1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 实现方式一：懒汉式（线程不安全）懒汉式：就是用的时候再进行实例化对象。 1234567891011public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 这种实现方式不支持多线程，因为没有同步锁，多线程下不能正常工作。 实现方式二：懒汉式（线程安全）12345678910public class Singleton { private static Singleton instance; public static synchronized Singleton getInstance(){ if (instance == null){ instance = new Singleton(); } return instance; }} 可以在多线程环境下使用，但是效率太低。 优点：一个对象初始化一次，节省内存。缺点：必须用synchronized来维持单例，没效率。 实现方式三：饿汉式（线程安全）1234567public class Singleton { private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; }} 因为它作为静态资源，所以在类装载时就被实例化 优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。 实现方式四：双检锁/双重校验锁DCL（线程安全）1234567891011121314public class Singleton { private static Singleton instance; public static Singleton getInstance(){ if (instance == null){ synchronized (Singleton.class){ if (instance == null){ instance = new Singleton(); } } } return instance; }} 采用双锁机制，安全且在多线程情况下能保持高性能。详细了解请点击：Java并发编程 – 单例模式线程安全问题 实现方式五：登记式/静态内部类（线程安全）1234567891011public class Singleton { private static Singleton instance; private static class SingletonHandler{ private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance(){ return SingletonHandler.INSTANCE; }} 这种方式可以说是恶汉式的变通版，SingletonHandler没有被主动使用的情况下是不会实例化Singleton对象的，所以这样做，既能达到lazy式的加载，又能保证线程安全。 实现方式六：枚举类（线程安全）123456public enum Singleton { INSTANCE; public void myMethod() { System.out.println(&quot;enum instance test&quot;); }} 它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。 测试： 123456public class Main { public static void main(String[] args) { Singleton singleton = Singleton.INSTANCE; singleton.myMethod(); }} 1enum instance test 总结不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。","link":"/2019/07/20/单例模式/"},{"title":"ArrayList源码分析","text":"简介 ArrayList是我们开发中非常常用的数据存储容器之一，其底层是数组实现的，我们可以在集合中存储任意类型的数据，ArrayList是线程不安全的，非常适合用于对元素进行查找，效率非常高。 线程安全性对ArrayList的操作一般分为两个步骤，改变位置(size)和操作元素(e)。所以这个过程在多线程的环境下是不能保证具有原子性的，因此ArrayList在多线程的环境下是线程不安全的。 源码分析1. 属性分析1234567891011121314151617181920212223242526272829303132/** * 默认初始化容量 */private static final int DEFAULT_CAPACITY = 10;/** * 如果自定义容量为0，则会默认用它来初始化ArrayList。或者用于空数组替换。 */private static final Object[] EMPTY_ELEMENTDATA = {};/** * 如果没有自定义容量，则会使用它来初始化ArrayList。或者用于空数组比对。 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};/** * 这就是ArrayList底层用到的数组 * 非私有，以简化嵌套类访问 * transient 在已经实现序列化的类中，不允许某变量序列化 */transient Object[] elementData;/** * 实际ArrayList集合大小 */private int size;/** * 可分配的最大容量 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 扩展：什么是序列化序列化是指：将对象转换成以字节序列的形式来表示，以便用于持久化和传输。 实现方法：实现Serializable接口。 然后用的时候拿出来进行反序列化即可又变成Java对象。 transient关键字解析 Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化。 有了transient关键字声明，则这个变量不会参与序列化操作，即使所在类实现了Serializable接口，反序列化后该变量为空值。 那么问题来了：ArrayList中数组声明：transient Object[] elementData;，事实上我们使用ArrayList在网络传输用的很正常，并没有出现空值。 原来：ArrayList在序列化的时候会调用writeObject()方法，将size和element写入ObjectOutputStream；反序列化时调用readObject()，从ObjectInputStream获取size和element，再恢复到elementData。 那为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？ 原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。 2. 构造方法分析根据initialCapacity 初始化一个空数组，如果值为0，则初始化一个空数组: 12345678910111213/** * 根据initialCapacity 初始化一个空数组 */public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); }} 不带参数初始化，默认容量为10: 123456/** * 不带参数初始化，默认容量为10 */public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;} 通过集合做参数的形式初始化：如果集合为空，则初始化为空数组： 1234567891011121314/** * 通过集合做参数的形式初始化 */public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; }} 3. 主干方法trimToSize()方法： 用来最小化实例存储，将容器大小调整为当前元素所占用的容量大小。 1234567891011/** * 这个方法用来最小化实例存储。 */public void trimToSize() { modCount++; if (size &lt; elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); }} clone()方法 用来克隆出一个新数组。 1234567891011public Object clone() { try { ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(e); }} 通过调用Object的clone()方法来得到一个新的ArrayList对象，然后将elementData复制给该对象并返回。 add(E e)方法 在数组末尾添加元素 12345678/** * 在数组末尾添加元素 */public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;} 看到它首先调用了ensureCapacityInternal()方法.注意参数是size+1,这是个面试考点。 123private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));} 这个方法里又嵌套调用了两个方法:计算容量+确保容量 计算容量：如果elementData是空，则返回默认容量10和size+1的最大值，否则返回size+1 123456private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity;} 计算完容量后，进行确保容量可用：(modCount不用理它，它用来计算修改次数) 如果size+1 &gt; elementData.length证明数组已经放满，则增加容量，调用grow()。 1234567private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);} 增加容量：默认1.5倍扩容。 获取当前数组长度=&gt;oldCapacity oldCapacity&gt;&gt;1 表示将oldCapacity右移一位(位运算)，相当于除2。再加上1，相当于新容量扩容1.5倍。 如果newCapacity&lt;minCapacity，则newCapacity = minCapacity。看例子更明白一点：假设size为1,则minCapacity=size+1=2,而elementData.length=1,newCapacity=1+1&gt;&gt;1=1,1&lt;2所以如果不处理该情况，扩容将不能正确完成。 如果新容量比最大值还要大，则将新容量赋值为VM要求最大值。 将elementData拷贝到一个新的容量中。 1234567891011private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);} size+1的问题 好了，那到这里可以说一下为什么要size+1。 size+1代表的含义是： 如果集合添加元素成功后，集合中的实际元素个数。 为了确保扩容不会出现错误。 假如不加一处理，如果默认size是0，则0+0&gt;&gt;1还是0。如果size是1，则1+1&gt;&gt;1还是1。有人问:不是默认容量大小是10吗?事实上，jdk1.8版本以后，ArrayList的扩容放在add()方法中。之前放在构造方法中。我用的是1.8版本，所以默认ArrayList arrayList = new ArrayList();后，size应该是0.所以,size+1对扩容来讲很必要. 123456public static void main(String[] args) { ArrayList arrayList = new ArrayList(); System.out.println(arrayList.size());}输出:0 事实上上面的代码是证明不了容量大小的，因为size只会在调用add()方法时才会自增。有办法的小伙伴可以在评论区大显神通。 add(int index, E element)方法123456789public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;} rangeCheckForAdd()是越界异常检测方法。ensureCapacityInternal()之前有讲，着重说一下System.arrayCopy方法： 1234567public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)代码解释: Object src : 原数组 int srcPos : 从元数据的起始位置开始 Object dest : 目标数组 int destPos : 目标数组的开始起始位置 int length : 要copy的数组的长度 示例：size为6，我们调用add(2,element)方法，则会从index=2+1=3的位置开始，将数组元素替换为从index起始位置为index=2，长度为6-2=4的数据。 异常处理： 1234private void rangeCheckForAdd(int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));} set(int index,E element)方法1234567891011public E set(int index, E element) { rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;}E elementData(int index) { return (E) elementData[index];} 逻辑很简单，覆盖旧值并返回。 indexOf(Object o)方法 根据Object对象获取数组中的索引值。 123456789101112public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1;} 如果o为空，则返回数组中第一个为空的索引；不为空也类似。 注意：通过源码可以看到，该方法是允许传空值进来的。 get(int index)方法 返回指定下标处的元素的值。 12345public E get(int index) { rangeCheck(index); return elementData(index);} rangeCheck(index)会检测index值是否合法，如果合法则返回索引对应的值。 remove(int index)方法 删除指定下标的元素。 12345678910111213141516public E remove(int index) { // 检测index是否合法 rangeCheck(index); // 数据结构修改次数 modCount++; E oldValue = elementData(index); // 记住这个算法 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;} 这里又碰到了System.arraycopy()方法，详情请查阅上文。 大概思路：将该元素后面的元素前移，最后一个元素置空。 ArrayList优缺点优点： 因为其底层是数组，所以修改和查询效率高。 可自动扩容(1.5倍)。 缺点： 插入和删除效率不高。 线程不安全。 那面试手写ArrayList应该就不是问题了。","link":"/2019/07/15/ArrayList源码分析/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"源码","slug":"源码","link":"/tags/源码/"}],"categories":[{"name":"Java 基础篇","slug":"Java-基础篇","link":"/categories/Java-基础篇/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"web 前端","slug":"web-前端","link":"/categories/web-前端/"},{"name":"Java源码分析","slug":"Java源码分析","link":"/categories/Java源码分析/"}]}