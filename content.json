{"pages":[{"title":"归档","text":"","link":"/archives/index.html"},{"title":"About Me","text":"我就是我，不一样的烟火 教育经历 本科就读于兰州理工大学软件工程专业 专业兴趣技能 -Java -大数据 联系我 QQ: 582023774","link":"/about/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"IO 常用API及基础总结","text":"File类#File 并不是指文件本身两个常量： 路径分隔符File.pathSeparator 名称分隔符File.separator //路径表示的几种形式 //1、windows下 String path = &quot;C:\\\\Users\\\\dell\\\\Desktop&quot;; //2、 path = &quot;C:&quot;+File.separator+&quot;Users&quot;+File.separator+&quot;dell&quot;+File.separator+&quot;Desktop&quot;; //3、推荐方式 path = &quot;C:/Users/dell/Desktop&quot;; IO流基础 一、概念流动、流向 以程序为中心二、IO流分类1、流向: 输入流与输出流 输入流 进内存输出流 出内存 2、数据 字节流:二进制 可以一切文件 包括纯文本 、doc 、音频 、视频等等 字符流:文本文件 只能处理纯文本 3、功能 节点:包裹源头 处理:增强功能，提供性能(提高效率)三、字符流与字节流(重点)1、字节流 输入流:InputStream 输出流:OutputStream 2、字符流 (读入 写出) 输入流:Reader 输出流:Writer四、操作1、与文件建立联系 2、选择流 3、操作 4、释放资源 ###FileWriter写数据### 输出流写数据的步骤： A、创建输出流对象 B、调用输出流对象的写数据方法 并刷新缓冲区 (硬盘存储数据的基本单位是字节) C、释放资源 (close()方法先刷新 再通知系统释放资源) 换行:\\n \\r \\r\\n * windows识别的换行为 \\r\\n * Linux识别的换行为 \\n * mac识别的换行为 \\r ###FileReader读数据### 同 FileWriter写数据 代码实例: * int len; * char[] chs = new char[1024]; * while ((len=fr.read(chs))!=-1) { * System.out.print((new String(chs,0,len))); * } * fr.close(); *注意 char[] chs = new char[1024]; //写1024及其整数倍 *往控制台输出时，不要ln System.out.print(); ###文件复制### 数据源: 目的地: *判断读 //先读 然后写进去 //后写 ###字符缓冲流### (高效地读入和写出) BufferedWriter bf = new BufferedWriter(new FileWriter(&quot;bf.txt&quot;)); BufferedReader br = new BufferedReader(new FileReader(&quot;bf.txt&quot;)); //注意构造方法里面 System.out.print(new String(csh,0,len)); // 缓冲流的特殊功能: newLine() //写一个换行符 这个换行符由系统决定 readLine() //读一行 【不包括换行符】 五、IO 常用API 的测试文件操作File:文件和目录路径名的抽象表示形式，File类的实例是不可变的(即File可以创建实例) ##创建功能 createNewFile() mkdir() mkdirs() ##删除功能 ##判断功能字节流字节缓冲流对象流转换流 (OutputStreamWriter 、 InputStreamReader)可以指定字符集 *实例化转化流，必须先实例化一个字节流*测试转换流 1234567891011121314@Testpublic void testOut() throws IOException { OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;osw.txt&quot;), &quot;UTF-8&quot;); osw.write(&quot;测试写字符，指定字符集为UTF-8&quot;); osw.close();}@Testpublic void testIn() throws IOException { InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;osw.txt&quot;),&quot;UTF-8&quot;); char[] buf = new char[1024]; isr.read(buf); System.out.println(new String(buf)); isr.close();} 缓冲字符流BufferedWriterBufferedReader 1234567891011121314151617@Testpublic void testOut() throws IOException { BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;)); bw.write(&quot;测试字符缓冲流&quot;); bw.flush(); bw.close();}@Testpublic void testIn() throws IOException { BufferedReader br = new BufferedReader(new FileReader(&quot;bw.txt&quot;)); //br.readLine() 读一行，读到最后时返回null String line = &quot;&quot;; while ((line=br.readLine())!=null) { System.out.println(line); } br.close();} 打印流 PrintWriter字符打印流12345678910111213141516/** * 测试打印流 * @throws FileNotFoundException */@Testpublic void testPrint() throws FileNotFoundException { PrintWriter pw = new PrintWriter(&quot;pw.txt&quot;); pw.print(&quot;测试字符打印流&quot;); pw.close();}@Testpublic void testPrintStream() throws FileNotFoundException { PrintStream ps = new PrintStream(&quot;ps.txt&quot;); ps.print(&quot;测试字节打印流&quot;); ps.close();} 六、注意1、字符流的底层，依然是字节流2、File 类只是用来表示目录和文件的相关信息，不对文件内容进行访问 new File(“”); //仅仅是创建一个内存对象3、int read() ; 读取一个字节/(字符)内容，返回将该字节内容存到int类型的低8/(16)位4、操作文件即为节点流5、包装流","link":"/2019/07/15/API常用之-IO/"},{"title":"API常用之--String","text":"charAt 用于给出位置上的字符valueOf 用于将其他类型转换为字符串类型indexOf 用于实现检索substring 获取子串位置trim 去除字符串周围空白","link":"/2019/08/11/API常用之-String/"},{"title":"IOC基本原理及相关实现","text":"一、IOC：Inversion of Control 控制反转.指的是 对象的创建权反转(交给)给 Spring. 作用是实现了程序的解耦合. 二、ioc(控制反转)底层原理1、传统方式开发，原始调用类中的方法对于如下类及其方法 123456public class ClassName{ //方法 public void methodName(){ //...... }} 若要调用方法methodName(),原始的做法都是先new一个对象，再用该对象调用类中的方法，即 12ClassName obj = new ClassName();obj.methodName(); 缺陷：耦合度太高 2、利用工厂模式解耦合 工厂模式 123public class Factory{ public static } 3、通过IOC把对象的创建交给spring进行管理第一步；创建xml文件第二部: 创建工厂类(使用dom4j解析配置文件 + 反射) 1234//使用dom4j解析配置文件//使用反射创建类对象class clazz = Class.forName() 三、Spring 中的工厂 通过工厂创建bean对象基本思路是：解析配置文件(配置文件中是类的唯一标识和全限定类名)，利用反射创建实例对象，然后将该标识和获得的对象分别作 key 和 value 封装到 Map 中。最后在静态方法中通过给定的唯一标识获取对应的 value 对象。 1234567891011121314151617181920212223242526272829303132333435363738394041public class BeanFactory { //定义一个Properties对象 private static Properties props; //定义一个Map,用于存放我们要创建的对象。我们把它称之为容器 private static Map&lt;String,Object&gt; beans; //使用静态代码块为Properties对象赋值 static { try { //实例化对象 props = new Properties(); //获取properties文件的流对象 InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;); props.load(in); //实例化容器 beans = new HashMap&lt;String,Object&gt;(); //取出配置文件中所有的Key Enumeration keys = props.keys(); //遍历枚举 while (keys.hasMoreElements()){ //取出每个Key String key = keys.nextElement().toString(); //根据key获取value String beanPath = props.getProperty(key); //反射创建对象 Object value = Class.forName(beanPath).newInstance(); //把key和value存入容器中 beans.put(key,value); } }catch(Exception e){ throw new ExceptionInInitializerError(&quot;初始化properties失败！&quot;); } } /** * 根据bean的名称获取对象 * @param beanName * @return */ public static Object getBean(String beanName){ return beans.get(beanName); } 比如，bean.properties如下：userDao 和 userService 是所提供的对象id标识,可根据个人喜好随意命名gavino.spring.dao.impl.UserDaoImpl 和 gavino.spring.service.impl.UserServiceImpl 是类的全限定类名。 12userDao=gavino.spring.dao.impl.UserDaoImpluserService=gavino.spring.service.impl.UserServiceImpl 四、DI :Dependency Injection 依赖注入.需要有 IOC 的环境,Spring 创建这个类的过程中,Spring 将类的依赖的属性设置进去。","link":"/2019/08/19/IOC基本原理及实现/"},{"title":"Bootstrap","text":"Bootstrap 简介 Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的, 一个用于快速开发 Web 应用程序和网站的前端框架。Bootstrap 的响应式 CSS 能够自适应于台式机、平板电脑和手机。 Bootstrap 环境安装Bootstrap 使用","link":"/2019/09/14/Bootstrap/"},{"title":"Dubbo 学习归档","text":"分布式服务架构RPC : 远程过程调用流动计算架构","link":"/2019/09/10/Dubbo-学习归档/"},{"title":"IntelliJ IDEA 常用笔记","text":"IDEA，全称 IntelliJ IDEA，是 Java 语言的集成开发环境，IDEA 在业界被公认为是最好的 java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS 整合、代码审查、创新的 GUI 设计等方面的功能可以说是超常的。 快捷输入psvmsout 类似的：soutp=System.out.println(“方法形参名 = “ + 形参名);soutv=System.out.println(“变量名 = “ + 变量);soutm=System.out.println(“当前类名.当前方法”);“abc”.sout =&gt; System.out.println(“abc”); 快捷键1、Alt+Enter快捷键是Idea中比较特殊的一个快捷键。 失效不起作用：第一步：进入Settings-&gt;Keymap-&gt;搜索：show Intention Actions这个快捷键。第二步：点击：Editor-&gt;intention-&gt;refactorings。将Introduce local variable这个选项勾选上。之后点击Apply，再点击Ok选项。之后就可以正常使用Alt+Enter快捷键了。 主题配置主题下载地址：http://www.easycolor.cc/intelliJidea/list.html 创建模块(Module)在 Eclipse 中我们有 Workspace（工作空间）和 Project（工程）的概念，在 IDEA中只有 Project（工程）和 Module（模块）的概念。这里的对应关系为： IDEA 官网说明：An Eclipse workspace is similar to a project in IntelliJ IDEAAn Eclipse project maps to a module in IntelliJ IDEA 翻译：Eclipse 中 workspace 相当于 IDEA 中的 ProjectEclipse 中 Project 相当于 IDEA 中的 Module 在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module。一个 Project可以有多个 Module。目前主流的大型项目都是分布式部署的，结构都是类似这种多 Module 结构。 模块的删除：先右键–&gt;选择Open Module Settings,点击 -，确认然后再右键删除 常用配置添加依赖 服务器的配置其他关闭打开 IDEA 时为上一次的project Settings –&gt; Appearance &amp; Behavior –&gt; System Settings, 取消 reopen last project on startup 前的勾选即可。","link":"/2019/07/28/IntelliJ-IDEA-常用笔记/"},{"title":"JSON简单应用","text":"","link":"/2019/08/13/JSON简单应用/"},{"title":"Java 内存模型","text":"cpu 多核并发缓存架构 Java 内存模型 JMM Java 线程内存模型跟cpu 缓存模型类似, 是基于 cpu 缓存模型来建立的, Java 线程内存模型是标准化的, 屏蔽掉了底层不同计算机的区别。 主内存 工作内存 主内存中的共享变量在工作内存中有一个共享变量的副本 JMM 数据原子操作 read(读取): 从主内存读取数据 load(载入): 将主内存读取到的数据写入工作内存 use(使用): 从工作内存读取数据来计算 assign(赋值): 将计算好的值重新赋值到工作内存中 store(存储): 将工作内存数据写入主内存 write(写入): 将 store 过去的变量值赋值给主内存中的变量 lock(锁定): 将主内存变量加锁, 标识为线程独占状态 unlock(解锁): 将主内存变量解锁, 解锁后其他线程可以锁定该变量 Java 内存模型执行流程(不加v关键字)： 1、每个线程从主内存中读出数据(共享变量)2、然后载入到各自相应的工作内存3、线程从工作内存读取数据(共享变量副本)开始使用, 在使用过程中，某些线程有可能会进行赋值操作(即改变工作内存中的数据),这时会导致线程间的数据不再一致4、当执行store 操作后，会将工作内存数据写入主内存5、然后将 store 过去的变量值赋值给主内存中的变量，由于某些线程改变了工作内存中的数据，所以在写入主内存后，会对主内存中的变量值进行修改, 而其他一些线程的值却从未改变 原子操作","link":"/2019/09/17/Java-内存模型/"},{"title":"Java 锁的种类及辨析","text":"","link":"/2019/09/07/Java-锁的种类及辨析/"},{"title":"Java中的那些属性和方法","text":"java类的成员变量包括实例变量和类变量，成员方法包括实例方法和类方法。 成员变量实例变量，是新建了实例后才能用的变量 类变量，是不用新建实例，直接通过类来调用的变量。特点是用static修饰。所以它们还有个响当当的名字，叫静态变量。成员变量最大，包括实例变量和类变量，类变量=静态变量 成员方法实例方法类方法注意 在不是继承关系的情况下，每new 一次对象 就生成一个实例变量 总得来说，Java中的属性是绑定到类型上，方法是绑定到对象上","link":"/2019/08/11/Java中的那些属性和方法/"},{"title":"Linux常用命令","text":"命令基本格式 一、常用基本命令1、 cpcp:copy 复制文件cp 源文件 目的地(目录)-p 保留文件原属性-r 复制目录 2、 | 管道output | input对某些命令执行的结果去作操作,会用到管道；用于命令与命令之间的连接，前一个命令的输出是后一个命令的输入 3、 rm rm [filename] remove 删除文件,对 root 用户有提示,普通用户没有提示 -f force 强制删除, root 无提示 -i 普通用户有提示的删除 -r 递归删除,慎重使用 -rf 4、文件的过滤 grep 123456789101112131415grep [OPTIONS] PATTERN [FILE...]过滤带有 [ 字符串 ] 的行grep [ 字符串 ] [ 文件 ] 过滤以 [ 字符串 ] 为开始的行grep [^ 字符串 ] [ 文件 ]过滤以 [ 字符串 ] 为结尾的行grep [ 字符串 $] [ 文件 ]过滤反选grep -v [ 字符串 ] [ 文件 ]eg.过滤以 root 为开始的行 grep ^root /etc/passwd过滤以 bash 为结尾的行grep bash$ /etc/passwd 二、文件操作三、查看日志四、查看进程和端口五、查看系统的状态TOP","link":"/2019/07/22/Linux常用命令/"},{"title":"SSM 整合","text":"通过对 SSM 框架的整合，加深对其应用的熟练以及底层原理的深刻理解，该整合使用的环境是 IntelliJ IDEA。 环境准备(一)创建数据库和表结构12345create database ssm; use ssm; create table account( id int primary key auto_increment, name varchar(20), money double ); (二)创建 Maven 工程(三)导入坐标并建立依赖(四)编写实体类(五)编写业务层接口(六)编写持久层接口整合步骤(一)保证 Spring 框架在 web 工程中独立运行(二)保证 SpringMVC 在 web 工程中独立运行(三)整合 Spring 和 SpringMVC(四)保证 MyBatis 框架在 web 工程中独立运行(五)整合 Spring 和 MyBatis 分析如何把代理对象存到 IOC 的容器里面去在 service 注入 dao 对象 把SqlMapConfig.xml配置文件中的内容配置到applicationContext.xml配置文件中 在 dao 接口中添加@Repository注解 在service中注入dao对象，进行测试 配置Spring的声明式事务管理 待以上配置完成后，即可删除SqlMapConfig.xml文件 (六)测试 SSM 整合结果","link":"/2019/09/08/SSM-整合/"},{"title":"Java面试难点和易混淆点总结(一)","text":"","link":"/2019/07/27/Java面试难点和易混淆点总结-一/"},{"title":"About Markdown","text":"一、MarkdownMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持 二、语法2.1 分割线分割线最常使用就是三个或以上*，还可以使用-和_。2.2字体后面俩字加黑 后面俩字斜体 2.3标题效果： 一级标题二级标题三级标题四级标题五级标题六级标题 2.4列表有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项 2 . 第二项 3 . 第三项 2.4.1列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第一个元素 2.5区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号 注意：只需在段落开头写一个 &gt; 即可，不必每行都带 &gt; ,一个区块的内容中间不能写空行。 2.6段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 2.7代码段1234567 for(int j=0;j&lt;=ny;++j) { if(i) DP[i][j]+=DP[i-1][j]; if(j) DP[i][j]+=DP[i][j-1]; DP[i][j]*=!mark[i][j];} 2.8表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 效果如下： 表头 表头 单元格 单元格 单元格 单元格 三、高级技巧3.1转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： 文本加粗** 正常显示星号 **","link":"/2019/07/03/about markdown/"},{"title":"Ajax的原理及实现","text":"一、什么是Ajax二、Ajax工作原理三、Ajax的实现","link":"/2019/07/24/ajax的原理及实现/"},{"title":"lambda表达式","text":"其实lambda表达式的本质是接口的子实现lambda表达式简化了匿名内部类的写法lambda表达式另一个叫法,函数式编程 1.lambda表达式: lambda表达式可以称之为闭包,他是java8中的一个非常重要的特性 很多java8新特性的写法都会用到lambda表达式 lambda表达式允许函数作为一个方法的参数,函数作为参数传递到方法中,这样代码就会变得简洁 语法: lambda 操作符 -&gt; -&gt; 左侧： 是 lambda 表达式的参数列表(接口中抽象方法的参数列表) -&gt; 右侧： 是 lambda 表达式中所需执行的功能，即 lambda 体(接口中抽象方法实现的功能) 123(parameters)-&gt;expression表达式或(parameters)-&gt;{statement代码块;} 说明: -可选参数声明:不需要声明参数类型,编译器统一识别参数值 -可选参数圆括号:只有一个参数无需定义圆括号,多个参数需要定义圆括号 -可选大括号:如果主体包含了一个语句,就不需要使用大括号，return 也可省 -可选返回关键字:如果主体只有一个表达式返回值,则编译器 会自动返回值,大括号需要指定返回了一个数据值 比如: //不要参数,返回值为5 ()-&gt;5 //接受一个参数(推断出数字类型),返回参数的2倍 x-&gt;2*x //接受两个参数(推断出数字类型),返回值为参数差值 (x,y)-&gt;x-y //接受两个参数,返回值为x-y (int x,int y)-&gt;x-y //接受一个参数,类型为String的参数,并输出参数的值 //推断出没有返回值,相当于方法的返回值void (String str)-&gt;System.out.println(str) //接受两个参数(推断出数字类型,返回值为参数的差值) (x,y)-&gt;{return (x-y);} 其实lambda表达式的本质就是接口的子实现 lambda表达式简化了匿名内部类的写法 lambda表达式另一个写法叫做函数式编程 注意: 就是把接口的实现是内部类,转换成函数式写法 使用lambda表达式需要注意变量的作用域问题: lambda表达式引用外层的成员变量如果外层的成员变量为final的,则在lambda内部不能修改成员变量的值如果外层的成员变量不是final的,则在lambda内部能修改成员变量的值 lambda表示式的局部变量可以不用声明为final,但必须不可以被后面的代码修改(即隐式的final特性) lambda表达式不允许声明一个与局部变量同名的参数或局部变量 2.方法的引用: 方法的引用方式用类名::方法名,其本质还是lambda表达式 具体的写法有四种 -构造器的引用 语法Class::new -静态方法的引用 语法 Class::静态方法的名称 -特定类任意的对象引用 语法 Class::非静态方法名称 -特定对象的方法引用 语法 instance(实例)对象::非静态的方法的的名称 12345public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{...}public interface List&lt;E&gt; extends Collection&lt;E&gt; {...}public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {...} 在 Iterable 接口的源码中提供了方法 forEach(Consumer&lt;? super T&gt; action) ,该方法的参数为一个接口 Consumer 对象, 并且调用其 accept(t) 方法。 123456789101112//Iterable接口的源码public interface Iterable&lt;T&gt; { ...... default void forEach(Consumer&lt;? super T&gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } ......} 在 Consumer 接口源码中，有一个 accept(T t) 方法。而且该接口用 @FunctionalInterface 修饰，是一个函数式接口 123456789101112//Consumer接口源码@FunctionalInterfacepublic interface Consumer&lt;T&gt; { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); ......} 再结合案例代码，不难分析 3.函数式接口 lambda 表达式需要”函数式接口”的支持接口中只有一个抽象方法的接口，称为函数式接口，可以使用注解 @FunctionalInterface 修饰 (保证该接口中只有一个抽象方法)，可以检查是否是函数式接口。 lambda 练习 调用 Collections.sort() 方法，通过定制排序比较两个 Employee (先按年龄比，年龄相同按姓名比), 使用 lambda 作为参数传递。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package lambda;import java.util.ArrayList;import java.util.Collections;/** * @author gavino */public class T_1 { public static void main(String[] args) { ArrayList&lt;Employee&gt; emps = new ArrayList&lt;Employee&gt;(); emps.add(new Employee(&quot;张三&quot;,19)); emps.add(new Employee(&quot;李四&quot;,18)); emps.add(new Employee(&quot;赵六&quot;,19)); emps.add(new Employee(&quot;王五&quot;,20)); Collections.sort(emps,(e1,e2)-&gt;{ if (e1.getAge()==e2.getAge()) { return e1.getName().compareTo(e2.getName()); }else { return Integer.compare(e1.getAge(), e2.getAge()); } }); emps.forEach(emp -&gt; System.out.println(emp)); }}class Employee{ private String name; private Integer age; public Employee() { } public Employee(String name, Integer age) { this.name = name; this.age = age; } public String getName() { return name; } public Integer getAge() { return age; } @Override public String toString() { return &quot;Employee [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; }} 结果 1234Employee [name=李四, age=18]Employee [name=张三, age=19]Employee [name=赵六, age=19]Employee [name=王五, age=20] ① 声明函数式接口，接口中声明抽象方法，public string getValue(String str);② 声明类 TestLambda ,类中编写方法使用接口作为参数，将一个字符串转换成大写，并作为方法的返回值③ 再将字符串的第 2 个和第 4 个索引位置进行截取子串 123456789101112131415161718192021222324252627package lanmbda;public class T_2 { public static void main(String[] args) { String str = &quot;lanzhou&quot;; String subStr = strHandler(str,(s)-&gt;s.substring(2, 4)); System.out.println(subStr); String upperStr = strHandler(str,(s)-&gt;s.toUpperCase()); System.out.println(upperStr); } /** * 用于处理字符串 * @return */ public static String strHandler(String str, MyFunction mf) { return mf.getValue(str); }}/** * 函数式接口 * @author gavino */@FunctionalInterfaceinterface MyFunction{ public String getValue(String str);} ① 声明一个带两个泛型的函数式接口，泛型类型为 &lt;T,R&gt; T 为参数,R 为返回值② 接口中声明对应抽象方法③ 在 TestLambda 类中声明方法，使用接口作为参数，计算两个 long 型参数的和④ 再计算两个 long 型参数的乘积 4.四大内置核心函数式接口在 java 8 之前已经有部分的函数式接口比如 java 8 以后","link":"/2019/09/02/lambda表达式/"},{"title":"mybatis配置中常见错误","text":"mybatis默认的包结构创建文件夹非常不方便，将其改为树形结构点击project右边的设置图标，将 Compact Middle Packages 的勾去掉即可。 环境搭建相关注意SqlMapConfig.xml头错误","link":"/2019/08/10/mybatis配置中常见错误/"},{"title":"博客记录","text":"博客搭建博客主题 填过的坑1、关于解决 npm 安装过慢的问题在cmd 命令行将默认源改为淘宝镜像源 2、 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/03/my blog/"},{"title":"sublime text 3 常用笔记","text":"如何运行程序Ctrl+B 运行程序后如何关闭下方方框1、 连按两次 Ctrl + ~ Ctrl + ~为打开Sublime Text 3控制台的快捷键2、 点击Esc键，立竿见影，最为便捷。","link":"/2019/07/27/sublime-text-3-常用笔记/"},{"title":"单例模式","text":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 优点1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 实现方式一：懒汉式（线程不安全）懒汉式：就是用的时候再进行实例化对象。 1234567891011public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 这种实现方式不支持多线程，因为没有同步锁，多线程下不能正常工作。 实现方式二：懒汉式（线程安全）12345678910public class Singleton { private static Singleton instance; public static synchronized Singleton getInstance(){ if (instance == null){ instance = new Singleton(); } return instance; }} 可以在多线程环境下使用，但是效率太低。 优点：一个对象初始化一次，节省内存。缺点：必须用synchronized来维持单例，没效率。 实现方式三：饿汉式（线程安全）1234567public class Singleton { private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; }} 因为它作为静态资源，所以在类装载时就被实例化 优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。 实现方式四：双检锁/双重校验锁DCL（线程安全）1234567891011121314public class Singleton { private static Singleton instance; public static Singleton getInstance(){ if (instance == null){ synchronized (Singleton.class){ if (instance == null){ instance = new Singleton(); } } } return instance; }} 采用双锁机制，安全且在多线程情况下能保持高性能。 实现方式五：登记式/静态内部类（线程安全）1234567891011public class Singleton { private static Singleton instance; private static class SingletonHandler{ private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance(){ return SingletonHandler.INSTANCE; }} 这种方式可以说是恶汉式的变通版，SingletonHandler没有被主动使用的情况下是不会实例化Singleton对象的，所以这样做，既能达到lazy式的加载，又能保证线程安全。 实现方式六：枚举类（线程安全）123456public enum Singleton { INSTANCE; public void myMethod() { System.out.println(&quot;enum instance test&quot;); }} 它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。 测试： 123456public class Main { public static void main(String[] args) { Singleton singleton = Singleton.INSTANCE; singleton.myMethod(); }} 1enum instance test 总结不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。 枚举、静态内部类、双检索模式、饿汉式都是线程安全的，如果懒汉式加了synchronized关键字也是线程安全的。1、饿汉式：线程安全，调用效率高，但是不能延时加载2、懒汉式：线程安全，调用效率不高，但是能延时加载3、DCL 由于JVM 底层模型原因，偶尔会出问题，不建议使用4、静态内部类实现模式：线程安全，调用效率高，可以延时加载5、枚举类：线程安全，调用效率高，不能延时加载，可以天然的防止反射和反序列化调用","link":"/2019/07/20/单例模式/"},{"title":"代理模式","text":"一、代理模式（Proxy Pattern） 代理模式也称为委托模式，是一种结构性设计模式。在代理模式中，一个类代表另一个类的功能。我们创建具有现有对象的对象，以便向外界提供功能接口。 优点可以隐藏委托类的实现;可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。 二、静态代理 静态代理设计模式 * 1、真实角色 * 2、代理角色： 要持有真实角色的引用 * 3、二者要实现相同的接口 12 装饰者模式就是静态代理的一种体现。 三、动态代理 字节码随用随创建，随用随加载。动态代理常用的有两种方式 基于接口提供者：JDK 官方的 Proxy 类。要求：被代理类最少实现一个接口。 基于子类提供者：第三方的 CGLib，如果报 asmxxxx 异常，需要导入 asm.jar。要求：被代理类不能用 final 修饰的类（最终类）。 基于接口的动态代理123456789101112131415161718192021222324252627282930package proxy.dynamic;/** * @author gavino * 模拟厂家，厂家直销 */public class Manufacturers implements Market { @Override public void sal(Double price) { System.out.println(&quot;收款 &quot;+price); } @Override public void afterSal() { System.out.println(&quot;免费售后2333&quot;); }}/** * @author gavino * 该接口提供销售规则 */interface Market{ /** * 出售 */ public void sal(Double price); /** * 售后 */ public void afterSal();} 123456789101112131415161718192021222324252627282930313233343536373839package proxy.dynamic;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @author gavino * 模拟消费者 */public class Customer { public static void main(String[] args) { //代理类中的真实对象(Manufacturers 制造商、厂商) final Manufacturers manufacturers = new Manufacturers(); Market agency = (Market) Proxy.newProxyInstance(manufacturers.getClass().getClassLoader(),manufacturers.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //获取当前方法方法 String name = method.getName(); //获取方法执行的参数 Double money = (Double) args[0]; Object realValue = null; if (&quot;sal&quot;.equals(name)) { realValue = method.invoke(manufacturers, money*0.8); } return realValue; } }); manufacturers.sal(13300.0); agency.sal(13300.0); }}=================================== 程序执行结果 ===============================================收款 13300.0收款 10640.0 相关方法和参数的详解Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法Proxy.newProxyInstance(loader, interfaces, h);这个方法的作用就是创建一个代理类对象，它接收三个参数：1、loader：一个classloader对象，定义了由哪个classloader对象对生成的代理类进行加载2、interfaces：一个interface对象数组，表示我们将要给我们的代理对象提供一组什么样的接口， 如果我们提供了这样一个接口对象数组，那么也就是声明了代理类实现了这些接口，代理类就可以调用接口中声明的所有方法。3、h：一个InvocationHandler对象，表示的是当动态代理对象调用方法的时候会关联到哪一个InvocationHandler对象上，并最终由其调用 通过Proxy类的newProxyInstance方法创建代理对象，我们来看下方法中的参数 第一个参数：manufacturers.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象 第二个参数：manufacturers.getClass().getInterfaces()，这里为代理类提供的接口是真实对象实现的接口， 这样代理对象就能像真实对象一样调用接口中的所有方法 第三个参数：h(匿名内部类)，我们将代理对象关联到上面的InvocationHandler对象上 123456789/** * newProxyInstance方法的参数含义： * ClassLoader：和被代理对象使用相同的类加载器。 * 它是用于加载代理对象字节码的。 * Interfaces：Class[]：字节码数组,和被代理对象具有相同的行为。实现相同的接口。 * InvocationHandler：如何代理。用于提供增强的代码. * 常情况下都是匿名内部类,此接口的实现类都是谁用谁写. */ Proxy.newProxyInstance(loader, interfaces, h); 12345678910111213141516171819202122new InvocationHandler() { /** * 执行被代理对象的任何方法，都会经过该方法。 * 此方法有拦截的功能。 * * 参数： * proxy：代理对象的引用。不一定每次都用得到 * method：当前执行的方法 * args：当前执行方法所需的参数 * 返回值： * 当前执行方法的返回值 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 方法增强 return null; }}-----------------------------------------------------------------------------------------method.invoke(obj, args); 基于接口的动态代理实现的总结 基于子类的动态代理 基于子类的动态代理 要求：被代理对象不能是最终类 用到的类：Enhancer 用到的方法：create(Class, Callback) 方法的参数： Class：被代理对象的字节码 Callback：如何代理 导入cglib的jar包和asm的jar包(maven 工程导入 cglib 依赖即可)去掉接口实现 12345678910111213package proxy.dynamic.cglib;/** * @author gavino * 模拟厂家，厂家直销 */public class Manufacturers { public void sal(Double price) { System.out.println(&quot;收款 &quot;+price); } public void afterSal() { System.out.println(&quot;免费售后2333&quot;); }} 1234567891011121314151617181920212223242526272829303132333435package proxy.dynamic.cglib;import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * @author gavino * 模拟消费者 */public class Customer { public static void main(String[] args) { final Manufacturers manufacturers = new Manufacturers(); Manufacturers cglibManufacturers = (Manufacturers)Enhancer.create(manufacturers.getClass(), new MethodInterceptor() { @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { //提供增强的代码 Object realValue = null; //获取方法执行的参数 Double money = (Double)args[0]; if(&quot;sal&quot;.equals(method.getName())) { realValue = method.invoke(manufacturers, money*0.8); } return realValue; } }); manufacturers.sal(12000.0); cglibManufacturers.sal(12000.0); }}======================================= 程序执行输出 ================================================收款 12000.0收款 9600.0 相关方法和参数的详解 12Enhancer.create(type, callback); 12345678910111213141516Enhancer.create(type, new MethodInterceptor() { /** * 执行被代理对象的任何方法，都会经过该方法。在此方法内部就可以对被代理对象的任何方法进行增强。 * * 参数： * 前三个和基于接口的动态代理是一样的。 * MethodProxy：当前执行方法的代理对象。 * 返回值： * 当前执行方法的返回值 */ @Override public Object intercept(Object arg0, Method arg1, Object[] arg2, MethodProxy arg3) throws Throwable { // 方法的增强 return null; }});","link":"/2019/08/23/代理模式/"},{"title":"策略、回调和多态","text":"策略可以理解为是一个接口的子实现回调是一种双向的调用方式,是一种思想、是一种机制回调也是多态的一种体(实)现 回调思想： 假如 类 A 中有方法a()和方法aBack(),类 B 中有方法b()类 A 调用 类 B 中的方法 b(),方法b()执行完后，主动调用类 A 的aBack() 方法形成一种双向调用的形式回调的核心就是调用方将本身即this传递给回调方，回调方再反过来调用调用方的方法 回调分为同步回调和异步回调。 经典应用场景在网上看到过一个比较经典的应用场景，非常好的解释了回调机制 老师问学生问题，学生思考完毕回答老师。场景分析: 策略、回调和多态三者之间的联系： 回调的方法，即重写的方法，是某一个策略实现在动态绑定过程中，根据多态的性质，首先利用策略决定绑定对象然后由该对象调用回调方法实现方法重写，实际上调用的是重写的方法在这种情况下，可以说多态是由策略和回调实现的 注：至于重载到底属不属于多态牵强的说是可以的","link":"/2019/09/06/策略、回调和多态/"},{"title":"策略模式","text":"在参数中传入接口， 什么是策略模式##","link":"/2019/09/04/策略模式/"},{"title":"细说 Java 线程池","text":"线程池线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。 为什么要使用线程池: 1.减少了创建和销毁线程的次数,每个工作线程都可以被重复 使用,或利用,可以并发执行多个任务 2.可以根据系统的承受能力,调整线程池中的工作线程数目 防止因为消耗过多的内存,而使服务器宕机(down) 结论:就是java给提供一批api方法,用于更好的管理线程 程序员只需要专注于写run方法(线程的逻辑) 自定义线程池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package thread.pool;//阻塞式队列import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.RejectedExecutionHandler;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * 此类演示手动创建线程池 * 核心：线程池执行器 * @author gavino * */public class TestExecutorService { public static void main(String[] args) { //手动创建一个线程池 ThreadPoolExecutor threadPool = new ThreadPoolExecutor(5, 10, 30L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(5),new RejectedExecutionHandler() { //回调方法 @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { System.out.println(&quot;线程数超过了线程池的容量，拒绝执行任务--&gt;&quot;+r); } }); //创建线程对象，并把线程对象放在线程池中，并执行 (这样并不等于执行run ) threadPool.execute(new TestThread(1)); threadPool.execute(new TestThread(2)); threadPool.execute(new TestThread(3)); threadPool.execute(new TestThread(4)); threadPool.execute(new TestThread(5)); threadPool.execute(new TestThread(6)); threadPool.execute(new TestThread(7)); threadPool.execute(new TestThread(8)); threadPool.execute(new TestThread(9)); threadPool.execute(new TestThread(10)); threadPool.execute(new TestThread(11)); threadPool.execute(new TestThread(12)); threadPool.execute(new TestThread(13)); threadPool.execute(new TestThread(14)); threadPool.execute(new TestThread(15)); threadPool.execute(new TestThread(16)); }}/** * 写线程的任务逻辑 * @author gavino * */class TestThread implements Runnable{ private int num; public TestThread(int num) { this.num=num; } @Override public void run() { try { System.out.println(&quot;第&quot;+num+&quot;号线程开始执行&quot;); Thread.sleep(3000); System.out.println(&quot;第&quot;+num+&quot;号线程执行结束&quot;); } catch (InterruptedException e) { e.printStackTrace(); } }} 对上面代码进行分析 ThreadPoolExecutor 及其相关参数new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);corePoolSize:核心池大小maximumPoolSize:最大池大小keepAliveTime:空闲的多余线程保持时间unit:时间单位workQueue:阻塞式队列handler:拒绝服务助手 在上面的代码中，一共创建了16个线程对象核心线程满了，线程会进入阻塞队列，阻塞式队列满了，才开临时线程能执行的线程总数为: 核心线程数量 + 阻塞队列中的线程数量 + 临时线程数量在上面的代码中，corePoolSize为5，maximumPoolSize为10， ThreadPoolExecutor线程池再分析 刚开始时线程池是空的，当有线程任务来临时则先用核心线程来处理 如果有新任务，并且之前有空闲线程，但不足核心池大小则创建新的线程 如果有新任务，核心线程数已经达到核心池大小，并且有空闲线程，则使用空闲线程来处理 如果有新任务，但核心线程都忙着，则把线程放在队列中，等核心线程有空闲了，再从队列中取出线程来处理 如果核心线程都忙，并且队列也满了，则需要开临时线程处理新任务，但不能超过最大线程数目 如果核心线程有空闲，队列中也没有阻塞的任务，则根据线程存活时间来销毁线程池中的线程(被销毁的线程有可能是核心线程，也有可能是临时线程),直到等于核心线程数为止 如果核心线程数、队列中的线程数、临时线程数都是最大值时，则回调handler提示 注意 ThreadPoolExecutor 将根据corePoolSize和maximumPoolSize设置的边界自动调整池大小 当新任务在方法 execute(java.lang.Runnable) 中提交时，如果运行的线程少于 corePoolSize，则创建新线程来处理请求，即使其他辅助线程是空闲的 如果运行的线程多于corePoolSize而少于maximumPoolSize，则仅当队列满时才创建新线程 如果设置的corePoolSize和maximumPoolSize相同，则创建了固定大小的线程池 如果将maximumPoolSize设置为基本的无界值(如Integer.MAX_VALUE)，则允许池适应任意数量的并发任务。 在大多数情况下，核心和最大池大小仅基于构造来设置，不过也可以使用setCorePoolSize(int)和setMaximumPoolSize(int)进行动态更改。 线程池的使用:有一个Executors的线程工具类,此类提供了若干静态方法这些静态方法用于生成线程池的对象 Executors.newSingleThreadExecutor(); 创建一个单线程的线程池,这个线程池只有一个线程在工作即单线程执行任务,如果这个唯一的线程因为异常结束,那么就会有一个新的线程来替代它,,因此线程池保证所有的任务是按照任务的提交顺序来执行 Executors.newFixedThreadPool(); 创建固定大小的线程池,每次提交一个任务就创建一个线程直到线程达到线程池的最大的大小,线程池的大小一旦达到最大就会保持不变,如果某个线程因为执行异常而结束,那么久会补充一个新的线程 Executors.newCachedThreadPool(); 创建了一个可以缓冲的线程池,如果线程大小超过处理任务所需要的线程,那么就回收部分线程,当线程数增加的时候,此线程池由可以智能添加新的线程来处理任务,此线程不会对线程池大小做限制,线程池的大小完全依赖操作系统能够创建的最大大小 Executors.newScheduledThreadPool() 创建一个大小无限制的线程池,此线程池支持定时以及周期性的执行任务的需求","link":"/2019/09/03/细说-Java-线程池/"},{"title":"这就是MyBatis","text":"本文将通过对 MyBatis 基础知识的总结，加深对 MyBatis 的理解与应用。 一、MyBatis 框架概述 mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。它封装了jdbc 操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程采用了ORM 思想解决了实体和数据库映射的问题，实现了结果集的封装。 ORM Object Relational Mappging 对象关系映射简单的说： 就是把数据库表和实体类及实体类的属性对应起来 让我们可以操作实体类就实现操作数据库表。 数据库 实体类 user User-&gt;User id userId-&gt;id user_name userName-&gt;user_name 二、JDBC 的回顾与分析1// 三、MyBatis 框架快速入门编写 User 实体类12345678910111213141516171819202122232425262728293031323334package gavino.mybatis.domain;import java.io.Serializable;import java.util.Date;/** * @author Yan weigang */public class User implements Serializable { private Integer userId; private String userName; private String userAddress; private String userSex; private Date userBirthday; public Integer getUserId() { return userId; } public void setUserId(Integer userId) { this.userId = userId; } //......此处为节省篇幅省去部分Getter and Setter public void setUserBirthday(Date userBirthday) { this.userBirthday = userBirthday; } @Override public String toString() { return &quot;User{&quot; + &quot;userId=&quot; + userId + &quot;, userName=&apos;&quot; + userName + &apos;\\&apos;&apos; + &quot;, userAddress=&apos;&quot; + userAddress + &apos;\\&apos;&apos; + &quot;, userSex=&apos;&quot; + userSex + &apos;\\&apos;&apos; + &quot;, userBirthday=&quot; + userBirthday + &apos;}&apos;; }} 编写持久层接口 IUserDao123456789package gavino.mybatis.dao;import gavino.mybatis.domain.User;import java.util.List;/** * @author Yan weigang */public interface IUserDao { List&lt;User&gt; findAll();} 编写持久层接口的映射文件 IUserDao.xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;gavino.mybatis.dao.IUserDao&quot;&gt; &lt;!--配置查询所有--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;lut.dats.mybatis.test.domain.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 编写测试类123456789101112131415161718192021222324252627282930313233343536373839package gavino.mybatis.test;import gavino.mybatis.dao.IUserDao;import gavino.mybatis.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;/** * @author Yan weigang */public class MybatisTest { @Test public void testMybatis() throws IOException { //读取配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建 SqlSessionFactory 的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //使用构建者创建工厂对象 SqlSessionFactory SqlSessionFactory factory = builder.build(is); //使用 SqlSessionFactory 生产 SqlSession 对象 SqlSession session = factory.openSession(); //使用 SqlSession 创建 dao 接口的代理对象 IUserDao mapper = session.getMapper(IUserDao.class); //使用代理对象执行查询所有方法 List&lt;User&gt; users = mapper.findAll(); users.forEach(user -&gt; System.out.println(user)); session.commit(); //释放资源 session.close(); is.close(); }} 总结 mybatis的环境搭建 第一步：创建maven工程并导入坐标 第二步：创建实体类和dao的接口 第三步：创建Mybatis的主配置文件 SqlMapConifg.xml 第四步：创建映射配置文件 IUserDao.xml 环境搭建的注意事项： 第一个：创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识保持一致。在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper所以：IUserDao 和 IUserMapper是一样的 第二个：在idea中创建目录的时候，它和包是不一样的包在创建时：lut.gavino.dao它是三级结构目录在创建时：lut.gavino.dao是一级目录 第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同 第四个：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名 第五个：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名 注意 不要忘记在映射配置中告知mybatis要封装到哪个实体类中配置的方式：指定实体类的全限定类名 明确 我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。不管使用XML还是注解配置。但是Mybatis它是支持写dao实现类的。 四、MyBatis 中的设计模式12345678/创建 SqlSessionFactory 的构建者对象SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();//使用构建者创建工厂对象 SqlSessionFactorySqlSessionFactory factory = builder.build(is);//使用 SqlSessionFactory 生产 SqlSession 对象SqlSession session = factory.openSession();//使用 SqlSession 创建 dao 接口的代理对象IUserDao mapper = session.getMapper(IUserDao.class); 构建者模式创建工厂mybatis 使用了构建者模式把对象的创建细节隐藏，使使用者直接调用方法即可拿到对象 工厂模式生产SqlSession 使用了工厂模式优势：解耦(降低类之间的依赖关系) 代理模式创建Dao接口实现类使用了代理模式优势: 不修改源码的基础上对已有方法增强 五、MyBatis 底层原理及其自定义分析六、基于代理 DAO 实现 CRUD 操作七、MyBatis 的参数深入八、MyBatis 的输出结果封装九、SqlMapConfig.xml 配置文件十、MyBatis 连接池与事务深入十一、MyBatis 的动态 SQL 语句十二、MyBatis 多表查询之一对多十三、MyBatis 多表查询之多对多十四、MyBatis 延迟加载策略十五、MyBatis 缓存Mybatis 一级缓存Mybatis 二级缓存 注意： 针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。 当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。 十六、MyBatis 注解开发 mybatis 的常用注解说明@Insert:实现新增@Update:实现更新@Delete:实现删除@Select:实现查询@Result:实现结果集封装@Results:可以与@Result 一起使用，封装多个结果集@ResultMap:实现引用@Results 定义的封装@One:实现一对一结果集封装@Many:实现一对多结果集封装@SelectProvider: 实现动态 SQL 映射@CacheNamespace:实现注解二级缓存的使用","link":"/2019/08/22/这就是MyBatis/"},{"title":"通用 Mapper","text":"什么是通用 Mapper 为什么要使用通用 Mapper原生Mybatis的痛点：1、mapper.xml文件里有大量的sql，当数据库表字段变动，配置文件就要修改2、需要自己实现sql分页，select * from table where . . . limit 1,3 自己手写分页，除了传参page、pageSize，还需要返回条目总数count。 3、数据库可移植性差：如果项目更换数据库，比如oracle–&gt;mysql，mapper.xml中的 sql要重新写，因为Oracle的PLSQL 和mysql 支持的函数是不同的。4、生成的代码量过大。5、批量操作，批量插入，批量更新，需要自写。 通用 mapper 的使用通用 mapper 与 Spring 集成引入依赖与 Spring 集成实体类映射创建 Mapper 接口","link":"/2019/09/11/通用-Mapper/"},{"title":"面向艺术，面向接口","text":"面向接口编程 应用:removeIf(Predicate) Thread(Runnable) 方法的参数是一个接口自己设计: 以在jdbc 操作数据库，写查询CommonDao.executeQuery(RowMapper,String,Object…); 总结： 方法的参数是接口 在主方法中(如 上面例子中 executeQuery()) 方法里回调接口的方法 在主方法里得到接口方法的返回值，并在主方法里使用它 在主方法中调用接口方法，方法的返回值跟接口的策略子实现有关系(核心) 复用性强扩展性强(每一个子实现 、策略都是扩展)维护性强","link":"/2019/09/10/面向艺术，面向接口/"},{"title":"实现状态管理的技术--Cookie和Session","text":"状态管理（数据管理）为什么需要状态管理什么是状态管理 状态指的是数据 管理指的是多次交互时对数据的修改 会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session 浏览器与服务器请求一次连接一次，每次连接服务器默认都不会保存任何数据通过技术手段，保存某次连接的数据，称为状态管理在多次请求中，使用某次请求的数据，必须使用状态管理技术实现状态管理的技术Cookie和Session 浏览器1（卡（华为手机，充电宝）—&gt; 服务器浏览器2（卡（华为手机，充电宝）—&gt;服务器浏览器3（卡（华为手机，充电宝）—&gt;服务器 浏览器1（id号）—&gt;服务器 （卡1（华为手机，充电宝，id号）浏览器2（id号）—&gt;服务器 （卡2（华为手机，充电宝，id号）浏览器3（id号）—&gt;服务器 （卡3（华为手机，充电宝，id号） CookieCookie:保存在浏览器端的文本文件，实现状态管理的方式之一 工作原理：当服务器创建cookie并发送到浏览器，浏览器再次访问服务器会自动将cookie发送到服务器 概念：客户端会话技术，将数据保存到客户端 快速入门： 使用步骤： 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理 基于响应头set-cookie和请求头cookie实现 cookie的细节 一次可不可以发送多个cookie? 可以 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁 持久化存储： setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值 零：删除cookie信息 cookie能不能存中文？ 在tomcat 8 之前 cookie中不能直接存储中文数据。 需要将中文数据转码—一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题？ 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 如果要共享，则可以将path设置为”/“ 2. 不同的tomcat服务器间cookie共享问题？ * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 案例：记住上一次访问时间 需求： 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 分析： 可以采用Cookie来完成 在服务器中的Servlet判断是否有一个名为lastTime的cookie 有：不是第一次访问 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20 写回Cookie：lastTime=2018年6月10日11:50:01 没有：是第一次访问 响应数据：您好，欢迎您首次访问 写回Cookie：lastTime=2018年6月10日11:50:01 cookie保存在浏览器端的文本文件 cookie存储数据大小有限制，不能超过4K cookie只能存储字符串,不能直接保存中文 cookie的数据不安全 cookie有路径的限制，只能读取同一个应用中的cookie同一个应用中，相同路径和子路径可以读取cookie发送cookie之前，都会cookie.serPath(“/“);为了方便读取 浏览器可以禁止cookieCookie的API： 创建cookieCookie c = new Cookie(“name”,”value”); 设置存活时间void setMaxAge(int seconds);-1:保存到浏览器的缓存中=0:cookie的失效，设置为0，被删除状态 0:保存到浏览器所在的磁盘中 设置路径void setPath(String path);cookie.setPat(“/“); 获取名字String getName(); 获取cookie的值String getValue(); 发送cookieresponse.addCookie(cookie); 获取cookieCookie[] cookies = request.getCookies(); 自动记忆账号和密码 代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@WebServlet(&quot;/cookieTest&quot;)public class CookieTest extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置响应的消息体的数据格式以及编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //1.获取所有Cookie Cookie[] cookies = request.getCookies(); boolean flag = false;//没有cookie为lastTime //2.遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0){ for (Cookie cookie : cookies) { //3.获取cookie的名称 String name = cookie.getName(); //4.判断名称是否是：lastTime if(&quot;lastTime&quot;.equals(name)){ //有该Cookie，不是第一次访问 flag = true;//有lastTime的cookie //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); cookie.setValue(str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); //响应数据 //获取Cookie的value，时间 String value = cookie.getValue(); System.out.println(&quot;解码前：&quot;+value); //URL解码： value = URLDecoder.decode(value,&quot;utf-8&quot;); System.out.println(&quot;解码后：&quot;+value); response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次访问时间为:&quot;+value+&quot;&lt;/h1&gt;&quot;); break; } } } if(cookies == null || cookies.length == 0 || flag == false){ //没有，第一次访问 //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); response.getWriter().write(&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); }} Session1、状态（数据）管理-session 会话管理 获取session对象 request.getSession();如果没有查找到session对象，会创建 request.getSession(true);如果没有查找到session对象，会创建 request.getSession(false);如果没有查找到session对象，返回null void setAttribute(String name,Object value);设置属性 Object getAttribute(String name);获取属性 2、基于session实现的功能 保存登录账号信息，所有包含登录功能的系统都必须实现 每个页面显示登录账号 使用session实现系统登录权限验证 3、session的销毁 超时时间 tomcat默认30分钟没有对session的访问 手动销毁 退出 void invalidate(); 4、Session的特点： Session是服务器维护的一个内存对象 Session可以保存任何数据类型 Session保存数据没有大小限制 Session没有路径的限制 Session数据没有安全隐患 默认，如果浏览器禁止cookie，Session也无法使用 5、URL重写 使用Session,防止浏览器禁止cookie 通过编码的方式，传递session的id response.encodeURL(“adminMain.jsp”); http://localhost:8080/day08_ums/adminMain.jsp;jsessionid=048F1A66235BD825944A8B804F131660","link":"/2019/07/24/Cookie和Session/"},{"title":"JDBC连接数据库基本操作","text":"什么是JDBCJAVA提供访问数据库的技术 JDBC如何实现可以操作所有数据库？JDBC提供了统一数据库的操作方式。JDBC是JAVA语言访问数据库的标准技术。提供了一组操作所有数据库的接口 接口 12345interface MyInterface{ public void save(); public void delete(); public void update();} 面向对象中多态MyInterface obj = new OracleClass();obj.save(); 驱动程序例如将数据添加到mysql数据库中,必须由mysql提供class MySqlClass implements MyInterface{ public void save(){ //将数据保存到mysql数据中 }}例如将数据添加到oracle数据库中，必须由oracle提供class OracleClass implements MyInterface{ public void save(){ //将数据保存到oracle数据中 }} * 1、JDBC的编码步骤 1、 加载驱动程序 2、 创建连接 3、 发送SQL INSERT UPDATE DELETE 4、 如果发送的是SELECT语句，处理结果集 5、 释放资源（关闭连接） 项目中业务功能SQL JDBC 技术标准 一组接口 数据库厂商提供驱动程序 JDBC工具类 CRUD 增删改查 模拟注册和登录，使用Statement,需要SQL与JAVA变量拼接，可能会出现SQL注入 Statement stmt = conn.createStatement(); 2、预处理语句对象 PreparedStatement,预处理语句对象，发送并执行SQL语句，是Statement子接口 优点： * 避免出现SQL注入现象 * 提升同一条SQL语句多次执行的效率 * 提升项目中SQL语句的可读性 用法： * SQL 使用?作为变量的占位符 String sql = “SELECT * FROM ajia_user WHERE username=’”+userName+”‘ AND password=’”+password+”‘“; String sql = “SELECT * FROM ajia_user WHERE username=? AND password=?”; String sql = “INSERT INTO ajia_user(id,username,password,email,phone,created,updated) “ + “VALUES(NULL,?,?,?,?,NOW(),NOW())”; String sql = “SELECT * FROM ajia_user WHERE id=?”; String sql = “SELECT * FROM ajia_user”; * 实例化： PreparedStatement pstmt = conn.prepareStatement(String sql); * 装载占位符(?)值 String userName = sc.nextLine(); String password = sc.nextLine(); String sql = &quot;SELECT * FROM ajia_user WHERE username=? AND password=?&quot;; pstmt.setString(1,userName); pstmt.setString(2,password); pstmt.setDouble(3,sal); pstmt.setTimeStamp(4,t); pstmt.setDate(5,d); pstmt.setObject(6,); * 执行SQL int executeUpdate();执行已经被装载值得SQL语句 ResultSet executeQuery();3、JDBC核心API DriverManager,驱动程序管理器Connection getConnection(String url,String user,String password);获取连接的方法url：jdbc:mysql://ip:3306/tedudbjdbc:mysql,主协议，指定调用哪个驱动程序//ip:3306/tedudb，自协议，指定数据库服务器的ip,数据库服务器软件的端口号，数据库名 Connection,连接对象Statement createStatement();PreparedStatement prepareStatement(String sql); Statement,语句对象int executeUpdate(String sql),执行insert,update,delete语句ResultSet executeQuery(String sql);执行select语句 PreparedStatement,语句处理语句对象void setXxx(int index,Xxx value);装载占位符值int executeUpdate(),执行insert,update,delete语句ResultSet executeQuery();执行select语句 关闭连接conn.close(); 4、JDBC事务处理事务：一组操作的逻辑单元 原子性，一致性，隔离性，持久性（ACID） 删除多条记录，修改多条记录，添加多条记录 Connection接口中： void setAutoCommit(boolean isAuto);设置自动提交方式，JDBC中默认自动提交 boolean getAutoCommit();获取JDBC自动提交方式 void commit();提交事务 void rollback();回滚事务 需求：使用JDBC事务，处理转账 t_account:id,username,balance create table t_account( id int(4) auto_increment primary key, username varchar(20), balance double(12,2) ); insert into t_account values(null,’1001’,100000); insert into t_account values(null,’1002’,100000); 5、批处理 create table t_log( id int(8) auto_increment primary key, title varchar(20), content varchar(50) ); 6、实体类 ajia_user 一组private属性 一组属性的setter和getter 重写父类equals(),hashCode(),toString()方法 一组构造器 实现SeriaLizable接口 7、DAO的设计 设计接口 实现类 接口的作用： * 解耦 多层体系结构应用中 视图层 控制层 业务层 持久层 * 扩展功能 1234567891011121314151617interface Hahaha{ public void f();} class Aaaaa implements Hahaha{ public void f(){ }//JDBC,MyBatis } class B{ public void f1(){ //..... Hahaha a = 反射获取Aaaaa对象; a.f(); } }JdbcUtil类： 123456789101112131415161718192021222324252627282930313233343536373839404142public class JdbcUtil { protected static Connection conn = null; private static String className=&quot;com.mysql.jdbc.Driver&quot;; private static String url=&quot;jdbc:mysql://localhost:3306/students_db?useUnicode=true&amp;characterEncoding=utf-8&quot;; private static String uname=&quot;root&quot;; private static String upasswd=&quot;root&quot;; /** * 获取数据库连接对象 * @return */ public static Connection getConn() { try { Class.forName(className); conn = DriverManager.getConnection(url, uname, upasswd); } catch (ClassNotFoundException e) { System.out.println(&quot;找不到驱动程序类 ，加载驱动失败！&quot;); e.printStackTrace() ; } catch (SQLException e) { System.out.println(&quot;数据库连接失败！&quot;); e.printStackTrace() ; } return conn; } /** * 关闭数据库连接 */ public static void closeConn(Connection conn) { try { if (conn!=null) conn.close(); conn = null; // 置null } catch (SQLException e) { System.out.println(&quot;连接关闭失败！&quot;); e.printStackTrace(); } } //测试// public static void main(String[] args) {// Connection conn = getConn();// System.out.println(conn);// }} 2、BaseDao设计 * 增删改方法的设计 * 查询方法的设计 ResultSet:基于连接的结果集 CacheRowSet:基于缓存的结果集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class BaseDao { Connection conn = null; /** 项目中增删改 * Object...param可变长参数 * 修改方法 */ public void update(String sql,Object...params) throws SQLException{ Connection conn = null; try { conn = JdbcUtil.getConn(); PreparedStatement pstmt = conn.prepareStatement(sql); if(params!=null){ for(int i=0;i&lt;params.length;i++ ){ pstmt.setObject(i+1, params[i]); } } pstmt.executeUpdate(); } finally{ JdbcUtil.closeConn(conn); } } /** * 查询方法 */ public ResultSet find(String sql,Object ...params)throws SQLException{ CachedRowSet crs = null; try { conn = JdbcUtil.getConn(); PreparedStatement pstmt = conn.prepareStatement(sql); if(params!=null){ for(int i=0;i&lt;params.length;i++ ){ pstmt.setObject(i+1, params[i]); } } ResultSet rs = pstmt.executeQuery(); //将基于连接的结果集转存到基于缓存的结果集 crs = new CachedRowSetImpl(); crs.populate(rs); } finally{ JdbcUtil.closeConn(conn); } return crs; } /** * 开启事务 */ public void beginTrans() { try { conn = JdbcUtil.getConn(); conn.setAutoCommit(false); // 关闭自动提交 } catch (SQLException e) { e.printStackTrace(); } } /** * 事务的提交 */ public void commit() { if (conn != null) { try { conn.commit(); } catch (SQLException e) { e.printStackTrace(); } } } /** * 事务的回滚 */ public void rollback() { if (conn != null) { try { conn.rollback(); } catch (SQLException e) { e.printStackTrace(); } } }}","link":"/2019/07/24/JDBC连接数据库基本操作/"},{"title":"JDK1.5 相关特性总结","text":"自动装箱和拆箱:装箱:把基本数据类型的数据装箱成对象类型拆箱:把对象的类型变成基本数据类型 在jdk1.5及以后版本自动装箱和拆箱 int i=10; Integer ii=i; int k=ii 在jdk1.5以前的版本 int i=10; Integer ii=new Integer(10); int k=ii.intValue(); 增强for循环: for(类型 变量名 : 集合或数组){ }可变参数: -用…来定义 -本质就是一个数组 -可以传入任意个参数 -可变参数只能放在方法参数的最后一个位置 静态导入: -用import static 报名.类名.静态属性名或静态的方法名 -可以提高开发效率 -降低了可读性,建议要慎用 枚举:enum当取值为几个(有限)固定的值.可以使用枚举类型枚举是一个数据类型 普通的枚举: 123 public enum RequestMethod{GET,POST,DELETE,PUT } 123456789 public enum Week{Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday } 总结：枚举也可以有方法和属性和构造函数但是构造方法必须是私有的.枚举还可以实现接口,不能进行继承,枚举也可以包含抽象方法所有的枚举的类型都默认继承自java.lang.Enum类 反射(一)什么是反射: java中提供一套类库,通过这样的类库 -运行时动态获取类中的信息 -运行时动态的调用构造函数创建对象 -运行时动态访问(调用)对象的方法和属性 这种运行期间动态获取类中的信息(属性,方法,包,注解等) 以及动态的调用对象的方法和属性的功能称之为java语言的反射机制 通俗的理解,在运行期间对类的内容进行操作 (二)Class类: 要想使用反射,就要获取到类中的所有信息(属性,方法,注解等…) 在java中有一个特殊的类 类型是Class,此类型的对象中存储是某个 类中的信息 比如: Class clazz=Class.forName(“lut.Student”); clazz是一个对象,对象中存储的都是数据,这些数据 都是Student中的属性和方法 属性:访问修饰符 类型 属性名 方法:访问修饰符 返回类型 方法名称(参数列表); Class clazz=Class.forName(&quot;lut.User&quot;); clazz存储的是User类中的信息 Class类是java提供的,这个Class类可表达任意一个类的信息 -每个类加载后(方法区),系统都会为该类生成一个对应的Class 类型的对象,这个对象存储在堆区中,通过该Class对象可以 访问方法区中的类的信息 -一旦获取了某个类Class类型的对象之后,程序员可以写程序调用 Class对象中的api方法,获取Class对象中的类的信息 -所有的基本数据类型有Class对象 Class clazz=int.class; (三)如何获取Class类型的对象-对象.getClass(); 比如: User user=new User(); Class clazz=user.getClass();-类名.class 比如: 有一个类叫做User类 Class clazz=User.class;-Class.forName(“包名.类名”); 比如: Class clazz=Class.forName(“lut.User”); 类的加载分为两个步骤: -把类加载到方法区中,并创建类的Class类型的对象 -返回Class对象,用以上三种获取Class类型的对象 (四)通过Class类型对象获取如下: -Field类:代表的成员变量,即属性 -Method类:代表的是方法 -Constructor类:代表的是构造方法 -Annotation类:代表的是注解 通过上面类的api方法获取数据 -可以获取Field类中的信息,获取类的属性 访问修饰符 属性的类型 属性名称 -可以获取Method类中的信息,获取方法 修饰符 返回类型 方法名(参数列表) -可以获取Constructor中的信息,获取构造函数, 修饰符 类名(参数列表) -可以获取Annotation中的信息,获取注解 注解名称 注解的属性 结论: 在运行期间,通过Class对象调用反射的api 可以反射实例化对象 可以反射访问属性,和反射调用方法 总之,编译期间能写的代码,用反射也能实现 (五)反射的api:-反射的方式创建对象 1.用无参数构造创建对象 Class对象.newInstance();//常用的做法 2.用有参数构造创建对象 Class对象.getConstructor(new Class[]{若干参数的类类型}) .newInstance(构造函数的参数); 比如: //有参数构造 public User(String name,String password){ } Class clazz=User.class; //传统的实例化对象 User user=new User(“zhangsan”,”zs”); //反射的做法: User user=clazz.getConstructor(new Class[]{String.class,String.class}) .newInstance(“张三”,”zs”);-反射方式获取Field中的信息 1.获取当前类以及长辈类的public Field Field[] fields=Class对象.getFields(); 2.获取当前类中的所有的属性Field Field[] fields=Class对象.getDeclaredFields() 3.获取当前类以及长辈类中指定的共有属性 Field field=Class对象.getField(String fieldName); 4.获取当前类中指定的属性 Field field=Class对象.getDeclaredField(String fieldName); 5.通过反射设定Field属性 Field对象.set(Object obj,Object value); 如果Field是私有的 必须先执行:Field对象.setAccessable(true);//设置属性可以访问 6.通过反射获取Field的值 Object value=Field对象.get(object); 如果Field是私有的 必须先执行:Field对象.setAccessable(true);//设置属性可以访问-反射方式获取Method方法信息 1.获取当前类以及长辈类的public Method Method[] methods=Class对象.getMethods(); 2.获取当前类中的所有的属性Field Method[] methods=Class对象.getDeclaredMethods() 3.获取当前类以及长辈类中指定的共有属性 Method method=Class对象.getMethod(String methodName,new Class[]{方法参数类型}); 4.获取当前类中指定的属性 Method method=Class对象.getDeclaredMethod(String methodName,new Class[]{方法参数类型}); 5.通过反射动态调用Method Object returnValue =Method对象.invoke(Object obj,object…args); 解析: 就是通过obj这个对象,调用Method对象确定的方法,给这个方法传递的参数是args Method对象对应的方法放回值returnValue; -反射获取Constructor构造函数 -具体查看api文档-反射获取注解Annotation -具体查看api文档 (六)在哪些地方使用反射,反射的应用场景 -用反射实现jdbc的通用查询和通用更新 -用反射解析注解 -单元测设,就是用反射实现的 -常见的框架,spring框架,apringmvc框架等,都是用反射实现的 -EL表达式 等… 反射的优点: 大幅度提高开发效率,框架就是反射实现的,框架可以大大提高开发效率反射的缺点: 反射执行效率比非反射的方式执行效率低 反射可以暴露类中的所有细节,突破了封装. 内省:就是自查的意思,本质就是反射,利用反射自省类中的属性和方法和其他 自省的方式有两种 方式一: jdk(jre)中自带的一套自省的类库,类库包含的是api方法 侧重:属性和属性的值,属性所对应的getter和setter方法 方式二: apache基金会提供一套公有的自省类库CommonsBeanUtils.jar 他能够处理属性和属性的值和对应的getter和setter 还可以处理普通的方法 总结: 1.能用Commons-Beanutils就用此工具类 2.其次用java的原生的内省Introspector工具类 3.最后用java的原生的反射api Class Field Method Constructor Annotation 原生反射api是最灵活的 要开发快选择1方式 要灵活选择3方式 注解: 注解应用场景很广泛,将来是一个趋势 他可以提高开发效率,但是执行效率堪忧,因为其底层解析注解是用反射解析的 用注解可以替换xml配置和属性文件 注解是一个标识,注解所代表的功能一定要用反射来实现 这些反射的代码,用于解析(寻找注解,获取注解的属性值) 然后根据设定的属性值,来决定是否执行一些业务功能 (一)使用注解有三个步骤: 1.用户定义注解 创建注解 2.把注解应用到对应的目标上 把注解放什么地方(包,类,属性,方法,方法参数等) 3.用反射的代码来确定是否有注解和注解属性值, 根据是否有注解以及注解的值做相应的功能 (二)如何定义注解:程序员创建注解 123456789101112//设定MyAnnotation注应用在什么位置上@Target(value={ElementType.METHOD})//指定注解的保留策略,source级别 class级别 runtime级别@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation { //注解的value属性 public String value(); //注解的name属性,且有默认值abc public String name() default &quot;abc&quot;; //注解的colors属性,且是一个数组,默认值为red和blue public String[] colors() default {&quot;red&quot;,&quot;blue&quot;};} (三)元注解/源注解 @Target和 @Retention和@Override等…都是jdk自带的注解 1.@Target(value={ElementType.Method,…}) 指定要修饰在什么样的目标上(包,注解,类/接口,方法,属性,参数等…) value取值是一个枚举类型的数据 ElementType: ANNOTATION 注解 METHOD 方法 FIELD 属性 CONSTRUCTOR 构造 TYPE 类/接口 PARAMETER 方法的参数上 等… 2.@Retention(RetentionPolicy.RUNTIME) 注解的保留策略 .java--.class--&gt;jvm执行.class SOURCE:源代码级别,Source修饰的注解是给编译看的 编译器把源代码编译完毕后,在class文件中就没有注解 CLASSS:类级别,Class修饰的注解给类加载器看的 在类加载的时候可以做一系列的引导操作, 在编译器编译完毕后注解存在,在类加载加载之后 就要丢弃注解 RUNTIME:运行时级别,给JVM看的,在程序运行的过程中做相关的操作 可以在jvm中借助反射api解析注解(四)注解中的属性详解: a.注解定义属性和接口定义的方法类似,缺省默认public public 类型 属性名称(); b.定义属性是,如果没有使用default指定默认值 则在使用注解,必须给属性赋值 如果带有默认值,是在使用注解的时候给属性赋值为新值 也可以使用默认值 c.注解中的属性类型必须遵守如下要求 可以是八种基本数据类型,枚举类型,Class类型,String类型, 以及上面类型的一维数组 d.在给数组赋值的时候,如果数组只有一个值就不用写{} e.有一个极特殊的属性value 如果只为该属性赋值,value=值 但是如果注解中只有value这一个属性,那么value可以省略 (五)把注解应用到目标 在对应的目标上写上注解 123456789101112 @MyAnnotation(value=&quot;xx&quot;,name=&quot;yy&quot;,colors={&quot;pink&quot;,&quot;green&quot;,&quot;gay&quot;})public class Demo1 { private String str; @MyAnnotation(value=&quot;aa&quot;,name=&quot;bb&quot;) public void method1(String name){ } public void method2(){ }} (六)写反射代码来解析注解: a.解析类上的注解 b.解析方法上的注解 泛型:(一) 一种参数化的类型 //非泛型的写法,不是参数化得类型 ArrayList list0=new ArrayList(); list0.add(“abc”); list0.add(10); //泛型的标准的写法,标准参数化的类型, 参数化类型指的是可以任意类型 ArrayList list1=new ArrayList(); list1.add(“abc”); list1.add(“aaa”); //泛型的写法,但不推荐 ArrayList list2=new ArrayList(); list2.add(“abc”); list2.add(“aaa”); list2.add(10);//语法是可以通过的 //泛型的写法,但不推荐 ArrayList list3=new ArrayList(); list3.add(“abc”); list3.add(“aaa”); //list3.add(10);//语法是错误的 //下列的写法是错误的,编译报错,泛型要求两端的类型必须一致 //ArrayList&lt;Object&gt; list4=new ArrayList&lt;String&gt;();(二)自定义泛型 类上的泛型,泛型类 1、泛型类一定要先定义,后使用,在类的名字后面定义泛型的类型2、泛型的类型一定要是引用数据类型,不能是基本数据类型3、 定义在类上,在类的内部使用,在整个类范围内类型是一致的4、类上的泛型的具体类型需要在创建类的对象的时候指定泛型具体类5、如果在使用类上泛型时不指定泛型的具体类型,默认的具体类型为泛型的上边界 方法上的泛型,泛型方法 泛型要先定义后使用,在返回类型之前定义,通常用大写字母 来定义一个泛型方法,可以定义多个,且定义在方法上,在方法的内部 使用,方法上泛型,在方法调用的时候自动推断出具体的类型, 无论何时,尽量使用泛型方法,因为泛型方法作用域小,只局限 于方法内部 T :类型type E :元素element K :关键字key V :值 value … 比如: 123 public &lt;T,E&gt; T save(T t,E e){ return t;} &lt;T,E&gt;就是标记,标记此方法是一个泛型方法放在修饰符和返回 类型之间,可以放置多个符号,说明有多个参数化类型 (三)泛型的上边界: 泛型所取得类型是上边界或上边界类型的子孙类型 如果不指定泛型默认的上边界是Object (四)泛型擦除: 泛型编译期间起作用,真正执行期间,泛型已经被擦除了,在编译阶段,编译器会将所有使用泛型的地方替换为泛型的上边界,并在必要的时候增加上必须的类型转换和类型检查，所以在执行期间没有泛型的概念了。泛型在编译期间就被擦除掉了.此过程叫做泛型的擦除 (五)集合与泛型 在 &lt;&lt;Easy Coding&gt;&gt; 一书中是这样解释的： 1、List、List、List&lt;?&gt;的区别 2、&lt;? extends T&gt; 和 &lt;? super T&gt; 的使用场景 &lt;? extends T&gt; 是Get First,适用于消费集合元素为主的场景 可以赋值给任何T及T子类的集合，上界为T 取出来的数据带有泛型限制，向上强制转型为 T ,null 可以表示任何类型，除 null 外，任何元素都不得添加进 &lt;? extends T&gt; 集合内 &lt;? super T&gt; 是Put First ,适用于生产集合元素为主的场景 可以赋值给任何T及T父类的集合，下界为T 只能往里放数据，而在取数据时不知道该数据具体属于谁，相当于泛型丢失extends 的场景是 put 功能受限，而 supper 的场景是 get 功能受限。 * 书中所举例子，以加菲猫、猫、动物为例，说明extends 和 super 的详细语法差异,源代码如下： 12345678910111213141516//用动物的猫科与加菲猫的继承关系说明 extends 与 super 在集合中的意义public class AnimalCatCarfield{ public static void main (String[] args){ //第1段：声明三个依次继承的类的集合：Object&gt;动物&gt;猫&gt;加菲猫 List&lt;Animal&gt; animal = new ArrayList&lt;&gt;(Animal); List&lt;Cat&gt; cat = new ArrayList&lt;Cat&gt;(); List&lt;Garfield&gt; garfield = new ArrayList&lt;Garfield&gt;(); animal.add(new Animal()); cat.add(new Cat()); garfield.add(new Garfield()); //第2段：测试赋值操作 //下行编译出错。只能赋值 Cat 或 Cat 子类集合 }}","link":"/2019/09/06/JDK1-5-相关特性总结/"},{"title":"Java基础面试总结(三)","text":"1. 谈谈对象的访问定位对象创建起来之后，就会在虚拟机栈中维护一个本地变量表，用于存储基础类型和基础类型的值，引用类型与引用类型的值。其中引用类型的值就是堆中对象地址。如何引用堆中地址有两种方式： 句柄：在堆中维护一个句柄池，句柄中包含了对象地址，当对象改变的时候，只需改变句柄，不需要改变栈中本地变量表的引用 直接指针：对象的地址直接存储在栈中，这样做的好处就是访问速度变快（Hotspot采用该方式） 2. JVM将内存主要划分为哪五部分方法区、虚拟机栈、本地方法栈、堆、程序计数器。 3. String的intern()函数作用这个要分版本来回答： 如果是JDK6，如果字符串产量池先前已经创建该对象，则返回引用；否则将其添加到字符串常量池并返回引用。 如果是JDK6+，若字符串常量池有则返回引用，如果池中没有堆中有，则将堆中的引用添加到池中(注意是引用),然后返回引用；若池中也没有，则在池中创建并返回引用。 4. 本地方法栈和虚拟机栈区别本地方法栈与虚拟机栈所发挥的作用很相似，他们的区别在于虚拟机栈为执行Java代码方法服务，而本地方法栈是为Native方法服务。 5. 分配堆内存指令1-Xms -Xmx 前者是堆的初始值，后者是堆能达到的最大值。 6. 程序计数器作用记录当前线程锁执行的字节码的行号。 程序计数器是一块较小的内存空间。 处于线程独占区。 执行java方法时，它记录正在执行的虚拟机字节码指令地址。执行native方法，它的值为undefined 该区域是唯一一个没有规定任何OutOfMemoryError的区域 7. 如何将字符串反转？ 通过 charAt(int index)返回char值进行字符串拼接 调用StringBuffer中的reverse方法 8. Collection 和 Collections 有什么区别？ Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 9. 在 Queue 中 poll()和 remove()有什么区别？ queue的增加元素方法add和offer的区别在于，add方法在队列满的情况下将选择抛异常的方法来表示队列已经满了，而offer方法通过返回false表示队列已经满了；在有限队列的情况，使用offer方法优于add方法； remove方法和poll方法都是删除队列的头元素，remove方法在队列为空的情况下将抛异常，而poll方法将返回null； element和peek方法都是返回队列的头元素，但是不删除头元素，区别在与element方法在队列为空的情况下，将抛异常，而peek方法将返回null. 10. 什么是迭代器Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包括了可以返回迭代器实例的迭代方法。迭代器可以在迭代过程中删除底层集合的元素，但是不可以直接调用集合的remove(Object obj)删除，可以通过迭代器的remove()方法删除 11. 迭代器的优点如果用的是for循环，就用集合自带的remove(),而这样就改变了集合的Size（）循环的时候会出错。但如果把集合放入迭代器，既iterator迭代可以遍历并选择集合中的每个对象而不改变集合的结构，而把集合放入迭代器，用迭代器的remove（）就不会出现问题 12. Java集合类中的Iterator和ListIterator的区别对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面： iterator()方法在set和list接口中都有定义，但是ListIterator()仅存在于list接口中（或实现类中）； ListIterator有add()方法，可以向List中添加对象，而Iterator不能 ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。 ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。 13. 怎么确保一个集合不能被修改？ Java中提供final关键字，对基本类型进行修饰，当第一次初始化后，该变量就不可被修改 Collections工具类中的UnmodifiableList(不可修改的List、Map、Set等) 14. 并行和并发区别并发的关键是你有处理多个任务的能力，不一定要同时。 15. 说一下你对Daemon线程(守护线程)的理解？它有什么意义？一般应用于什么样的场景？所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因 此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。 守护线程和用户线程的没啥本质的区别：唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。 16. sleep() 和 wait() 有什么区别？ 对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。 而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。 17. notify 和 notifyAll 区别notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。换言之，如果只有一个线程在等待一个信号灯，notify和notifyAll都会通知到这个线程。但如果多个线程在等待这个信号灯，那么notify只会通知到其中一个，而其它线程并不会收到任何通知，而notifyAll会唤醒所有等待中的线程。 18. 线程中start()和run()的区别 每个线程都有要执行的任务。线程的任务处理逻辑可以在Tread类的run实例方法中直接实现或通过该方法进行调用，因此run()相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。 而start()的作用是启动相应的线程。启动一个线程实际是请求Java虚拟机运行相应的线程，而这个线程何时能够运行是由线程调度器决定的。start()调用结束并不表示相应线程已经开始运行，这个线程可能稍后运行，也可能永远也不会运行。 19. 线程池的五种状态线程池的5种状态：Running、ShutDown、Stop、Tidying、Terminated。 20. 线程池中 submit()和 execute()方法有什么区别？ execute(Runnable x) 没有返回值。可以执行任务，但无法判断任务是否成功完成。——实现Runnable接口 submit(Runnable x) 返回一个future。可以用这个future来判断任务是否成功完成。——实现Callable接口","link":"/2019/07/27/Java基础面试总结-三/"},{"title":"Java基础面试总结(一)","text":"1. 简单说下什么是跨平台 术语：操作系统指令集、屏蔽系统之间的差异 由于各种操作系统所支持的指令集不是完全一致，所以在操作系统之上加个虚拟机可以来提供统一接口，屏蔽系统之间的差异。 2. Java有几种基本数据类型 有八种基本数据类型。 数据类型 字节 默认值 byte 1 0 short 2 0 int 4 0 long 8 0 float 4 0.0f double 8 0.0d char 2 ‘\\u0000’ boolean 4 false 各自占用几字节也记一下。 Java的默认数据类型1、 3. 面向对象特征面向对象的编程语言有封装、继承 、抽象、多态等4个主要的特征。 封装： 把描述一个对象的属性和行为的代码封装在一个模块中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。 抽象： 把现实生活中的对象抽象为类。分为过程抽象和数据抽象 数据抽象 –&gt;鸟有翅膀,羽毛等(类的属性) 过程抽象 –&gt;鸟会飞,会叫(类的方法) 继承：子类继承父类的特征和行为。子类可以有父类的方法，属性（非private）。子类也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高代码之间的耦合性。 多态： 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定(比如：向上转型，只有运行才能确定其对象属性)。方法覆盖和重载体现了多态性。 4. 为什么要有包装类型 术语：让基本类型也具有对象的特征 基本类型 包装器类型 boolean Boolean char Character int Integer byte Byte short Short long Long float Float double Double 为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型）因为容器都是装object的，这是就需要这些基本类型的包装器类了。 自动装箱：new Integer(6);，底层调用:Integer.valueOf(6) 自动拆箱: int i = new Integer(6);，底层调用i.intValue();方法实现。 123Integer i = 6;Integer j = 6;System.out.println(i==j); 答案在下面这段代码中找： 12345public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);} 二者的区别： 声明方式不同：基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间； 存储方式及位置不同：基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用； 初始值不同：基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null； 使用方式不同：基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。 5.==和equals区别 ==较的是两个引用在内存中指向的是不是同一对象（即同一内存空间），也就是说在内存空间中的存储位置是否一致。如果两个对象的引用相同时（指向同一对象时），“==”操作符返回true，否则返回flase。 equals用来比较某些特征是否一样。我们平时用的String类等的equals方法都是重写后的，实现比较两个对象的内容是否相等。 我们来看看String重写的equals方法： 它不止判断了内存地址，还增加了字符串是否相同的比较。 1234567891011121314151617181920212223242526public boolean equals(Object anObject) { //判断内存地址是否相同 if (this == anObject) { return true; } // 判断参数类型是否是String类型 if (anObject instanceof String) { // 强转 String anotherString = (String)anObject; int n = value.length; // 判断两个字符串长度是否相等 if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; // 一一比较 字符是否相同 while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false;} 6. String、StringBuffer和StringBuilder区别 java中String、StringBuffer、StringBuilder是编程中经常使用的字符串类，他们之间的区别也是经常在面试中会问到的问题。现在总结一下，看看他们的不同与相同。 1. 数据可变和不可变 String底层使用一个不可变的字符数组private final char value[];所以它内容不可变。 StringBuffer和StringBuilder都继承了AbstractStringBuilder底层使用的是可变字符数组：char[] value; 2. 线程安全 StringBuilder是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低。 通过他们的append()方法来看，StringBuffer是有同步锁，而StringBuilder没有： 123456@Overridepublic synchronized StringBuffer append(Object obj) { toStringCache = null; super.append(String.valueOf(obj)); return this;} 12345@Overridepublic StringBuilder append(String str) { super.append(str); return this;} 3. 相同点StringBuilder与StringBuffer有公共父类AbstractStringBuilder。 最后，操作可变字符串速度：StringBuilder &gt; StringBuffer &gt; String，这个答案就显得不足为奇了。 7. 讲一下Java中的集合 Collection下：List系(有序、元素允许重复)和Set系(无序、元素不重复) set根据equals和hashcode判断，一个对象要存储在Set中，必须重写equals和hashCode方法 Map下：HashMap线程不同步；ConcurrentMap线程同步 Collection系列和Map系列：Map是对Collection的补充，两个没什么关系 8. ArrayList和LinkedList区别？ 之前专门有写过ArrayList和LinkedList源码的文章。 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 9. ConcurrentModificationException异常出现的原因123456789101112public class Test { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer integer = iterator.next(); if(integer==2) list.remove(integer); } }} 执行上段代码是有问题的，会抛出ConcurrentModificationException异常。 原因：调用list.remove()方法导致modCount和expectedModCount的值不一致。 1234final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException();} 解决办法：在迭代器中如果要删除元素的话，需要调用Iterator类的remove方法。 123456789101112public class Test { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer integer = iterator.next(); if(integer==2) iterator.remove(); //注意这个地方 } }} 10. HashMap和HashTable、ConcurrentHashMap区别？相同点: HashMap和Hashtable都实现了Map接口 都可以存储key-value数据 不同点： HashMap可以把null作为key或value，HashTable不可以 HashMap线程不安全，效率高。HashTable线程安全，效率低。 HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。 什么是fail-fast?就是最快的时间能把错误抛出而不是让程序执行。 10.2 如何保证线程安全又效率高？Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 ConcurrentHashMap将整个Map分为N个segment(类似HashTable)，可以提供相同的线程安全，但是效率提升N倍，默认N为16。 10.3 我们能否让HashMap同步？HashMap可以通过下面的语句进行同步：Map m = Collections.synchronizeMap(hashMap); 11. 拷贝文件的工具类使用字节流还是字符流 答案：字节流 11.1 什么是字节流，什么是字符流？字节流：传递的是字节（二进制）， 字符流：传递的是字符 11.2 答案我们并不支持下载的文件有没有包含字节流(图片、影像、音源)，所以考虑到通用性，我们会用字节流。 12. 线程创建方式 这个之前自己做过总结，也算比较全面。 方法一：继承Thread类，作为线程对象存在（继承Thread对象）12345678910111213141516171819202122232425262728293031public class CreatThreadDemo1 extends Thread{ /** * 构造方法： 继承父类方法的Thread(String name)；方法 * @param name */ public CreatThreadDemo1(String name){ super(name); } @Override public void run() { while (!interrupted()){ System.out.println(getName()+&quot;线程执行了...&quot;); try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { CreatThreadDemo1 d1 = new CreatThreadDemo1(&quot;first&quot;); CreatThreadDemo1 d2 = new CreatThreadDemo1(&quot;second&quot;); d1.start(); d2.start(); d1.interrupt(); //中断第一个线程 }} 常规方法，不多做介绍了，interrupted方法，是来判断该线程是否被中断。（终止线程不允许用stop方法，该方法不会施放占用的资源。所以我们在设计程序的时候，要按照中断线程的思维去设计，就像上面的代码一样）。 让线程等待的方法 Thread.sleep(200); //线程休息2ms Object.wait()； //让线程进入等待，直到调用Object的notify或者notifyAll时，线程停止休眠 方法二：实现runnable接口，作为线程任务存在123456789101112131415public class CreatThreadDemo2 implements Runnable { @Override public void run() { while (true){ System.out.println(&quot;线程执行了...&quot;); } } public static void main(String[] args) { //将线程任务传给线程对象 Thread thread = new Thread(new CreatThreadDemo2()); //启动线程 thread.start(); }} Runnable 只是来修饰线程所执行的任务，它不是一个线程对象。想要启动Runnable对象，必须将它放到一个线程对象里。 方法三：匿名内部类创建线程对象12345678910111213141516171819202122232425262728293031public class CreatThreadDemo3 extends Thread{ public static void main(String[] args) { //创建无参线程对象 new Thread(){ @Override public void run() { System.out.println(&quot;线程执行了...&quot;); } }.start(); //创建带线程任务的线程对象 new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;线程执行了...&quot;); } }).start(); //创建带线程任务并且重写run方法的线程对象 new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;runnable run 线程执行了...&quot;); } }){ @Override public void run() { System.out.println(&quot;override run 线程执行了...&quot;); } }.start(); }} 创建带线程任务并且重写run方法的线程对象中，为什么只运行了Thread的run方法。我们看看Thread类的源码，，我们可以看到Thread实现了Runnable接口，而Runnable接口里有一个run方法。所以，我们最终调用的重写的方法应该是Thread类的run方法。而不是Runnable接口的run方法。 方法四：创建带返回值的线程12345678910111213141516171819202122232425public class CreatThreadDemo4 implements Callable { public static void main(String[] args) throws ExecutionException, InterruptedException { CreatThreadDemo4 demo4 = new CreatThreadDemo4(); FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(demo4); //FutureTask最终实现的是runnable接口 Thread thread = new Thread(task); thread.start(); System.out.println(&quot;我可以在这里做点别的业务逻辑...因为FutureTask是提前完成任务&quot;); //拿出线程执行的返回值 Integer result = task.get(); System.out.println(&quot;线程中运算的结果为:&quot;+result); } //重写Callable接口的call方法 @Override public Object call() throws Exception { int result = 1; System.out.println(&quot;业务逻辑计算中...&quot;); Thread.sleep(3000); return result; }} Callable接口介绍： 123456789public interface Callable&lt;V&gt; { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;} 返回指定泛型的call方法。然后调用FutureTask对象的get方法得道call方法的返回值。 方法五：定时器Timer1234567891011121314public class CreatThreadDemo5 { public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(&quot;定时器线程执行了...&quot;); } },0,1000); //延迟0，周期1s }} 方法六：线程池创建线程123456789101112131415161718192021public class CreatThreadDemo6 { public static void main(String[] args) { //创建一个具有10个线程的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); long threadpoolUseTime = System.currentTimeMillis(); for (int i = 0;i&lt;10;i++){ threadPool.execute(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName()+&quot;线程执行了...&quot;); } }); } long threadpoolUseTime1 = System.currentTimeMillis(); System.out.println(&quot;多线程用时&quot;+(threadpoolUseTime1-threadpoolUseTime)); //销毁线程池 threadPool.shutdown(); threadpoolUseTime = System.currentTimeMillis(); }} 方法七：利用java8新特性 stream 实现并发lambda表达式不懂的，可以看看我的java8新特性文章： java8-lambda：https://www.jianshu.com/p/3a08dc78a05f java8-stream：https://www.jianshu.com/p/ea16d6712a00 12345678910public class CreatThreadDemo7 { public static void main(String[] args) { List&lt;Integer&gt; values = Arrays.asList(10,20,30,40); //parallel 平行的，并行的 int result = values.parallelStream().mapToInt(p -&gt; p*2).sum(); System.out.println(result); //怎么证明它是并发处理呢 values.parallelStream().forEach(p-&gt; System.out.println(p)); }} 1234520040102030 怎么证明它是并发处理呢,他们并不是按照顺序输出的 。","link":"/2019/07/26/Java基础面试总结-一/"},{"title":"ArrayList源码分析","text":"简介 ArrayList是我们开发中非常常用的数据存储容器之一，其底层是数组实现的，我们可以在集合中存储任意类型的数据，ArrayList是线程不安全的，非常适合用于对元素进行查找，效率非常高。 线程安全性对ArrayList的操作一般分为两个步骤，改变位置(size)和操作元素(e)。所以这个过程在多线程的环境下是不能保证具有原子性的，因此ArrayList在多线程的环境下是线程不安全的。 源码分析1. 属性分析1234567891011121314151617181920212223242526272829303132/** * 默认初始化容量 */private static final int DEFAULT_CAPACITY = 10;/** * 如果自定义容量为0，则会默认用它来初始化ArrayList。或者用于空数组替换。 */private static final Object[] EMPTY_ELEMENTDATA = {};/** * 如果没有自定义容量，则会使用它来初始化ArrayList。或者用于空数组比对。 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};/** * 这就是ArrayList底层用到的数组 * 非私有，以简化嵌套类访问 * transient 在已经实现序列化的类中，不允许某变量序列化 */transient Object[] elementData;/** * 实际ArrayList集合大小 */private int size;/** * 可分配的最大容量 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 扩展：什么是序列化序列化是指：将对象转换成以字节序列的形式来表示，以便用于持久化和传输。 实现方法：实现Serializable接口。 然后用的时候拿出来进行反序列化即可又变成Java对象。 transient关键字解析 Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化。 有了transient关键字声明，则这个变量不会参与序列化操作，即使所在类实现了Serializable接口，反序列化后该变量为空值。 那么问题来了：ArrayList中数组声明：transient Object[] elementData;，事实上我们使用ArrayList在网络传输用的很正常，并没有出现空值。 原来：ArrayList在序列化的时候会调用writeObject()方法，将size和element写入ObjectOutputStream；反序列化时调用readObject()，从ObjectInputStream获取size和element，再恢复到elementData。 那为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？ 原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。 2. 构造方法分析根据initialCapacity 初始化一个空数组，如果值为0，则初始化一个空数组: 12345678910111213/** * 根据initialCapacity 初始化一个空数组 */public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); }} 不带参数初始化，默认容量为10: 123456/** * 不带参数初始化，默认容量为10 */public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;} 通过集合做参数的形式初始化：如果集合为空，则初始化为空数组： 1234567891011121314/** * 通过集合做参数的形式初始化 */public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; }} 3. 主干方法trimToSize()方法： 用来最小化实例存储，将容器大小调整为当前元素所占用的容量大小。 1234567891011/** * 这个方法用来最小化实例存储。 */public void trimToSize() { modCount++; if (size &lt; elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); }} clone()方法 用来克隆出一个新数组。 1234567891011public Object clone() { try { ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(e); }} 通过调用Object的clone()方法来得到一个新的ArrayList对象，然后将elementData复制给该对象并返回。 add(E e)方法 在数组末尾添加元素 12345678/** * 在数组末尾添加元素 */public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;} 看到它首先调用了ensureCapacityInternal()方法.注意参数是size+1,这是个面试考点。 123private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));} 这个方法里又嵌套调用了两个方法:计算容量+确保容量 计算容量：如果elementData是空，则返回默认容量10和size+1的最大值，否则返回size+1 123456private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity;} 计算完容量后，进行确保容量可用：(modCount不用理它，它用来计算修改次数) 如果size+1 &gt; elementData.length证明数组已经放满，则增加容量，调用grow()。 1234567private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);} 增加容量：默认1.5倍扩容。 获取当前数组长度=&gt;oldCapacity oldCapacity&gt;&gt;1 表示将oldCapacity右移一位(位运算)，相当于除2。再加上1，相当于新容量扩容1.5倍。 如果newCapacity&lt;minCapacity，则newCapacity = minCapacity。看例子更明白一点：假设size为1,则minCapacity=size+1=2,而elementData.length=1,newCapacity=1+1&gt;&gt;1=1,1&lt;2所以如果不处理该情况，扩容将不能正确完成。 如果新容量比最大值还要大，则将新容量赋值为VM要求最大值。 将elementData拷贝到一个新的容量中。 1234567891011private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);} size+1的问题 好了，那到这里可以说一下为什么要size+1。 size+1代表的含义是： 如果集合添加元素成功后，集合中的实际元素个数。 为了确保扩容不会出现错误。 假如不加一处理，如果默认size是0，则0+0&gt;&gt;1还是0。如果size是1，则1+1&gt;&gt;1还是1。有人问:不是默认容量大小是10吗?事实上，jdk1.8版本以后，ArrayList的扩容放在add()方法中。之前放在构造方法中。我用的是1.8版本，所以默认ArrayList arrayList = new ArrayList();后，size应该是0.所以,size+1对扩容来讲很必要. 123456public static void main(String[] args) { ArrayList arrayList = new ArrayList(); System.out.println(arrayList.size());}输出:0 事实上上面的代码是证明不了容量大小的，因为size只会在调用add()方法时才会自增。有办法的小伙伴可以在评论区大显神通。 add(int index, E element)方法123456789public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;} rangeCheckForAdd()是越界异常检测方法。ensureCapacityInternal()之前有讲，着重说一下System.arrayCopy方法： 1234567public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)代码解释: Object src : 原数组 int srcPos : 从元数据的起始位置开始 Object dest : 目标数组 int destPos : 目标数组的开始起始位置 int length : 要copy的数组的长度 示例：size为6，我们调用add(2,element)方法，则会从index=2+1=3的位置开始，将数组元素替换为从index起始位置为index=2，长度为6-2=4的数据。 异常处理： 1234private void rangeCheckForAdd(int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));} set(int index,E element)方法1234567891011public E set(int index, E element) { rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;}E elementData(int index) { return (E) elementData[index];} 逻辑很简单，覆盖旧值并返回。 indexOf(Object o)方法 根据Object对象获取数组中的索引值。 123456789101112public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1;} 如果o为空，则返回数组中第一个为空的索引；不为空也类似。 注意：通过源码可以看到，该方法是允许传空值进来的。 get(int index)方法 返回指定下标处的元素的值。 12345public E get(int index) { rangeCheck(index); return elementData(index);} rangeCheck(index)会检测index值是否合法，如果合法则返回索引对应的值。 remove(int index)方法 删除指定下标的元素。 12345678910111213141516public E remove(int index) { // 检测index是否合法 rangeCheck(index); // 数据结构修改次数 modCount++; E oldValue = elementData(index); // 记住这个算法 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;} 这里又碰到了System.arraycopy()方法，详情请查阅上文。 大概思路：将该元素后面的元素前移，最后一个元素置空。 ArrayList优缺点优点： 因为其底层是数组，所以修改和查询效率高。 可自动扩容(1.5倍)。 缺点： 插入和删除效率不高。 线程不安全。 那面试手写ArrayList应该就不是问题了。","link":"/2019/07/15/arrayList源码分析/"},{"title":"js 相关知识点总结","text":"关于javascript: 简称js, javascript是嵌入html中在浏览器中运行的脚本语言, js跟java和c没有任何关系,只是语法相似,用来向html页面添加交互行为, 直接嵌入html页面, 由浏览器解释执行代码,不进行预编译 javascript特点: 可以用任何编辑文本的工具编写js代码 由浏览器内置的javascript引擎执行代码 解释执行:事先不编译,逐行执行 基于对象:内置大量的现成的对象 适宜: 客户端的数据计算 客户端的表单验证 浏览器的事件触发 网页特效制作 服务器的异步提交 ajax js的注释: 12单行 //多行 /**/ 注意： js代码区分大小写,大小写敏感所有js语句用分号结束标识符的定义:可以包含字母,数字,下划线,$符号,就是不能用数字开头命名的规范用骆驼(驼峰)命名法 数据类型 原始数据类型(基本数据类型) number: 数字 (整数、小数、NaN) string: 字符串。 boolean: true 和 false null: 一个对象为空的占位符注：用 typeof() 得到的 null 的类型为 Object undefined: 未定义 引用数据类型: 对象 运算符 在 js 中，如果运算数不是运算符所要求的类型，那么 js 引擎会自动的将运算数进行类型转换 其他类型转 number string 转 number: 字面是数字，按照字面值转换。如果字面不是数字，则转为NaN(不是数字的数字类型) boolean 转 number: true 转为 1, false 转为 0eg: true+true=2 其他类型转 boolean number: 0 或 NaN 为假，其他为真 string: 除了空字符串(“”), 其他都是 true null &amp; undefined: 都是 false 对象: 所有对象都是 true 比较运算符: 比较运算符的比较方式： 类型相同，则直接比较 对于字符串，按照字典顺序逐位进行比较，直到得出大小为止 类型不同，先进行类型转换，再进行比较 === 表示 全等于, 在比较之前，先判断类型，如果类型不一样，则直接返回 false 变量的定义使用关键字 var 和不使用 var 使用 var :定义的变量是局部变量 不使用 var :定义的变量是全局变量(即使在方法里面定义) 流程控制语句 在 js 中，switch 语句可以接受任意的原始数据类型 for in JavaScript 对象 Function: 函数(方法)对象 创建： var fun = new Function(形参列表，方法体);该方法了解即可 functioin 方法名称(形参列表){ 方法体} var 方法名 = function(){ 方法体} 推荐后面两种方式 属性 length: 代表形参的个数 特点 方法定义时，形参的类型不用写,返回值类型也不用写 方法是一个对象，如果定义名称相同的方法，(后面定义的)会覆盖之前定义的方法 在 js 中，当进行方法调用时，方法的调用只与方法的名称有关,和参数列表无关 在方法声明中有一个隐藏的内置对象(数组), arguments, 封装所有的实际参数 调用 方法名称(实参);1234567891011121314/*求任意个数的和*/function add(){ var sum = 0; for(var i=0;i&lt;arguments.length;i++){ sum += arguments[i]; } return sum;}//调用function getResult(){ var sum = add(1,2,3); console.log(sum);} Array: 创建 var arr = new Array(元素列表); var arr = new Array(默认长度); var arr = [元素列表]; 常用方法 join(参数): 将数组中的元素按照指定的分隔符拼接为字符串 push() 向数组的末尾添加一个或更多元素，并返回新的长度 属性 length: 数组的长度。 特点 js 中，数组元素的类型是可变的 js 中，数组的长度是可变的。 Date: 日期对象 创建 var date = new Date(); 常用方法 toLocaleString(): 返回当前 date 对象对应的时间本地字符串格式 getTime(): 获取毫秒值。返回当前日期对象描述的时间到1970年1月1日零点的毫秒值差12345678910function demo(){ var date = new Date(); document.write(date+&quot;&lt;br&gt;&quot;); document.write(date.toLocaleTimeString()+&quot;&lt;br&gt;&quot;); document.write(date.toLocaleDateString()+&quot;&lt;br&gt;&quot;); document.write(date.getTime()+&quot;&lt;br&gt;&quot;); document.write(date.getDay()+&quot;&lt;br&gt;&quot;); document.write(date.toString()+&quot;&lt;br&gt;&quot;);} Math: 数学 创建 Math 对象不用创建，直接使用。Math.方法名(); 常用方法 random(): 返回0~1之间的随机数。含0不含1 属性 PI RegExp: 正则表达式对象 正则表达式: 定义字符串的组成规则 一些特殊含义的单个字符 \\d: 单个数字 \\w: 单个字符 其他 相关量词符号 {m,n}: 表示 m&lt;= 数量 &lt;= n m 如果缺省:{,n}: 表示最多 n 次 n 如果缺省:{m,}: 表示最少 m 次 开始和结束 ^: 开始 $: 结束 其他 正则对象 创建 var reg = new RegExp(“正则表达式”); var reg = /正则表达式/;注意在//之间不加引号 方法 test(参数): 验证指定的字符串是否符合正则定义的规范 Global: 全局对象, Global 中封装的方法不需要对象就可以直接调用。 常用方法: encodeURI(): url 编码 decodeURI(): url 解码 parseInt(): 将字符串转为数字 isNaN(): 判断一个值是不是NaN, NaN参与的==比较 全为 false eval(): eval函数用于计算表达式字符串,或者用于执行字符串中js代码 BOM BOM对象 browser object model浏览器对象模型,用来访问跟浏览器窗口有关的对象在BOM对象有很多的对象,每个对象还有很多属性和方法, 通过这些方法和属性,移动窗口,更改状态栏文本和其他跟窗口操作相关的. window对象: window表示浏览器窗口是所有javascript全局对象,如果不写window,默认从window访问起 window常用的属性: document:在窗口中显示文档树. history:浏览器的窗口的后退和前进 location:窗口文件地址对象. window.location.href=”login.html”; screen:当前屏幕对象 navigator:浏览器的相关信息 window对象常用的方法: alert();弹出式窗口,模态框(当前窗口不关闭,无法操作后面的窗口) confirm();模态框,确认窗口 setTimeOut() setInterval() 周期性函数 clearTimeOut() clearInterval(); DOM DOM对象: Document Object model文档对象模型,用来操作文档定义了访问和操作html文档的标准方法应用程序通过对dom树的操作,来实现和html的交互 dom编程:用 js 做 dom 编程的目的，就是为让 html 页面中的内容局部改变查询: -通过id查询 -通过name查询 -通过标签名查询 -通过表单名查询 根据id查询 document.getElementById(“”); 通过id查询返回元素节点, 在整个html文档中搜索id 只找到第一个id,返回元素 如果id错误,返回null 根据层次查询节点: -parentNode 遵循文档的上下文层次结构,查找单个父节点 比如: var td_ele=document.getElementById(“tdid”); var tr_ele=td_ele.parentNode; var table_ele=td_ele.parentNode.parentNode; -childNodes 遵循文档的上下文层次结构,查找多个子节点 比如:上面的例子 var td_ele=document.getElementById(“tdid”); //获取当前td对象的所有兄弟 var tds_ele=td_ele.parentNode.childNodes; //获取当前td的父亲,和所有叔叔节点 var trs_ele=td_ele.parentNode.parentNode.childNodes; 根据标签名查询节点: getElementsByTagName(“标签名”); 从当前对象往下寻找符合标签名的所有元素对象 返回结果是一个数组 标签名错误,返回长度为0, 比如: var table_ele=document.getElementById(&quot;tblid&quot;); var trs_ele=table_ele.getElementsByTagName(&quot;tr&quot;);根据name属性查询节点 document.getElementsByName(“元素的name属性值”); 注意:不是所有的元素节点都有name属性 根据document.表单名字.表单控间名 docuemnt.forms[数字].表单控件名 创建元素节点: document.createElement(元素节点名); 返回结果是创建的节点对象 创建文本节点: document.createTextNode(“文本信息”); 返回结果是一个文本节点对象 添加新节点: parentNode.appendChild(newNode); 追加newNode节点到父节点的所有子节点的最后. parentNode.insertBefore(newNode,refNode); 把newNode插入到refNode的前面 newNode和refNode是兄弟关系 删除节点:node.removeChild(childNode) 删除node节点下的childNode的节点对象 定位节点: parentNode.firstChild;第一个子节点 parentNode.lastChild;最后一个子节点 事件","link":"/2019/09/16/js-相关知识点总结/"},{"title":"Mysql在项目中的基本操作","text":"Mysql 数据库：关系型数据库非关系型数据库，NOSQL数据库关系型数据库：Oracle Mysql(SUN Java) DB2(IBM) DDL(数据定义语言): CREATE、 DROP、 ALTER 表的设计范式 第一范式强调数据表的原子性 表中字段的值是不能拆分的 第二范式消除了非主属性对于码的部分函数依赖，即完全依赖表中非主字段必须完全依赖主键字段 第三范式消除了非主属性对于码的传递函数依赖依赖不能传递 避免表中数据冗余 创建表语法:create table 表名( 字段名1 数据类型(长度) 约束, 字段名1 数据类型(长度), 字段名1 数据类型(长度)); 表名，字段名 只能由字母，数字，下划线，$ 组成 不能由数字开头 不能是SQL中的关键字 删除表drop table 表名; MYSQL常用的数据类型 int(6) double(10,2) //浮点型，加小数10位，小数部分占2位 varchar:可变长字符类型 //name varchar(10) Jack char:不可变长字符类型 //idcode char(18) 210 date:日期类型 timestamp:时间戳类型 约束约束是用来完备性和正确性 主键约束 开发中，通常都会为一张表设计一个字段，该字段用来唯一标识记录。将该字段添加主键约束，添加了主键约束的字段，称为主键字段。添加主键字段防止出现张冠李戴的现象。主键约束的特点：非空、唯一一个表只能有一个主键 外键约束*注意:外键字段必须引用于主键字段被引用的表称为主表，引用的表称为从表外键的三种添加方式(如: 在主表员工表 emp 中给字段 deptno 设置外键,外键为从表 dept 的主键 deptno ) 方式一[ 列名 数据类型() references 外键所属表(该表主键) ] 1234create table emp( ......., deptno int(2) references dept(deptno)); 方式二不在列名后面写，而是在最后表级添加[ foreign key(外键列名) references 外键所属表(该表主键) ] 12345create table emp( ......., deptno int(2), constraint t_emp_dept_fk foreign key(deptno) references dept(deptno)); 方式三前两张方式的局限性：只能先建 才能引入外键可以在创建表时先不添加外键待表建好以后，通过修改表的方式添加外键 123456create table emp( ......., deptno int(2));alter table emp add foreign key(deptno) references dept(deptno); 唯一约束唯一性约束 unique 123456create table emp( ......., email varchar(50) unique, phone varchar(20) unique, ......); 非空约束not null 12345create table emp( ......., password varchar(20) not null, ......); 检查约束check 123......created timestamp,check(created&gt;&apos;2019-1-1&apos;) 设置一个字段默认值 123456drop table if exists t_user;create table t_user( id int() primary key auto_increment, gender char() default &apos;0&apos;, ...... ); 主键约束：primary key,主键字段的值非空唯一 外键约束：foreign key references t1(id);外键字段值引用其他主键字段的值 创建数据库 1create database mydb; 选择数据库 1use mydb; 查看数据库中的表 1show tables; 创建表 Demo 12345678910create table t_user( id int(6) auto_increment primary key, username varchar(20), password varchar(20), email varchar(50), phone varchar(20), type char(1), created timestamp, updated timestamp); 先删除再创建表 12drop table if exists t_user;create table t_user(.....); 查看表结构 1desc 表名; sql 语句中的常用操作细节: 细节操作: 设置主键并让主键自增auto_increment primary keyauto_increment,自动增长，用来生成主键字段的值 mysql 解决乱码：创建数据库时:create database my_db default charset=utf8;创建表设置字符集:creaate table tablename(……)default charset=utf8; mysql 中的时间 date datetime timestamp 1234设置系统当前时间demo:commited date default now(),starttime datetime default now(),paytime timestamp default currene_timestamp(), 根据如下需求创建表,并进行相关操作： 创建部门表和员工表，员工表中有部门号字段为外键字段，引用部门表中部门号字段 部门表字段：部门号，部门名，部门地址 员工表字段：员工号，员工姓名，职位，薪水，入职日期，经理编号，部门号 部门表 12345create table dept( deptno int(2) auto_increment primary key, dname varchar(30), loc varchar(50) ); 员工表 1234567891011create table emp( empno int(4) auto_increment primary key, ename varchar(20), job varchar(20), sal double(10,2), hiredate date, mgr int(4), deptno int(2), foreign key(mgr) references emp1(empno), foreign key(deptno) references dept1(deptno)); 创建表设置字符集 12345678910111213141516create table dept( deptno int(2) auto_increment primary key, dname varchar(30), loc varchar(50) ) default charset=utf8; create table emp( empno int(4) auto_increment primary key, ename varchar(20), job varchar(20), sal double(10,2), hiredate date, mgr int(4), deptno int(2))default charset=utf8; alter table emp add foreign key(mgr) references emp(empno); alter table emp add foreign key(deptno) references dept(deptno); 表的管理DML（INSERT UPDATE DELETE SELECT） INSERT:添加数据 需求：创建管理员账号 1insert into t_user values(NULL,&apos;admin&apos;,&apos;admin&apos;,&apos;admin@gavino.com&apos;,&apos;15699782000&apos;,&apos;2&apos;,now(),now()); 需求：创建普通用户账号 1insert into t_user values(NULL,&apos;user01&apos;,&apos;user01&apos;,&apos;user01@gavino.com&apos;,&apos;15699782111&apos;,&apos;1&apos;,now(),now()); 需求：1、创建4个部门分别为10,20,30,40,部门名为研发部，教学部，人事部，财务部 1234insert into dept values(10,&apos;研发部&apos;,&apos;理工本部综合楼301&apos;);insert into dept values(20,&apos;教学部&apos;,&apos;理工本部综合楼302&apos;);insert into dept values(30,&apos;人事部&apos;,&apos;理工本部综合楼303&apos;);insert into dept values(40,&apos;财务部&apos;,&apos;理工本部综合楼304&apos;); 2、向员工表中添加如下员工： 一个总裁 1insert into emp values(7000,&apos;KING&apos;,&apos;总裁&apos;,20000,&apos;2010-1-1&apos;,null,10); 三个部门（研发部，教学部，人事部）经理 123insert into emp values(7001,&apos;汪三四&apos;,&apos;经理&apos;,18000,&apos;2013-2-12&apos;,7000,10);insert into emp values(7002,&apos;马五六&apos;,&apos;经理&apos;,22000,&apos;2014-3-10&apos;,7000,20);insert into emp values(7003,&apos;周七八&apos;,&apos;经理&apos;,10000,&apos;2012-5-29&apos;,7000,30); 每个部门中添加5个员工 研发部 12345insert into emp values(7004,&apos;王啊&apos;,&apos;CLERK&apos;,15000,&apos;2012-09-19&apos;,7001,10); insert into emp values(7005,&apos;张吖&apos;,&apos;CLERK&apos;,12500,&apos;2013-02-12&apos;,7001,10);insert into emp values(7006,&apos;白嗄&apos;,&apos;CLERK&apos;,11000,&apos;2017-12-12&apos;,7001,10);insert into emp values(7007,&apos;王阿&apos;,&apos;CLERK&apos;,9000,&apos;2018-06-06&apos;,7001,10);insert into emp values(7008,&apos;曹咦&apos;,&apos;CLERK&apos;,19000,&apos;2019-05-12&apos;,7001,10); 教学部 123 insert into emp values(7010,&apos;楚王&apos;,&apos;讲师&apos;,22000,&apos;2016-09-19&apos;,7002,20); insert into emp values(7011,&apos;腾非&apos;,&apos;讲师&apos;,18000,&apos;2013-02-12&apos;,7002,20);...... 人事部 12insert into emp values(7015,&apos;张六&apos;,&apos;人事专员&apos;,6000,&apos;2017-09-19&apos;,7003,30);...... UPDATE 需求：将公司中30号部门员工涨薪100012update emp set sal=sal+1000 where deptno=30;update emp set sal=sal+600,hiredate=&apos;2016-05-12&apos; where empno=7019; DELETE 12insert into emp(empno,ename) values(8000,&apos;aaaa&apos;); delete from emp where empno=8000; SELECT: DML（INSERT,UPDATE,DELETE） DQL（SELECT） DML（INSERT,UPDATE,DELETE,SELECT 增删改查 CRUD） sql 更多练习： 基本查询 select 字段1,字段2… from 表名; 需求：列出员工姓名，薪水，职位，入职日期select ename,sal,job,hiredate from emp; 需求：列出员工表中所有数据select * from emp; (开发中，尽可能不使用*)select empno,ename,job,sal,hiredate,mgr,deptno from emp; 过滤查询 需求：列出10号部门员工的姓名，工资，入职日期select ename,sal,hiredate from emp where deptno=10; 需求：列出薪水低于10000的员工姓名，薪水，职位，部门号select ename,sal,job,deptno from emp where sal&lt;10000; 需求：列出10号部门16年之后入职的员工姓名，薪水，职位，入职日期select ename,sal,job,hiredate from emp where deptno=10 and hiredate&gt;’2016-1-1’; 需求：列出10号部门或16年之后入职的员工姓名，薪水，职位，入职日期，部门号select ename,sal,job,hiredate,deptno from emp where deptno=10 or hiredate&gt;’2016-1-1’; 需求：列出10，20号部门中的员工姓名，薪水，职位，部门号select ename,sal,job,deptno from emp where deptno in(10,20); 需求：列出’王’姓的员工姓名，职位，入职日期(模糊查询：like % _)%:任意位任意字符_:一位任意字符select ename,job,hiredate from emp where ename like ‘王%’; 需求：列出名字中第二个字是’浩’的员工姓名，薪水，职位，入职日期，部门号select ename,sal,job,hiredate,deptno from emp where ename like ‘_浩%’; 排序查询 order by asc(升序) desc(降序) 需求：列出员工的姓名，薪水，职位入职日期，根据薪水降序排序select ename,sal,hiredate from emp order by sal desc; 需求：列出员工的姓名，薪水，职位,入职日期，根据薪水降序排序,入职日期升序排序select ename,sal,hiredate from emp order by sal desc,hiredate asc; 需求：列出10号部门员工的姓名，薪水，职位，入职日期，根据薪水降序排序select ename,sal,job,hiredate from emp where deptno=10 order by sal desc; 分组查询 group by (统计运算：max min sum avg count) 需求：列出公司中每个部门员工薪水总和select deptno, sum(sal) from emp group by deptno; 需求：列出公司中每个部门的最大工资，最小工资，平均工资，工资总和select deptno,max(sal),min(sal),avg(sal),sum(sal) from emp group by deptno; 需求：列出公司中有多少个员工select ename,count(*) from emp;–语法错误 (注意：分组查询，只能查询分组字段和分组之后的函数运算结果) 多表查询（联合查询，内连接，外连接查询） ( 查询的数据分布在多张表里 ) 需求：列出员工姓名，薪水，职位，入职日期，部门名，部门地址等值查询(等价于内连接)select ename,sal,job,hiredate,dname,loc from emp e,dept dwhere e.deptno=d.deptno;内连接查询只查询满足连接条件的数据inner join … on…select ename,sal,job,hiredate,dname,loc from emp e inner join dept don e.deptno=d.deptno;(等值查询或内连接查询，查询的结果都必须满足连接条件)注意：多表查询一定要指定连接条件，条件的数量最少为 n-1否则会出现笛卡尔乘积现象外连接查询 :左外连接、右外连接、全外连接左外连接select ename,sal,job,hiredate,dname,loc from emp e left outer join dept don e.deptno=d.deptno;右外连接select ename,sal,job,hiredate,dname,loc from dept d right outer join emp eon e.deptno=d.deptno;右外连接select ename,sal,job,hiredate,dname,loc from emp e right outer join dept don e.deptno=d.deptno;全外连接（oracle支持）select ename,sal,job,hiredate,dname,loc from emp e full outer join dept don e.deptno=d.deptno; mysql分页查询 select * from emp limit 5,5; 其它操作HAVING 对分组后的结果再过滤 HAVING 是分组后的筛选条件,WHERE 则是在分组前筛选 WHERE子句在聚合前先筛选记录。也就是说作用在GROUP BY 子句和HAVING子句前 HAVING 在分组和聚集之后选取分组的行。因此，WHERE 子句不能包含聚集函数； HAVING 子句总是包含聚集函数。（也可以写不使用聚集的 HAVING 子句， 但这样做没有意义。同样的条件可以更有效地用于 WHERE ） 子查询普通子查询执行顺序 先查子查询 相关子查询先执行主查询 IN (NOT IN)EXISTS (NOT EXISTS)联合(多表)查询UNION UNION ALLUNION 对多个结果集去重的连接操作UNION ALL 对多个结果集不去重的连接操作 视图(view)一个命名的查询 ,可以通过视图隐藏表结构可以简化SQL语句创建视图 123create or replace view myviewas...... 使用视图查询: 1select * from myview; 事务 原子性(Atomicity)一个不可分割的操作单元，保证所有的操作要么都成功，要么都失败 一致性(Consistency)事务前后数据的完整性必须保持一致 隔离性(Isolation)并发访问数据库期间，一个用户的事务不会被其他事务所干扰，多个并发事务的数据相互隔离 持久性(Durability)一旦事务被提交，它对数据的改变就是永久的。","link":"/2019/07/23/mysql在项目中的基本操作/"},{"title":"Java基础面试总结(二)","text":"1. 两个对象的hashCode相同，则equals也一定为true，对吗？不对，答案见下面的代码： 1234@Overridepublic int hashCode() { return 1;} 两个对象equals为true，则hashCode也一定相同，对吗？ 这块肯定是有争议的。面试的时候这样答：如果按照官方设计要求来打代码的话，hashcode一定相等。但是如果不按官方照设计要求、不重写hashcode方法，就会出现不相等的情况。 2. java线程池用过没有？ Executors提供了四种方法来创建线程池。 newFixedThreadPool() :创建固定大小的线程池。 newCachedThreadPool(): 创建无限大小的线程池，线程池中线程数量不固定，可根据需求自动更改。 newSingleThreadPool() : 创建单个线程池，线程池中只有一个线程。 newScheduledThreadPool() 创建固定大小的线程池，可以延迟或定时的执行任务。 手写一个： 12345678910public static void main(String[] args) { ExecutorService threadPool = Executors.newCachedThreadPool(); threadPool.execute(() -&gt; { for (int i = 0; i&lt; 20;i++) { System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); } }); threadPool.shutdown();} 线程池作用 限制线程个数，避免线程过多导致系统运行缓慢或崩溃。 不需要频繁的创建和销毁，节约资源、响应更快。 3. Math.round(-2.5)等于多少？ 不要认为它是四舍五入!不要认为它是四舍五入!不要认为它是四舍五入! 口诀：+0.5后向下取整。所以结果是-2。 留个题，Math.round(-2.6)结果和Math.round(2.6)结果 4. 面向对象六大原则 单一职责原则——SRP 让每个类只专心处理自己的方法。 开闭原则——OCP 软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。 里式替换原则——LSP 子类可以去扩展父类，但是不能改变父类原有的功能。 依赖倒置原则——DIP 应该通过调用接口或抽象类(比较高层)，而不是调用实现类(细节)。 接口隔离原则——ISP 把接口分成满足依赖关系的最小接口，实现类中不能有不需要的方法。 迪米特原则——LOD 高内聚,低耦合。 5. static和final区别 关键词 修饰物 影响 final 变量 分配到常量池中，程序不可改变其值 final 方法 子类中将不能被重写 final 类 不能被继承 static 变量 分配在内存堆上，引用都会指向这一个地址而不会重新分配内存 static 方法块 虚拟机优先加载 static 类 可以直接通过类来调用而不需要new 6. String s = “hello”和String s = new String(“hello”);区别String s = new String(&quot;hello&quot;);可能创建两个对象也可能创建一个对象。如果常量池中有hello字符串常量的话，则仅仅在堆中创建一个对象。如果常量池中没有hello对象，则堆上和常量池都需要创建。 String s = &quot;hello&quot;这样创建的对象，JVM会直接检查字符串常量池是否已有”hello”字符串对象，如没有，就分配一个内存存放”hello”，如有了，则直接将字符串常量池中的地址返回给栈。(没有new，没有堆的操作) 7. 引用类型是占用几个字节？hotspot在64位平台上，占8个字节，在32位平台上占4个字节。 8. (1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4和(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)区别12System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4);System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)); 控制台: 12a34a7 8.1 什么情况下,加号会变成字符串连接符依据上面的例子来思考。 9. java中的switch选择结构可以使用数据类型的数据(JDK1.8) char byte short int Character Byte Short Integer String enum 更好的记忆方法: 基本类型中，没有boolean和浮点类型+长类型long.相应的包装类型也没有。 外加String和enum。 10. 4&amp;5``4^5``4&amp;10&gt;&gt;1各等于多少1234567// 0100 &amp; 0101 = 0100 = 4System.out.println(4&amp;5);// 0100 ^ 0101 = 0001 = 1System.out.println(4^5);System.out.println(10&gt;&gt;1); // 有疑问参考下面的运算符优先级System.out.println(4&amp;10&gt;&gt;1); 12344154 4|5等于多少呢答案：5 运算符优先级 运算符 结合性 [ ] . ( ) (方法调用) 从左向右 ! ~ ++ -- +(一元运算) -(一元运算) 从右向左 * / % 从左向右 + - 从左向右 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 从左向右 &lt; &lt;= &gt; &gt;= instanceof 从左向右 == != 从左向右 &amp; 从左向右 ^ 从左向右 ` ` &amp;&amp; 从左向右 ` ?: 从右向左 = 从右向左 11. 某些java类为什么要实现Serializable接口为了网络进行传输或者持久化 什么是序列化将对象的状态信息转换为可以存储或传输的形式的过程 除了实现Serializable接口还有什么序列化方式 Json序列化 FastJson序列化 ProtoBuff序列化… 12. JVM垃圾处理方法标记-清除算法（老年代）该算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象(可达性分析), 在标记完成后统一清理掉所有被标记的对象. 该算法会有两个问题： 效率问题，标记和清除效率不高。 空间问题: 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集。 所以它一般用于”垃圾不太多的区域，比如老年代”。 复制算法（新生代）该算法的核心是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象（非垃圾）复制到另外一块上面, 然后把已使用过的内存空间一次清理掉. 优点：不用考虑碎片问题，方法简单高效。缺点：内存浪费严重。 现代商用VM的新生代均采用复制算法, 但由于新生代中的98%的对象都是生存周期极短的, 因此并不需完全按照1∶1的比例划分新生代空间, 而是将新生代划分为一块较大的Eden区和两块较小的Survivor区(HotSpot默认Eden和Survivor的大小比例为8∶1), 每次只用Eden和其中一块Survivor. 当发生MinorGC时, 将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor上, 最后清理掉Eden和刚才用过的Survivor的空间. 当Survivor空间不够用(不足以保存尚存活的对象)时, 需要依赖老年代进行空间分配担保机制, 这部分内存直接进入老年代。 复制算法的空间分配担保：在执行Minor GC前, VM会首先检查老年代是否有足够的空间存放新生代尚存活对象, 由于新生代使用复制收集算法, 为了提升内存利用率, 只使用了其中一个Survivor作为轮换备份, 因此当出现大量对象在Minor GC后仍然存活的情况时, 就需要老年代进行分配担保, 让Survivor无法容纳的对象直接进入老年代, 但前提是老年代需要有足够的空间容纳这些存活对象. 但存活对象的大小在实际完成GC前是无法明确知道的, 因此Minor GC前, VM会先首先检查老年代连续空间是否大于新生代对象总大小或历次晋升的平均大小, 如果条件成立, 则进行Minor GC, 否则进行Full GC(让老年代腾出更多空间).然而取历次晋升的对象的平均大小也是有一定风险的, 如果某次Minor GC存活后的对象突增,远远高于平均值的话,依然可能导致担保失败(Handle Promotion Failure, 老年代也无法存放这些对象了), 此时就只好在失败后重新发起一次Full GC(让老年代腾出更多空间). 标记-整理算法（老年代）标记清除算法会产生内存碎片问题, 而复制算法需要有额外的内存担保空间, 于是针对老年代的特点, 又有了标记整理算法. 标记整理算法的标记过程与标记清除算法相同, 但后续步骤不再对可回收对象直接清理, 而是让所有存活的对象都向一端移动,然后清理掉端边界以外的内存. 13. 新生代、老年代、持久代都存储哪些东西新生代： 方法中new一个对象，就会先进入新生代。 老年代： 新生代中经历了N次垃圾回收仍然存活的对象就会被放到老年代中。 大对象一般直接放入老年代。 当Survivor空间不足。需要老年代担保一些空间，也会将对象放入老年代。 永久代：指的就是方法区。 14. 可达性算法中，哪些对象可作为GC Roots对象。 虚拟机栈中引用的对象 方法区静态成员引用的对象 方法区常量引用对象 本地方法栈JNI引用的对象 15. 什么时候进行MinGC和FullGCMinGC: 当Eden区满时,触发Minor GC. FullGC: 调用System.gc时，系统建议执行Full GC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小大于老年代的剩余空间 堆中分配很大的对象，而老年代没有足够的空间 16. 如何判定对象为垃圾对象在堆里面存放着Java世界中几乎所有的对象实例, 垃圾收集器在对堆进行回收前, 第一件事就是判断哪些对象已死(可回收). 引用计数法在JDK1.2之前，使用的是引用计数器算法。在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就+1，当引用失效的时候，计数器的值就-1，当引用计数器被减为零的时候，标志着这个对象已经没有引用了，可以回收了！ 问题：如果在A类中调用B类的方法，B类中调用A类的方法，这样当其他所有的引用都消失了之后，A和B还有一个相互的引用，也就是说两个对象的引用计数器各为1，而实际上这两个对象都已经没有额外的引用，已经是垃圾了。但是该算法并不会计算出该类型的垃圾。 可达性分析法在主流商用语言(如Java、C#)的主流实现中, 都是通过可达性分析算法来判定对象是否存活的: 通过一系列的称为 GC Roots 的对象作为起点, 然后向下搜索; 搜索所走过的路径称为引用链/Reference Chain, 当一个对象到 GC Roots 没有任何引用链相连时, 即该对象不可达, 也就说明此对象是不可用的, 如下图:虽然E和F相互关联， 但它们到GC Roots是不可达的, 因此也会被判定为可回收的对象。 注: 即使在可达性分析算法中不可达的对象, VM也并不是马上对其回收, 因为要真正宣告一个对象死亡, 至少要经历两次标记过程: 第一次是在可达性分析后发现没有与GC Roots相连接的引用链, 第二次是GC对在F-Queue执行队列中的对象进行的小规模标记(对象需要覆盖finalize()方法且没被调用过). 17. 你能说出来几个垃圾收集器SerialSerial收集器是Hotspot运行在Client模式下的默认新生代收集器, 它在进行垃圾收集时，会暂停所有的工作进程，用一个线程去完成GC工作 特点：简单高效，适合jvm管理内存不大的情况（十兆到百兆）。 ParnewParNew收集器其实是Serial的多线程版本，回收策略完全一样，但是他们又有着不同。 我们说了Parnew是多线程gc收集，所以它配合多核心的cpu效果更好，如果是一个cpu，他俩效果就差不多。（可用-XX:ParallelGCThreads参数控制GC线程数） CmsCMS(Concurrent Mark Sweep)收集器是一款具有划时代意义的收集器, 一款真正意义上的并发收集器, 虽然现在已经有了理论意义上表现更好的G1收集器, 但现在主流互联网企业线上选用的仍是CMS(如Taobao),又称多并发低暂停的收集器。 由他的英文组成可以看出，它是基于标记-清除算法实现的。整个过程分4个步骤： 初始标记(CMS initial mark):仅只标记一下GC Roots能直接关联到的对象, 速度很快 并发标记(CMS concurrent mark: GC Roots Tracing过程) 重新标记(CMS remark):修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录 并发清除(CMS concurrent sweep: 已死对象将会就地释放) 可以看到，初始标记、重新标记需要STW(stop the world 即：挂起用户线程)操作。因为最耗时的操作是并发标记和并发清除。所以总体上我们认为CMS的GC与用户线程是并发运行的。 优点:并发收集、低停顿 缺点： CMS默认启动的回收线程数=(CPU数目+3)*4当CPU数&gt;4时, GC线程最多占用不超过25%的CPU资源, 但是当CPU数&lt;=4时, GC线程可能就会过多的占用用户CPU资源, 从而导致应用程序变慢, 总吞吐量降低. 无法清除浮动垃圾（GC运行到并发清除阶段时用户线程产生的垃圾），因为用户线程是需要内存的，如果浮动垃圾施放不及时，很可能就造成内存溢出，所以CMS不能像别的垃圾收集器那样等老年代几乎满了才触发，CMS提供了参数-XX:CMSInitiatingOccupancyFraction来设置GC触发百分比(1.6后默认92%),当然我们还得设置启用该策略-XX:+UseCMSInitiatingOccupancyOnly 因为CMS采用标记-清除算法，所以可能会带来很多的碎片，如果碎片太多没有清理，jvm会因为无法分配大对象内存而触发GC，因此CMS提供了-XX:+UseCMSCompactAtFullCollection参数，它会在GC执行完后接着进行碎片整理，但是又会有个问题，碎片整理不能并发，所以必须单线程去处理，所以如果每次GC完都整理用户线程stop的时间累积会很长，所以XX:CMSFullGCsBeforeCompaction参数设置隔几次GC进行一次碎片整理（默认为0）。 G1同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是引入分区的思路，弱化分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。 因为每个区都有E、S、O代，所以在G1中，不需要对整个Eden等代进行回收，而是寻找可回收对象比较多的区，然后进行回收（虽然也需要STW操作，但是花费的时间是很少的），保证高效率。 新生代收集G1的新生代收集跟ParNew类似，如果存活时间超过某个阈值，就会被转移到S/O区。 年轻代内存由一组不连续的heap区组成, 这种方法使得可以动态调整各代区域的大小 老年代收集分为以下几个阶段： 初始标记 (Initial Mark: Stop the World Event)在G1中, 该操作附着一次年轻代GC, 以标记Survivor中有可能引用到老年代对象的Regions. 扫描根区域 (Root Region Scanning: 与应用程序并发执行)扫描Survivor中能够引用到老年代的references. 但必须在Minor GC触发前执行完 并发标记 (Concurrent Marking : 与应用程序并发执行)在整个堆中查找存活对象, 但该阶段可能会被Minor GC中断 重新标记 (Remark : Stop the World Event)完成堆内存中存活对象的标记. 使用snapshot-at-the-beginning(SATB, 起始快照)算法, 比CMS所用算法要快得多(空Region直接被移除并回收, 并计算所有区域的活跃度). 清理 (Cleanup : Stop the World Event and Concurrent)在含有存活对象和完全空闲的区域上进行统计(STW)、擦除Remembered Sets(使用Remembered Set来避免扫描全堆，每个区都有对应一个Set用来记录引用信息、读写操作记录)(STW)、重置空regions并将他们返还给空闲列表(free list)(Concurrent) 详情请看参考文档 18. JVM中对象的创建过程1. 拿到内存创建指令当虚拟机遇到内存创建的指令的时候（new 类名），来到了方法区，找 根据new的参数在常量池中定位一个类的符号引用。 2. 检查符号引用检查该符号引用有没有被加载、解析和初始化过，如果没有则执行类加载过程，否则直接准备为新的对象分配内存 3. 分配内存虚拟机为对象分配内存（堆）分配内存分为指针碰撞和空闲列表两种方式；分配内存还要要保证并发安全，有两种方式。 3.1. 指针碰撞所有的存储空间分为两部分，一部分是空闲，一部分是占用，需要分配空间的时候，只需要计算指针移动的长度即可。 3.2. 空闲列表虚拟机维护了一个空闲列表，需要分配空间的时候去查该空闲列表进行分配并对空闲列表做更新。 可以看出，内存分配方式是由java堆是否规整决定的，java堆的规整是由垃圾回收机制来决定的 3.2.5 安全性问题的思考假如分配内存策略是指针碰撞，如果在高并发情况下，多个对象需要分配内存，如果不做处理，肯定会出现线程安全问题，导致一些对象分配不到空间等。 下面是解决方案： 3.3 线程同步策略也就是每个线程都进行同步，防止出现线程安全。 3.4. 本地线程分配缓冲也称TLAB（Thread Local Allocation Buffer），在堆中为每一个线程分配一小块独立的内存，这样以来就不存并发问题了，Java 层面与之对应的是 ThreadLocal 类的实现 4. 初始化 分配完内存后要对对象的头（Object Header）进行初始化，这新信息包括：该对象对应类的元数据、该对象的GC代、对象的哈希码。 抽象数据类型默认初始化为null，基本数据类型为0，布尔为false。。。5. 调用对象的初始化方法也就是执行构造方法。","link":"/2019/07/27/Java基础面试总结-二/"},{"title":"Java 多线程基础总结","text":"本文是Java多线程的基础入门篇 一、程序 进程 线程 程序：指令集，静态概念 进程：操作系统调度程序，动态概念 线程：在进程内多条执行路径 线程是进程中包含的一个或多个执行单元。线程只能归属一个进程。并且线程只能访问该进程所拥有的资源。当操作系统创建一个进程，该进程会自动申请一个主线程作为首要执行的任务。线程之间是独立的 一个进程内可以有多条并行的线程一个线程是进程的一个执行单元同类的多个线程共享一块内存空间和一组资源。线程本身是一个有可供程序执行的堆栈。线程的切换耗时小，把线程称为轻负荷进程。 进程和线程的关系： 1.一个进程至少要有一个线程。 2.线程的划分尺度一定是小于进程。 3.多个进程在执行过程中拥有独立的内存单元。 4.而多个线程共享内存。 5.线程在执行过程中与进程的区别在于每个独立的线程都有一个程序的执行入口，顺序执行，并有一个程序的执行出口。 6.从逻辑角度讲，多线程的意义在于一个应用程序中，有多个执行部分可以并发运行，但操作系统并没有将多个线程看作独立的应用来实现进程的调度和管理以及资源分配。 线程和进程的区别 根本区别：线程作为资源分配的单位 进程是调度和执行的单位 线程是进程的一部分 线程是不同的执行路径 并发：多个线程”同时”进行(),实际上多个线程是并发运行的。操作系统将运行时的多个线程以时间片段划分，在不同的时间片段中随机切换。Java支持多线程，即在Java应用程序中，可以创建多个线程，多个线程可以并发运行。 二、线程创建之一 继承Thread +run(线程体) 启动：创建子类对象 +对象.start() 1234567891011121314151617181920/** * 继承Thread类，定义线程类 * @author gavino */public class MyThread extends Thread { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(i); } }}public class Test { public static void main(String[] args) { MyThread t1 = new MyThread();//创建线程对象 t1.start();//启动线程 MyThread t2 = new MyThread(); t2.start(); }}继承Thread类方式的缺点 三、静态代理模式* 1、真实角色* 2、代理角色： 要持有真实角色的引用* 3、二者要实现相同的接口 四、线程创建之二 类实现Runnable接口 +重写run(线程体)方法 –&gt;真实角色类 启动： 1、创建真实角色 2、创建代理角色(Thread类) +真实角色引用 3、代理对象.start() 12345678910111213141516171819202122232425262728/** * 实现 Runnable 接口创建线程 描述的是线程任务，而不是线程 * 所以不能直接启动 * 注意 此时，MyThread 不是线程类，只是实现了接口的普通类 * @author gavino */public class MyThread implements Runnable { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(i); } }}/** * Runnable 接口，是线程任务的规范接口，实现Runnable接口的类，描述的是线程任务 * 可以使用一个Thread对象封装一个实现Runnable接口对象，进而实现多线程。 * @author gavino */public class Test { public static void main(String[] args) { Runnable r1 = new MyThread();//创建一个任务对象 Thread t1 = new Thread(r1);//创建一个线程对象 t1.start();//调用的是Thread 的run()方法，由该run()方法调用r1的run() Thread t2 = new Thread(r1);//创建第二个线程对象 t2.start(); }}匿名内部类创建并启动线程 12345678910public static void main(String[] args) { new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(&quot;匿名内部类多线程&quot;+i); } } }).start();} 两种线程的区别 继承类，不能实现多个线程共享同一个实例资源实现接口，任务模块化，多个线程可以共享同一个资源 继承类，就不能继承其它类，有单继承局限性实现接口，还可以继承其他的父类 判断线程的个数，就看new 了多少个 Thread 或多少个 Thread 的子类。实现 Runnable的类并不是线程类 推荐使用Runnable创建线程1）避免单继承的局限性2）便于共享资源 五、线程创建之三 类实现Callable接口 run方法的缺点：1、不能抛异常2、没有返回值 Callable创建线程：优点–可以获取返回值，缺点–比较繁琐 1）创建Callable实现类 +重写call()方法2）借助执行调度服务ExecutorService获取Future对象 ExecutorService ser = Executors.newFixedThreadPool(线程数量); Future result = ser.submit(实现类对象);3）获取值 result.get();4）停止服务 ser.shutdown(); 六、线程池就是把若干用户线程添加到线程池中，由线程来统一管理线程 为什么要使用线程池： 减少了创建和销毁线程的次数，每个工作线程 可以根据系统的承受能力，调整线程池中结论： 线程池的使用：有一个Executors 的线程工具类，此类提供了若干静态方法这些静态方法1.线程池保证所有的任务是按照任务的提交顺序来执行 Executors.newFixedThreadPool();创建固定大小的线程池，每次提交一个任务就创建一个 Executors.newCachedThreadPool();创建了一个可以缓冲的线程池，如果线程大小超过处理任务所需要的线程，那么就回收部分线程， 创建一个大小无限制的线程池，此线程池支持定时以及周期性的执行任务的需求。 线程池核心线程满了，线程会进入阻塞队列，阻塞式队列满了，才开临时线程能执行的线程总数为: 核心线程数量 + 阻塞队列中的线程数量 + 临时线程数量 七、线程状态与停止线程、线程阻塞(一)线程状态 新建状态(new): 创建一个线程对象 就绪状态(Runnable): 线程对象创建以后，调用start()方法，就绪状态的线程只处于等待cpu的使用权。变为可运行。 运行状态(Running): 就绪状态的线程，获取到了cpu资源，执行程序代码。 阻塞状态(Blocked): 等待阻塞 调用wait()方法 没有占用cpu资源，也没有处于排队等待cpu状态 睡眠阻塞 调用sleep()方法 占用cpu资源，也没有处于排队等待cpu状态 IO阻塞 进入IO操作，线程即进入到IO阻塞状态，当IO操作结束，即结束IO阻塞状态 死亡状态(Dead): 线程任务执行结束 即run()结束，该线程对象就会垃圾回收 (二)停止线程 自然终止：线程体正常执行完毕。 外部干涉： 线程类中定义线程体使用的标识 线程体使用该标识 提供对外的方法改变该标识 外部根据条件调用该方法即可 (三)线程阻塞 join:合并线程(调用 join() 后，线程会等待 join() 所属线程运行结束后再继续运行。) yield：(屈服，让步)暂停自己的线程(从运行状态切换到就绪状态)就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行 注意是让自己或者其他线程运行，并不是单纯的让给其他线程。 sleep:休眠(暂停当前线程) 不释放锁 常用于两种形式 与时间相关的 如倒计时 模拟网络延时 八、线程基本信息-优先级 优先级不代表执行的先后顺序 代表概率 MAX_PRIORITY 10 NORM_PRIORITY 5(默认) MIN_PRIORITY 1 *setPriority() 设置优先级 123456789101112131415161718192021222324252627282930313233/** * 测试线程的优先级 * @author gavino */public class Test { public static void main(String[] args) { for (int i = 0; i &lt; 10; i++) { System.out.println(i+&quot; 线程：&quot;+Thread.currentThread().getName()+&quot; 优先级：&quot;+Thread.currentThread().getPriority()); } MyRun r1 = new MyRun(); MyRun r2 = new MyRun(); Thread t1 = new Thread(r1); t1.setName(&quot;t1&quot;); Thread t2 = new Thread(r2); t2.setName(&quot;t2&quot;); //获取线程的优先级// System.out.println(t1.getPriority());// System.out.println(t2.getPriority()); //设置线程优先级 t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(Thread.MIN_PRIORITY); t1.start(); t2.start(); }}class MyRun implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(i+&quot; 线程：&quot;+Thread.currentThread().getName()+&quot; 优先级：&quot;+Thread.currentThread().getPriority()); } }} 执行结果： 123456789101112130 线程：main 优先级：51 线程：main 优先级：52 线程：main 优先级：5...0 线程：t1 优先级：101 线程：t1 优先级：102 线程：t1 优先级：100 线程：t2 优先级：13 线程：t1 优先级：10...1 线程：t2 优先级：12 线程：t2 优先级：1... 线程类中常用的API currentThread()：当前线程 getName()：设置名称 setName(): 获取名称 isAlive()：判断状态 setDaemon(): 设置一个线程为守护(后台)线程 九、线程同步与锁定 可能出现线程安全问题的条件 多个线程访问统一资源 多行代码对同一个变量进行运算 同步：并发 多个线程访问同一份资源 确保资源安全 –&gt;线程安全（常说 Hashtable是线程安全的 HashMap是线程不安全的）synchronized–&gt;同步异步: synchronized可以修饰一段代码或方法(一)、同步块synchronized(引用类型|this|类.class) {}注意：(重要) 给this对象加锁，即谁调用该方法，谁就是该this对象 串行还是并行，得看所调用的资源是否互斥 要使资源互斥，即加锁的对象应该为同一对象 synchronized 作用在类上，类锁 synchronized static 和 synchronized(类名.class)此时锁在同一个类上 (两个方法)当锁分别加在对象上和类上时，但是加锁的目标不同，即锁定的资源不互斥，他们将并行运行总结： synchronized 关键字加的锁实际是加到对象上的，关键是找到加锁对象 synchronized 修饰，两个方法是并行还是串行，看锁定的资源是否互斥 (二)、同步方法synchronized 修饰方法，并不是给方法加锁，而是给方法的调用对象加锁，JVM每次调用方法，都会处理锁(线程安全的方法效率低)public synchronized void method(){…}-——————————————————-* 实例方法，this为默认的锁对象* 类方法，当前类的字节码对象作为锁* 同步代码段锁，可以是任意对象锁 单例设计模式：确保一个类只有一个对象(该对象为内部自己创建，外部只能调用这一个对象) #【确保一个类只有一个对象】 懒汉式：(前面懒得创建对象，在使用的时候再创建对象) 1、构造器私有化 避免外部直接创建对象 2、声明一个私有的静态变量(属性) 3、创建一个对外的公共的静态方法 访问该变量，如果变量没有对象 创建该对象 饿汉式： 1、构造器私有化 避免外部直接创建对象 2、声明一个私有的静态变量(属性)，同时创建对象 3、创建一个对外的公共的静态方法 访问该变量 十、死锁 过多的同步容易造成死锁 123456789101112synchronized(o1){ ...... synchronized(02){ ...... }}synchronized(02){ ...... synchronized(01){ ..... }} 模拟线程死锁现象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @author gavino 模拟线程死锁现象 * 不同的线程分别占用对方需要的同步资源 * 都在等待对方放弃自己需要的同步资源 * * 出现死锁后，不会出现异常 */public class Demo { public static void main(String[] args) { MyLock myLock = new MyLock(); YouLock youLock = new YouLock(); StringBuilder sb = new StringBuilder(); Thread t1 = new Thread(new Runnable() { @Override public void run() { synchronized (myLock) { sb.append(&quot;my lock&quot;); sb.append(&quot;hehehe&quot;); System.out.println(sb); synchronized (youLock) { sb.append(&quot;your lock&quot;); sb.append(&quot;hahaha&quot;); System.out.println(sb); } } } }); Thread t2 = new Thread(new Runnable() { @Override public void run() { synchronized (youLock) { sb.append(&quot;your lock&quot;); sb.append(&quot;hahaha&quot;); System.out.println(sb); synchronized (myLock) { sb.append(&quot;my lock&quot;); sb.append(&quot;hehehe&quot;); System.out.println(sb); } } } }); t1.start(); t2.start(); }}class MyLock {}class YouLock {} 解决方法：生产者消费者模式（此处不指设计模式） 即：（过马路）信号灯法（标志位） 信号灯:flag 思路: flag–&gt;T 生产者生产 消费者等待 生产完成后通知消费 flag–&gt;F 消费者消费 生产者等待 消费完成后通知生产 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * 一个场景 共同的资源 */public class Product { //信号灯 private boolean flag = true; private String pro; //生产功能 public synchronized void produce(String pro) { if (!flag) { try { this.wait();// } catch (InterruptedException e) { e.printStackTrace(); } } //开始生产 try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;生产了&quot;+pro); //生产完毕 this.pro = pro ; //通知消费 this.notify(); //停止生产 this.flag = false; } //消费功能 public synchronized void consume() { if (flag) { try { this.wait();// } catch (InterruptedException e) { e.printStackTrace(); } } //开始消费 try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } //消费完毕 System.out.println(&quot;消费了&quot;+pro); //通知生产 this.notifyAll(); //停止消费 this.flag = true; }}定义生产者 12345678910111213141516171819/* * 生产者 */public class Producer implements Runnable { private Product p; Producer(Product p) { this.p = p; } @Override public void run() { for(int i=0;i&lt;20;i++) { if(0==i%2) { p.produce(&quot;产品A&quot;); }else { p.produce(&quot;产品B&quot;); } } }} 定义消费者 123456789101112131415/* * 消费者 */public class Consumer implements Runnable { private Product p; Consumer(Product p) { this.p = p; } @Override public void run() { for (int i = 0; i &lt; 20; i++) { p.consume(); } }} 应用 123456789public static void main(String[] args) { //公共资源 产品 Product product = new Product(); //多线程 不同的对象访问同一份资源 Producer p = new Producer(product); Consumer c = new Consumer(product); new Thread(p).start(); new Thread(c).start();} 注意wait():等待 会释放锁sleep()不释放锁notify()/notifyAll():唤醒wait() notify()/notifyAll()和synchronized一同使用-—————————————————wait和notify是object的方法，也就是说所有对象都有这两个方法。notify() 唤醒处于等待阻塞状态的线程wait() 将当前线程对象切换到等待阻塞状态这两个方法可以用来阻塞当前线程（同时放弃互斥锁）或者是唤醒其他调用wait方法陷入阻塞的线程（不能唤醒那些因为抢占锁而阻塞的队列）。能够执行wait和notify的前提是代码已经进入了synchronized包含的代码块中。 十一、任务调度Timerschedule()quartz 框架 十二、总结 重点：* 创建线程* 终止线程* sleep* 同步(面试中) 面试点一个同步方法可以调用另一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁。也就是说 synchronized 获得的锁是可重入的。子类也可以调用父类的同步方法 程序在执行过程中，如果出现异常，默认情况锁会被释放。(因此要非常小心的处理同步业务逻辑的异常) 拓展JUC: 在 Java 5.0 提供了 java.util.concurrent(简称JUC)包,在此包中增加了在并发编程中很常用的工具类,用于定义类似于线程的自定义子系统,包括线程池,异步 IO 和轻量级任务框架;还提供了设计用于多线程上下文中的 Collection 实现等。quartz 框架： Quartz是一个完全由java编写的开源作业调度框架。 高并发编程工具JUC","link":"/2019/08/06/java-多线程/"},{"title":"这就是SpringMVC","text":"SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful 编程风格的请求。特点：基于模块化开发 SpringMVC VS Struts2区别入口不一 SpringMVC 基于方法设计的 SpringMVC 的基本概念SpringMVC 的入门 入门案例简单分析：jsp页面发送请求，编写相应的类和方法响应请求，再转发到相应的jsp页面 1、搭建开发环境在 IDEA 下创建一个Empty Project, New Module,选择 Maven,创建一个web项目(选择webapp)。 在pom.xml文件中导入相关依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;springmvc_day01_01_start&lt;/name&gt; &lt;groupId&gt;lut.gavino&lt;/groupId&gt; &lt;artifactId&gt;springmvc_day01_01_start&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.9.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;version&gt;6.1.7&lt;/version&gt; &lt;configuration&gt; &lt;connectors&gt; &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt; &lt;port&gt;8888&lt;/port&gt; &lt;maxIdleTime&gt;30000&lt;/maxIdleTime&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;webAppSourceDirectory&gt;${project.build.directory}/${pom.artifactId}-${pom.version}&lt;/webAppSourceDirectory&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置前端控制器 打开webapp下的WEB-INF目录,编辑 web.xml 文件,需要配置核心控制器–Servlet,具体配置的web.xml文件内容如下： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app version=&quot;2.4&quot; xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;description&gt;Cocoon blocks dispatcher&lt;/description&gt; &lt;display-name&gt;DispatcherServlet&lt;/display-name&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; resources 下创建配置文件 右击 resources ,依次选择 New -&gt; XML Configuration File -&gt; Spring Config,创建文件名为 springmvc.xml的配置文件。注：该文件名称任意 部署服务器(Tomcat Server) 2、代码案例在 webapp下编写 index.jsp 页面： 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Springmvc 入门案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Springmvc 入门案例&lt;/h2&gt; &lt;a href=&quot;&quot;&gt;入门测试 demo1&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 在 src下的main下的java包下创建一个控制器的类,springmvc.controller.HelloController。 12345678910package springmvc.controller;/** * @author Gavino */public class HelloController { public String getSpringmvc(){ System.out.println(&quot;Hello Springmvc!!!&quot;); return &quot;success&quot;; }} 在 springmvc.xml 配置文件中 开启注解扫描 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=&quot;springmvc&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 在HelloController类上添加注解然后在HelloController类的方法getSpringmvc()上添加注解 @RequestMapping 12345678@Controllerpublic class HelloController { @RequestMapping(path = &quot;/hello&quot;) public String getSpringmvc(){ System.out.println(&quot;Hello Springmvc!!!&quot;); return &quot;success&quot;; }} 在@RequestMapping(path = “/hello”)中提供路径/hello,所以在页面(index.jsp)请求路径中写hello即可 1234&lt;body&gt; &lt;h2&gt;Springmvc 入门案例&lt;/h2&gt; &lt;a href=&quot;hello&quot;&gt;入门测试 demo1&lt;/a&gt;&lt;/body&gt; 在web.xml文件中提供一组全局的初始化参数用于加载springmvc.xml, 1234&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;&lt;/init-param&gt; 1&lt;load-on-startup&gt;1&lt;/load-on-startup&gt; jsp页面一发请求,创建一个DispatcherServlet对象web.xml完整配置如下: 123456789101112131415&lt;servlet&gt; &lt;description&gt;Cocoon blocks dispatcher&lt;/description&gt; &lt;display-name&gt;DispatcherServlet&lt;/display-name&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; HelloController类的方法getSpringmvc()返回一个字符串”success”,则默认跳到success.jsp页面，所以创建一个success.jsp页面。此处在webapp下的WEB-INF目录下创建一个目录pages，用于存放页面，然后在该目录下创建success.jsp页面。 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt; Congratulations Springmvc 入门成功！！！&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 最后在springmvc.xml文件中配置视图解析器，以跳转到指定页面 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=&quot;springmvc.controller&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 文件所在目录 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;&gt;&lt;/property&gt; &lt;!-- 文件后缀名 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3、执行过程及原理分析 执行过程 1、服务器启动，应用被加载。读取到 web.xml 中的配置创建 spring 容器并且初始化容器中的对象。如：HelloController 和 InternalResourceViewResolver等2、浏览器发送请求，被 DispatherServlet 捕获，该 Servlet 并不处理请求，而是把请求转发出去。转发的路径是根据请求 URL，匹配@RequestMapping 中的内容。3、匹配到了后，执行对应方法。该方法有一个返回值。4、根据方法的返回值，借助 InternalResourceViewResolver 找到对应的结果视图。5、渲染结果视图，响应浏览器。 SpringMVC 的请求响应流程 4、入门案例的流程总结 启动服务器，加载一些配置文件 Servlet 第一次发请求，才会被创建成对象，DispatcherServlet对象创建在服务器启动过程中，springmvc.xml文件被加载然后创建 HelloController 对象创建视图解析器对象在通过视图解析器访问到指定页面 发送请求，后台处理请求 页面请求到达前端控制器 DispatcherServlet 一方面，通过路径配置找到对应方法，拿到返回值 另一方面，找到视图解析器对象，帮助跳到指定页面最后将结果通知给用户 5、相关组件 DispatcherServlet：前端控制器 相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。 HandlerMapping：处理器映射器 HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 Handler：处理器 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 HandlAdapter：处理器适配器 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 View Resolver：视图解析器 View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 View：视图 SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 &lt;mvc:annotation-driven&gt;说明 在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。使用 &lt;mvc:annotation-driven&gt; 自动加载 RequestMappingHandlerMapping （处理映射器） 和RequestMappingHandlerAdapter （ 处理适配器 ） ，可用 在SpringMVC.xml 配置文件中使用&lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。 6、RequestMapping 注解 使用说明 作用用于建立请求 URL 和处理请求方法之间的对应关系。 使用位置 类上：请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。它出现的目的是为了使我们的 URL 可以按照模块化管理: 方法上：请求 URL 的第二级访问目录。 属性 value：用于指定请求的 URL。它和 path 属性的作用是一样的。 method：用于指定请求的方式。 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。例如：params = {“accountName”}，表示请求参数必须有 accountNameparams = {“moeny!100”}，表示请求参数中 money 不能是 100。 headers：用于指定限制请求消息头的条件。 注意： 以上四个属性只要出现 2 个或以上时，他们的关系是与的关系。 代码示例 请求参数的绑定1、请求参数绑定实体类型2、请求参数绑定集合类型3、配置解决中文乱码的过滤器4、自定义类型转换器及相关异常常用注解1、RequestParam 作用把请求中指定名称的参数给控制器中的形参赋值。 属性 value：请求参数中的名称。 required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。 代码示例 2、RequestBody 作用用于获取请求体内容。直接使用得到是 key=value&amp;key=value…结构的数据。get 请求方式不适用。 属性 required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。 代码示例 3、PathVaribale 作用用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。 属性 value：用于指定 url 中占位符名称。 required：是否必须提供占位符。 代码示例 4、RequestHeader 作用用于获取请求消息头。 属性 value：提供消息头名称 required：是否必须有此消息头 代码示例 5、CookieValue 作用用于把指定 cookie 名称的值传入控制器方法参数。 属性 value：指定 cookie 的名称。 required：是否必须有此 cookie。 代码示例 6、ModelAttribute 作用该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。出现在参数上，获取指定的数据给参数赋值。 属性 value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。 代码示例 7、SessionAttribute 作用用于多次执行控制器方法间的参数共享。 属性 value：用于指定存入的属性名称 type：用于指定存入的数据类型。 代码示例 响应数据和结果视图(一)返回值分类1、字符串 2、void3、ModelAndView ModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。 注意：我们在页面上获取使用的是 requestScope.username 取的，所以返回 ModelAndView 类型时，浏览器跳转只能是请求转发。 (二)转发和重定向1、forward 转发2、Redirect 重定向 (三)ResponseBody 响应 json 数据 使用说明 作用：该注解用于将 Controller 的方法返回的对象，通过 HttpMessageConverter 接口转换为指定格式的数据如：json,xml 等，通过 Response 响应给客户端 使用示例 SpringMVC 实现文件上传SpringMVC 中的异常处理异常处理的思路实现步骤SpringMVC 中的拦截器(一)拦截器的定义和作用 用户可以自己定义一些拦截器来实现特定的功能。 拦截器链（Interceptor Chain）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 拦截器和过滤器:过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。 拦截器也是 AOP 思想的具体应用。我们要想自定义拦截器， 要求必须实现：HandlerInterceptor 接口。 (二)自定义拦截器的步骤Step 一：编写一个普通类实现 HandlerInterceptor 接口Step 二：配置拦截器在spingmvc.xml 中Step 三：测试运行结果 (三)拦截器的细节 拦截器的放行 拦截器中方法的说明 拦截器的作用路径 多个拦截器的执行顺序 (四)流程测试","link":"/2019/08/31/这就是SpringMVC/"},{"title":"这就是Spring","text":"本文将通过对 Spring 基础知识的总结，加深对 Spring 的理解与应用。 一、Spring 概述Spring 的优势方便解耦，简化开发AOP编程的支持声明式事务的支持方便程序的测试方便集成各种优秀框架降低 JavaEE API 的使用难度Java 源码是经典学习范例 Spring 的体系结构核心容器 Sping 的开发包官网https://spring.io/下载地址(http://repo.springsource.org/libs-release-local/org/springframework/spring) 二、IOC 的概念和作用这部分内容可查看之前的文章IOC基本原理及相关实现对IOC有单独的阐述 三、使用 spring 的 IOC 解决程序耦合创建持久层接口和实现类1234567891011121314151617181920package gavino.spring.dao;/** * @author Yan weigang */public interface IDemoDao { void print();}package gavino.spring.dao.impl;import gavino.spring.dao.IDemoDao;/** * @author Yan weigang */public class DemoDaoImpl implements IDemoDao { public void print() { System.out.println(&quot;使用 spring 的 IOC 解决程序耦合&quot;); }} 创建业务层接口和实现类1234567891011121314151617181920212223package gavino.spring.service;/** * @author Yan weigang */public interface IDemoService { void print();}package gavino.spring.service.impl;import gavino.spring.dao.IDemoDao;import gavino.spring.dao.impl.DemoDaoImpl;import gavino.spring.service.IDemoService;/** * @author Yan weigang */public class DemoServiceImpl implements IDemoService { IDemoDao dao = new DemoDaoImpl();//将通过ioc解决这种依赖关系 public void print() { dao.print(); }} 测试 12345678910111213package gavino.spring.ui;import gavino.spring.service.impl.DemoServiceImpl;/** * @author Yan weigang */public class View { public static void main(String[] args) { DemoServiceImpl service = new DemoServiceImpl();//将通过ioc解决这种依赖关系 service.print(); }} 基于 XML 的配置在pom.xml 中导入相关依赖 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;lut.gavino&lt;/groupId&gt; &lt;artifactId&gt;day01_spring04_ioc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 在resources下创建一个任意名称的 xml 文件(不能是中文，我一般命名为bean.xml)给配置文件导入约束 在之前的 Spring 开发包中，解压以 dist 结尾的压缩包以后，进入该包中找到 docs 文件夹并进入，然后选择 spring-framework-reference 文件进入，在该目录下找到 core.html 文件用浏览器打开，找到如下约束: 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 在 bean.xml 文件中导入约束以后在配置文件中配置 service 和 dao,让 Spring 管理资源 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置 dao --&gt; &lt;bean id=&quot;demoDao&quot; class=&quot;gavino.spring.dao.impl.DemoDaoImpl&quot;&gt;&lt;/bean&gt; &lt;!-- 配置 service --&gt; &lt;bean id=&quot;demoService&quot; class=&quot;gavino.spring.service.impl.DemoServiceImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 修改前面的测试，测试配置是否成功 1234567891011121314151617181920212223242526272829303132333435package gavino.spring.ui;import gavino.spring.dao.IDemoDao;import gavino.spring.service.IDemoService;import gavino.spring.service.impl.DemoServiceImpl;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author Yan weigang */public class View { public static void main(String[] args) {// IDemoService service = new DemoServiceImpl();//将通过ioc解决这种依赖关系// service.print(); //1.使用 ApplicationContext 接口，就是在获取 spring 容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); //2.根据 bean 的 id 获取对象 IDemoDao dao = (IDemoDao) context.getBean(&quot;demoDao&quot;); IDemoDao demoDao = context.getBean(&quot;demoDao&quot;, IDemoDao.class); System.out.println(dao); System.out.println(demoDao); IDemoService service = context.getBean(&quot;demoService&quot;,IDemoService.class); System.out.println(service); service.print(); }}------------------------------------------------------------------------------------------运行结果:gavino.spring.dao.impl.DemoDaoImpl@5e3a8624gavino.spring.dao.impl.DemoDaoImpl@5e3a8624gavino.spring.service.impl.DemoServiceImpl@5c3bd550使用 spring 的 IOC 解决程序耦合 Spring 基于 XML 的 IOC 细节 BeanFactory 是 Spring 的顶层接口 BeanFactory 和 ApplicationContext 的区别 BeanFactory 才是 Spring 容器中的顶层接口。ApplicationContext 是它的子接口。 BeanFactory 和 ApplicationContext 的区别： 创建对象的时间点不一样。 ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。 BeanFactory：什么使用什么时候创建对象。 ApplicationContext 接口的实现类 ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件 推荐使用这种 FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext:当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 IOC 中 bean 标签和管理对象细节 bean 标签 作用 用于配置对象让 spring 来创建的。默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。 属性 id：给对象在容器中提供一个唯一标识。用于获取对象。class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。scope：指定对象的作用范围。* singleton :默认值，单例的.* prototype :多例的.* request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中.* session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中.* global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session.init-method：指定类中的初始化方法名称。destroy-method：指定类中销毁方法名称。 bean 的作用范围和生命周期 单例对象：scope=”singleton” 一个应用只有一个对象的实例。它的作用范围就是整个引用。生命周期：对象出生：当应用加载，创建容器时，对象就被创建了。对象活着：只要容器在，对象一直活着。对象死亡：当应用卸载，销毁容器时，对象就被销毁了。 多例对象：scope=”prototype” 每次访问对象时，都会重新创建对象实例。生命周期：对象出生：当使用对象时，创建新的对象实例。对象活着：只要对象在使用中，就一直活着。对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。 实例化 Bean 的三种方式 第一种方式：使用默认无参构造函数 1234&lt;!--在默认情况下：它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;gavino.spring.service.impl.AccountServiceImpl&quot;/&gt; 第二种方式：spring 管理静态工厂-使用静态工厂的方法创建对象 123456789101112131415/*** 模拟一个静态工厂，创建业务层实现类*/public class StaticFactory {public static IAccountService createAccountService(){return new AccountServiceImpl();} }&lt;!-- 此种方式是:使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器id 属性：指定 bean 的 id，用于从容器中获取class 属性：指定静态工厂的全限定类名factory-method 属性：指定生产对象的静态方法--&gt; &lt;bean id=&quot;accountService&quot;class=&quot;gavino.spring.factory.StaticFactory&quot;factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt; 第三种方式：spring 管理实例工厂-使用实例工厂的方法创建对象 12345678910111213141516/*** 模拟一个实例工厂，创建业务层实现类* 此工厂创建对象，必须现有工厂实例对象，再调用方法*/public class InstanceFactory {public IAccountService createAccountService(){return new AccountServiceImpl();} }&lt;!-- 此种方式是：先把工厂的创建交给 spring 来管理。然后在使用工厂的 bean 来调用里面的方法factory-bean 属性：用于指定实例工厂 bean 的 id。factory-method 属性：用于指定实例工厂中创建对象的方法。--&gt; &lt;bean id=&quot;instancFactory&quot; class=&quot;gavino.spring.factory.InstanceFactory&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;accountService&quot;factory-bean=&quot;instancFactory&quot;factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt; spring 的依赖注入依赖注入的概念 spring中的依赖注入 #依赖注入： Dependency Injection #IOC的作用： 降低程序间的耦合（依赖关系） #依赖关系的管理： 以后都交给spring来维护 #在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明 #依赖关系的维护： 就称之为依赖注入。 #依赖注入： *能注入的数据：有三类 基本类型和String 其他bean类型（在配置文件中或者注解配置过的bean） 复杂类型/集合类型 *注入的方式：有三种 第一种：使用构造函数提供 第二种：使用set方法提供 第三种：使用注解提供 构造函数注入12345678910111213141516171819 private String name;//String类型 private Integer id;//基本数据类型 private Date time;//其它Bean类型//提供构造函数 public DemoServiceImpl(String name, Integer id, Date time) { this.name = name; this.id = id; this.time = time; }//测试方法 @Test public void print() { System.out.println(&quot;----------测试构造函数注入 基本数据类型和String-----------&quot;); System.out.println(&quot;id:&quot;+id+&quot; name:&quot;+name+&quot; &quot;); System.out.println(&quot;----------测试构造函数注入 其它Bean类型-----------&quot;); System.out.println(&quot;time:&quot;+time); } bean.xml文件中的配置 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置 dao --&gt; &lt;bean id=&quot;demoDao&quot; class=&quot;gavino.spring.dao.impl.DemoDaoImpl&quot;&gt;&lt;/bean&gt; &lt;!-- 配置 service --&gt; &lt;bean id=&quot;demoService&quot; class=&quot;gavino.spring.service.impl.DemoServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;id&quot; value=&quot;101&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;依赖注入&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;time&quot; ref=&quot;date&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 在测试类中测试是否注入成功 1234567891011121314151617/** * @author Yan weigang */public class DITest { @Test public void testConstructor(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); IDemoService service = context.getBean(&quot;demoService&quot;, IDemoService.class); service.print(); }}########################## 测试输出如下 ####################################----------测试构造函数注入 基本数据类型和String-----------id:101 name:依赖注入 ----------测试构造函数注入 其它Bean类型-----------time:Mon Aug 26 19:46:18 CST 2019 set 方法注入注掉构造方法，提供相应的set方法 1234567891011121314151617181920212223242526272829303132/** * @author Yan weigang */public class DemoServiceImpl implements IDemoService { private String name; private Integer id; private Date time;// IDemoDao dao = new DemoDaoImpl();//将通过ioc解决这种依赖关系// private IDemoDao dao;// public DemoServiceImpl(String name, Integer id, Date time) {// this.name = name;// this.id = id;// this.time = time;// } public void setName(String name) { this.name = name; } public void setId(Integer id) { this.id = id; } public void setTime(Date time) { this.time = time; } @Test public void print() { System.out.println(&quot;----------测试构造函数注入 基本数据类型和String-----------&quot;); System.out.println(&quot;id:&quot;+id+&quot; name:&quot;+name+&quot; &quot;); System.out.println(&quot;----------测试构造函数注入 其它Bean类型-----------&quot;); System.out.println(&quot;time:&quot;+time); }} 修改bean.xml配置文件 123456&lt;bean id=&quot;demoService&quot; class=&quot;gavino.spring.service.impl.DemoServiceImpl&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;020&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;set方法注入&quot;&gt;&lt;/property&gt; &lt;property name=&quot;time&quot; ref=&quot;date&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; 测试类中测试是否注入成功 1234567891011 @Test public void testConstructor(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); IDemoService service = context.getBean(&quot;demoService&quot;, IDemoService.class); service.print(); }============================= 测试输出如下 ====================================----------测试构造函数注入 基本数据类型和String-----------id:20 name:set方法注入 ----------测试构造函数注入 其它Bean类型-----------time:Mon Aug 26 20:01:38 CST 2019 使用 p 名称空间注入数据（本质还是调用 set 方法）使用 p 名称空间注入，使用 p:propertyName 来注入数据，它的本质仍然是调用类中的set 方法实现注入功能。依然提供相应的set方法，代码如在set 方法中注入一样修改bean.xml配置文件： 1xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- p名称空间注入 --&gt; &lt;bean id=&quot;demoService&quot; class=&quot;gavino.spring.service.impl.DemoServiceImpl&quot; p:id=&quot;303&quot; p:name=&quot;p名称空间注入&quot; p:time-ref=&quot;date&quot;/&gt; &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 测试类中测试是否注入成功 12345++++++++++++++++++++++++++ 测试输出如下 +++++++++++++++++++++++++++++++++++++----------测试构造函数注入 基本数据类型和String-----------id:303 name:p名称空间注入 ----------测试构造函数注入 其它Bean类型-----------time:Mon Aug 26 20:10:11 CST 2019 注入集合属性注入集合属性，用的也是set方法注入的方式，只不过变量的数据类型都是集合。 123456789101112131415161718192021222324252627282930313233343536373839404142package gavino.spring.service.impl;import gavino.spring.dao.IDemoDao;import gavino.spring.dao.impl.DemoDaoImpl;import gavino.spring.service.IDemoService;import org.junit.Test;import java.util.*;/** * @author Yan weigang */public class DemoServiceImpl implements IDemoService { private String[] str; private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String,String&gt; map; private Properties props; //提供set方法 public void setStr(String[] str) { this.str = str; } public void setList(List&lt;String&gt; list) { this.list = list; } public void setSet(Set&lt;String&gt; set) { this.set = set; } public void setMap(Map&lt;String, String&gt; map) { this.map = map; } public void setProps(Properties props) { this.props = props; } @Test public void print() { System.out.println(Arrays.toString(str)); System.out.println(list); System.out.println(set); System.out.println(map); System.out.println(props); }} 配置bean.xml配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;bean id=&quot;demoService&quot; class=&quot;gavino.spring.service.impl.DemoServiceImpl&quot;&gt; &lt;property name=&quot;str&quot;&gt; &lt;array&gt; &lt;value&gt;数组元素1&lt;/value&gt; &lt;value&gt;数组元素2&lt;/value&gt; &lt;value&gt;数组元素3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;list&quot; &gt; &lt;list&gt; &lt;value&gt;列表A&lt;/value&gt; &lt;value&gt;列表B&lt;/value&gt; &lt;value&gt;列表C&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;set 1&lt;/value&gt; &lt;value&gt;set 2&lt;/value&gt; &lt;value&gt;set 3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;testB&quot;&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;props&quot;&gt; &lt;props&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类中测试是否注入成功 123456============================ 测试输出如下 ===================================[数组元素1, 数组元素2, 数组元素3][列表A, 列表B, 列表C][set 1, set 2, set 3]{testA=aaa, testB=bbb}{password=root, username=root} 四、基于注解的 IOC配置环境搭建明确： 注解配置和 xml 配置要实现的功能都是一样的，都是要降低程序间的耦合。只是配置的形式不一样。 (一)导入相关依赖(二)使用@Component 注解配置管理的资源(三)创建 spring 的 xml 配置文件并开启对注解的支持注意:基于注解整合时，导入约束时需要多导入一个 context 名称空间下的约束。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 告知 spring 创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package=&quot;gavino.spring&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 常用注解 用于创建对象的( 相当于：&lt;bean id=”” class=””&gt; ) @Component 作用：把资源让 spring 来管理。相当于在 xml 中配置一个 bean。 属性：value：指定 bean 的 id。如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。 @Controller 一般用于表现层的注解。 @Service 一般用于业务层的注解。 @Repository 一般用于持久层的注解。 注意@Controller、@Service、@Repository 三个注解都是针对一个的衍生注解，他们的作用及属性都是一模一样的。它们只不过是提供了更加明确的语义化。如果注解中有且只有一个属性要赋值时，且名称是 value，value 在赋值时可以不写。 用于注入数据的( 相当于：&lt;property name=”” ref=””&gt; &lt;property name=”” value=””&gt; ) @Autowired 作用：自动按照类型注入。当使用注解注入属性时，set 方法可以省略。它只能注入其他 bean 类型。当有多个类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到就报错。 @Qualifier 作用：在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。它在给字段注入时不能独立使用，必须和@Autowire 一起使用；但是给方法参数注入时，可以独立使用。 属性：value：指定 bean 的 id。 @Resource 作用：直接按照 Bean 的 id 注入。它也只能注入其他 bean 类型。 属性：name：指定 bean 的 id。 @Value 作用：注入基本数据类型和 String 类型数据的 属性：value：用于指定值 用于改变作用范围 @Scope( 相当于：&lt;bean id=”” class=”” scope=””&gt; ) 作用：指定 bean 的作用范围。 属性：value：指定范围的值。取值：singleton prototype request session globalsession 和生命周期相关的( 相当于：&lt;bean id=”” class=”” init-method=”” destroy-method=”” /&gt; ) @PostConstruct 作用：用于指定初始化方法。 @PreDestroy 作用：用于指定销毁方法。 其他新注解 @Configuration @ComponentScan @Bean @PropertySource @Import 注意 关于Spring 和 XML 的选择问题注解的优势配置简单XML的优势修改时不用修改源码 五、Spring 整合 Junit说在前面 spring整合Junit时，Junit4 和 Junit5 的代码形式并不一样 123456//@RunWith(SpringJUnit4ClassRunner.class)//junit4环境下@ExtendWith(SpringExtension.class)//junit5环境下@ContextConfiguration(classes = SpringConfiguration.class)public class AccountServiceTest { ......} Spring整合junit的配置 1、导入spring整合junit的jar(坐标)2、使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的@Runwith(junit4环境下),若导入的是Junit5的坐标，则应替换为@ExtendWith3、告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置*@ContextConfiguration的说明： locations：指定xml文件的位置，加上classpath关键字，表示在类路径下 classes：指定注解类所在地位置 六、AOP 的相关概念连接点即方法被增强的方法才是切入点，切入点一定是连接点，但连接点不一定是切入点切面切入点表达式 七、Spring 中的 AOP八、Spring 中的 JdbcTemplateJdbcTemplate的作用 九、Spring 中的事务控制十、总结","link":"/2019/08/24/这就是Spring/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"框架","slug":"框架","link":"/tags/框架/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"命令","slug":"命令","link":"/tags/命令/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"Sublime","slug":"Sublime","link":"/tags/Sublime/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"Cookie","slug":"Cookie","link":"/tags/Cookie/"},{"name":"Session","slug":"Session","link":"/tags/Session/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"源码","slug":"源码","link":"/tags/源码/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"springMVC","slug":"springMVC","link":"/tags/springMVC/"}],"categories":[{"name":"Java 基础篇","slug":"Java-基础篇","link":"/categories/Java-基础篇/"},{"name":"SSM","slug":"SSM","link":"/categories/SSM/"},{"name":"web 前端","slug":"web-前端","link":"/categories/web-前端/"},{"name":"常用工具","slug":"常用工具","link":"/categories/常用工具/"},{"name":"Java 虚拟机","slug":"Java-虚拟机","link":"/categories/Java-虚拟机/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"剑指offer","slug":"剑指offer","link":"/categories/剑指offer/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"教程","slug":"教程","link":"/categories/教程/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"数据库","slug":"数据库","link":"/categories/数据库/"},{"name":"源码分析","slug":"源码分析","link":"/categories/源码分析/"}]}